{
  "address": "0xA5F1e012619D08a698dc37f6e34AbA254A846DcF",
  "abi": [
    {
      "inputs": [],
      "name": "ERC721AddressZeroIsNotaValidOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721ApprovalToCurrentOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721ApproveCallerIsNotOwnerNorApprovedForAll",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721ApproveToCaller",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721InvalidTokenId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721MintToTheZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721NotApprovedOrOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721TokenAlreadyMinted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721TransferFromIncorrectOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721TransferToNonReceiverImplementer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721TransferToTheZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "IndexOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKApprovalForAssetsToCurrentOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKAssetAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKBadConfig",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKBadPriorityListLength",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKCannotTransferSoulbound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKCatalogRequiredForParts",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKChildAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKChildIndexOutOfRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKEquippableEquipNotAllowedByCatalog",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKIdZeroForbidden",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKIndexOutOfRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKIsNotContract",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKMaxPendingAssetsReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKMaxPendingChildrenReached",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "childContract",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        }
      ],
      "name": "RMRKMaxRecursiveBurnsReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKMustUnequipFirst",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNestableTooDeep",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNestableTransferToDescendant",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNestableTransferToNonRMRKNestableImplementer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNestableTransferToSelf",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNoAssetMatchingId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNotApprovedForAssetsOrOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNotApprovedOrDirectOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKNotEquipped",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKPartAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKPartDoesNotExist",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKPartIsNotSlot",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKPendingChildIndexOutOfRange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKSlotAlreadyUsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKTargetAssetCannotReceiveSlot",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKTokenCannotBeEquippedWithAssetIntoSlot",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKTokenDoesNotHaveAsset",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKUnexpectedAssetId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKUnexpectedChildId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKUnexpectedNumberOfAssets",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RMRKUnexpectedNumberOfChildren",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RentrantCall",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "partId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "equippableAddresses",
          "type": "address[]"
        }
      ],
      "name": "AddedEquippables",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "partId",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "enum IRMRKCatalog.ItemType",
          "name": "itemType",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "zIndex",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "equippableAddresses",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        }
      ],
      "name": "AddedPart",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "AllChildrenRejected",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAllForAssets",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ApprovalForAssets",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "replacesId",
          "type": "uint64"
        }
      ],
      "name": "AssetAccepted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "replacesId",
          "type": "uint64"
        }
      ],
      "name": "AssetAddedToTokens",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "AssetPrioritySet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        }
      ],
      "name": "AssetRejected",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        }
      ],
      "name": "AssetSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "childIndex",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        }
      ],
      "name": "ChildAccepted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "slotPartId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "childAssetId",
          "type": "uint64"
        }
      ],
      "name": "ChildAssetEquipped",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "slotPartId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "childAssetId",
          "type": "uint64"
        }
      ],
      "name": "ChildAssetUnequipped",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "childIndex",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        }
      ],
      "name": "ChildProposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "childIndex",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "fromPending",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "toZero",
          "type": "bool"
        }
      ],
      "name": "ChildTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fromTokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "toTokenId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "NestTransfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "partId",
          "type": "uint64"
        }
      ],
      "name": "SetEquippableToAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "partId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "equippableAddresses",
          "type": "address[]"
        }
      ],
      "name": "SetEquippables",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "state",
          "type": "bool"
        }
      ],
      "name": "Soulbound",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "equippableGroupId",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "slotPartId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "parentAddress",
          "type": "address"
        }
      ],
      "name": "ValidParentEquippableGroupIdSet",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "RMRK_INTERFACE",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "rmrkInterface",
          "type": "bytes4"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "version",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        }
      ],
      "name": "acceptAsset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "parentId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "childIndex",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        }
      ],
      "name": "acceptChild",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "parentId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "addChild",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "equippables",
          "type": "address[]"
        },
        {
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        },
        {
          "internalType": "uint64",
          "name": "_partId",
          "type": "uint64"
        }
      ],
      "name": "addPart",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "approveForAssets",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "burn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxChildrenBurns",
          "type": "uint256"
        }
      ],
      "name": "burn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "burnedChildren",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "parent",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "slotId",
          "type": "uint64"
        }
      ],
      "name": "canTokenBeEquippedWithAssetIntoSlot",
      "outputs": [
        {
          "internalType": "bool",
          "name": "canBeEquipped",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "partId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "targetAddress",
          "type": "address"
        }
      ],
      "name": "checkIsEquippable",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isEquippable",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "partId",
          "type": "uint64"
        }
      ],
      "name": "checkIsEquippableToAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isEquippable",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "parentId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "childOf",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            }
          ],
          "internalType": "struct IERC7401.Child",
          "name": "child",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "parentId",
          "type": "uint256"
        }
      ],
      "name": "childrenOf",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            }
          ],
          "internalType": "struct IERC7401.Child[]",
          "name": "children",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "directOwnerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "parentId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isNFT",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "childIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint64",
              "name": "assetId",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "slotPartId",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "childAssetId",
              "type": "uint64"
            }
          ],
          "internalType": "struct IERC6220.IntakeEquip",
          "name": "data",
          "type": "tuple"
        }
      ],
      "name": "equip",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "equippableGroupId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "parentAddress",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "slotPartId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "childIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint64",
              "name": "assetId",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "slotPartId",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "childAssetId",
              "type": "uint64"
            }
          ],
          "internalType": "struct IERC6220.IntakeEquip",
          "name": "data",
          "type": "tuple"
        }
      ],
      "name": "equipToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getActiveAssetPriorities",
      "outputs": [
        {
          "internalType": "uint64[]",
          "name": "priorities",
          "type": "uint64[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getActiveAssets",
      "outputs": [
        {
          "internalType": "uint64[]",
          "name": "assetIds",
          "type": "uint64[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "approved",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApprovedForAssets",
      "outputs": [
        {
          "internalType": "address",
          "name": "approved",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        }
      ],
      "name": "getAssetAndEquippableData",
      "outputs": [
        {
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        },
        {
          "internalType": "uint64",
          "name": "equippableGroupId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "catalogAddress",
          "type": "address"
        },
        {
          "internalType": "uint64[]",
          "name": "partIds",
          "type": "uint64[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        }
      ],
      "name": "getAssetMetadata",
      "outputs": [
        {
          "internalType": "string",
          "name": "metadata",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "newAssetId",
          "type": "uint64"
        }
      ],
      "name": "getAssetReplacements",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "replacesAssetId",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "targetCatalogAddress",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "slotPartId",
          "type": "uint64"
        }
      ],
      "name": "getEquipment",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "assetId",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "childAssetId",
              "type": "uint64"
            },
            {
              "internalType": "uint256",
              "name": "childId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "childEquippableAddress",
              "type": "address"
            }
          ],
          "internalType": "struct IERC6220.Equipment",
          "name": "equipment",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getMetadataURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getParentTokens",
      "outputs": [
        {
          "internalType": "uint64[]",
          "name": "",
          "type": "uint64[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "partId",
          "type": "uint64"
        }
      ],
      "name": "getPart",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum IRMRKCatalog.ItemType",
              "name": "itemType",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "z",
              "type": "uint8"
            },
            {
              "internalType": "address[]",
              "name": "equippable",
              "type": "address[]"
            },
            {
              "internalType": "string",
              "name": "metadataURI",
              "type": "string"
            }
          ],
          "internalType": "struct IRMRKCatalog.Part",
          "name": "part",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64[]",
          "name": "partIds",
          "type": "uint64[]"
        }
      ],
      "name": "getParts",
      "outputs": [
        {
          "components": [
            {
              "internalType": "enum IRMRKCatalog.ItemType",
              "name": "itemType",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "z",
              "type": "uint8"
            },
            {
              "internalType": "address[]",
              "name": "equippable",
              "type": "address[]"
            },
            {
              "internalType": "string",
              "name": "metadataURI",
              "type": "string"
            }
          ],
          "internalType": "struct IRMRKCatalog.Part[]",
          "name": "parts",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getPendingAssets",
      "outputs": [
        {
          "internalType": "uint64[]",
          "name": "assetIds",
          "type": "uint64[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTokenId",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getType",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isApproved",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAllForAssets",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isApproved",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        }
      ],
      "name": "isChildEquipped",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isEquipped",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "isTransferable",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isTransferable_",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        },
        {
          "internalType": "address[]",
          "name": "equippables",
          "type": "address[]"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "token_id",
          "type": "uint64"
        },
        {
          "internalType": "string",
          "name": "metadataURI",
          "type": "string"
        }
      ],
      "name": "mintChild",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "nestTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "parentId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "pendingChildOf",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            }
          ],
          "internalType": "struct IERC7401.Child",
          "name": "child",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "parentId",
          "type": "uint256"
        }
      ],
      "name": "pendingChildrenOf",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "contractAddress",
              "type": "address"
            }
          ],
          "internalType": "struct IERC7401.Child[]",
          "name": "children",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxRejections",
          "type": "uint256"
        }
      ],
      "name": "rejectAllAssets",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxRejections",
          "type": "uint256"
        }
      ],
      "name": "rejectAllChildren",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        }
      ],
      "name": "rejectAsset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAllForAssets",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint64[]",
          "name": "priorities",
          "type": "uint64[]"
        }
      ],
      "name": "setPriority",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "equippableGroupId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "parentAddress",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "slotPartId",
          "type": "uint64"
        }
      ],
      "name": "setValidParentForEquippableGroup",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "destinationId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "childIndex",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "childAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "childId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isPending",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "transferChild",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "assetId",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "slotPartId",
          "type": "uint64"
        }
      ],
      "name": "unequip",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xba61d9ca3920960d011352d0a52471c2efb6eb2e1413cbbde50dd4c73a601bc7",
  "receipt": {
    "to": null,
    "from": "0x79827dAE626421e3E4e548FF524b23d2A3ad776E",
    "contractAddress": "0xA5F1e012619D08a698dc37f6e34AbA254A846DcF",
    "transactionIndex": 0,
    "gasUsed": "5230572",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8537b2074ac8569716eee700f673a44035cc3b9e08be0e2c5dae60ac62bf2778",
    "transactionHash": "0xba61d9ca3920960d011352d0a52471c2efb6eb2e1413cbbde50dd4c73a601bc7",
    "logs": [],
    "blockNumber": 192479,
    "cumulativeGasUsed": "5230572",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "73623be5649659c8fe18dc3bf5f392c8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ERC721AddressZeroIsNotaValidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721ApproveCallerIsNotOwnerNorApprovedForAll\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721InvalidTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721MintToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721NotApprovedOrOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TokenAlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferToNonReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKApprovalForAssetsToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKAssetAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKBadConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKBadPriorityListLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKCannotTransferSoulbound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKCatalogRequiredForParts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKChildAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKChildIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKEquippableEquipNotAllowedByCatalog\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKIdZeroForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKIsNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKMaxPendingAssetsReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKMaxPendingChildrenReached\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"childContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"}],\"name\":\"RMRKMaxRecursiveBurnsReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKMustUnequipFirst\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNestableTooDeep\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNestableTransferToDescendant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNestableTransferToNonRMRKNestableImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNestableTransferToSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNoAssetMatchingId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotApprovedForAssetsOrOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotApprovedOrDirectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKNotEquipped\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKPartAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKPartDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKPartIsNotSlot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKPendingChildIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKSlotAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKTargetAssetCannotReceiveSlot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKTokenCannotBeEquippedWithAssetIntoSlot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKTokenDoesNotHaveAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKUnexpectedAssetId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKUnexpectedChildId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKUnexpectedNumberOfAssets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RMRKUnexpectedNumberOfChildren\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"partId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"equippableAddresses\",\"type\":\"address[]\"}],\"name\":\"AddedEquippables\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"partId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"enum IRMRKCatalog.ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"zIndex\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"equippableAddresses\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"name\":\"AddedPart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AllChildrenRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAllForAssets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ApprovalForAssets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"replacesId\",\"type\":\"uint64\"}],\"name\":\"AssetAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"replacesId\",\"type\":\"uint64\"}],\"name\":\"AssetAddedToTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AssetPrioritySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"}],\"name\":\"AssetRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"}],\"name\":\"AssetSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"}],\"name\":\"ChildAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"childAssetId\",\"type\":\"uint64\"}],\"name\":\"ChildAssetEquipped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"childAssetId\",\"type\":\"uint64\"}],\"name\":\"ChildAssetUnequipped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"}],\"name\":\"ChildProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"fromPending\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toZero\",\"type\":\"bool\"}],\"name\":\"ChildTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NestTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"partId\",\"type\":\"uint64\"}],\"name\":\"SetEquippableToAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"partId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"equippableAddresses\",\"type\":\"address[]\"}],\"name\":\"SetEquippables\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"Soulbound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"equippableGroupId\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"}],\"name\":\"ValidParentEquippableGroupIdSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RMRK_INTERFACE\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"rmrkInterface\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"}],\"name\":\"acceptAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"}],\"name\":\"acceptChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"addChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"equippables\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"_partId\",\"type\":\"uint64\"}],\"name\":\"addPart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approveForAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxChildrenBurns\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burnedChildren\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slotId\",\"type\":\"uint64\"}],\"name\":\"canTokenBeEquippedWithAssetIntoSlot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canBeEquipped\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"partId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"checkIsEquippable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEquippable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"partId\",\"type\":\"uint64\"}],\"name\":\"checkIsEquippableToAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEquippable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"childOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"internalType\":\"struct IERC7401.Child\",\"name\":\"child\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"}],\"name\":\"childrenOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"internalType\":\"struct IERC7401.Child[]\",\"name\":\"children\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"directOwnerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isNFT\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"childAssetId\",\"type\":\"uint64\"}],\"internalType\":\"struct IERC6220.IntakeEquip\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"equip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"equippableGroupId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"childAssetId\",\"type\":\"uint64\"}],\"internalType\":\"struct IERC6220.IntakeEquip\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"equipToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getActiveAssetPriorities\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"priorities\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getActiveAssets\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"assetIds\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApprovedForAssets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"}],\"name\":\"getAssetAndEquippableData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"equippableGroupId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"catalogAddress\",\"type\":\"address\"},{\"internalType\":\"uint64[]\",\"name\":\"partIds\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"}],\"name\":\"getAssetMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"newAssetId\",\"type\":\"uint64\"}],\"name\":\"getAssetReplacements\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"replacesAssetId\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetCatalogAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"}],\"name\":\"getEquipment\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"childAssetId\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"childEquippableAddress\",\"type\":\"address\"}],\"internalType\":\"struct IERC6220.Equipment\",\"name\":\"equipment\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMetadataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getParentTokens\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"partId\",\"type\":\"uint64\"}],\"name\":\"getPart\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IRMRKCatalog.ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"z\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"equippable\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"internalType\":\"struct IRMRKCatalog.Part\",\"name\":\"part\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"partIds\",\"type\":\"uint64[]\"}],\"name\":\"getParts\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IRMRKCatalog.ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"z\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"equippable\",\"type\":\"address[]\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"internalType\":\"struct IRMRKCatalog.Part[]\",\"name\":\"parts\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPendingAssets\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"assetIds\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAllForAssets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"}],\"name\":\"isChildEquipped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEquipped\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"isTransferable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isTransferable_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"equippables\",\"type\":\"address[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"token_id\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"}],\"name\":\"mintChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"nestTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pendingChildOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"internalType\":\"struct IERC7401.Child\",\"name\":\"child\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parentId\",\"type\":\"uint256\"}],\"name\":\"pendingChildrenOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"internalType\":\"struct IERC7401.Child[]\",\"name\":\"children\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRejections\",\"type\":\"uint256\"}],\"name\":\"rejectAllAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRejections\",\"type\":\"uint256\"}],\"name\":\"rejectAllChildren\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"}],\"name\":\"rejectAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAllForAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64[]\",\"name\":\"priorities\",\"type\":\"uint64[]\"}],\"name\":\"setPriority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"equippableGroupId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"}],\"name\":\"setValidParentForEquippableGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"childId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPending\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"assetId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"slotPartId\",\"type\":\"uint64\"}],\"name\":\"unequip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"RMRKIdZeroForbidden()\":[{\"details\":\"The ID 0 in RMRK suite is reserved for empty values. Guarding against its use ensures the expected operation\"}],\"RMRKMaxRecursiveBurnsReached(address,uint256)\":[{\"params\":{\"childContract\":\"Address of the collection smart contract in which the maximum number of recursive burns was reached\",\"childId\":\"ID of the child token at which the maximum number of recursive burns was reached\"}}],\"RMRKNotApprovedOrDirectOwner()\":[{\"details\":\"When a token is nested, only the direct owner (NFT parent) can mange it. In that case, approved addresses are  not allowed to manage it, in order to ensure the expected behaviour\"}]},\"events\":{\"AddedEquippables(uint64,address[])\":{\"details\":\"It is emitted when new addresses are marked as equippable for `partId`.\",\"params\":{\"equippableAddresses\":\"An array of the new addresses that can equip this part\",\"partId\":\"ID of the part that had new equippable addresses added\"}},\"AddedPart(uint64,uint8,uint8,address[],string)\":{\"details\":\"It is emitted when a new part is added.\",\"params\":{\"equippableAddresses\":\"An array of addresses that can equip this part\",\"itemType\":\"Enum value specifying whether the part is `None`, `Slot` and `Fixed`\",\"metadataURI\":\"The metadata URI of the part\",\"partId\":\"ID of the part that was added\",\"zIndex\":\"An uint specifying the z value of the part. It is used to specify the depth which the part should  be rendered at\"}},\"AllChildrenRejected(uint256)\":{\"details\":\"Emitted when a token removes all a child tokens from its pending array.\",\"params\":{\"tokenId\":\"ID of the token that rejected all of the pending children\"}},\"Approval(address,address,uint256)\":{\"details\":\"Emitted when `owner` enables `approved` to manage the `tokenId` token.\"},\"ApprovalForAll(address,address,bool)\":{\"details\":\"Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\"},\"ApprovalForAllForAssets(address,address,bool)\":{\"params\":{\"approved\":\"Boolean value signifying whether the permission has been granted (`true`) or revoked (`false`)\",\"operator\":\"Address of the account that has been granted the approval to manage the token's assets on all of  the tokens\",\"owner\":\"Address of the account that has granted the approval for all assets on all of their tokens\"}},\"ApprovalForAssets(address,address,uint256)\":{\"details\":\"Approvals must be cleared on transfer\",\"params\":{\"approved\":\"Address of the account that has been granted approval to manage the token's assets\",\"owner\":\"Address of the account that has granted the approval for all token's assets\",\"tokenId\":\"ID of the token on which the approval was granted\"}},\"AssetAccepted(uint256,uint64,uint64)\":{\"params\":{\"assetId\":\"ID of the asset that was accepted\",\"replacesId\":\"ID of the asset that was replaced\",\"tokenId\":\"ID of the token that had a new asset accepted\"}},\"AssetAddedToTokens(uint256[],uint64,uint64)\":{\"params\":{\"assetId\":\"ID of the asset that has been added to the token's pending assets array\",\"replacesId\":\"ID of the asset that would be replaced\",\"tokenIds\":\"An array of token IDs that received a new pending asset\"}},\"AssetPrioritySet(uint256)\":{\"params\":{\"tokenId\":\"ID of the token that had the asset priority array updated\"}},\"AssetRejected(uint256,uint64)\":{\"params\":{\"assetId\":\"ID of the asset that was rejected\",\"tokenId\":\"ID of the token that had an asset rejected\"}},\"AssetSet(uint64)\":{\"params\":{\"assetId\":\"ID of the asset that was initialized\"}},\"ChildAccepted(uint256,uint256,address,uint256)\":{\"details\":\"Emitted when a parent token accepts a token from its pending array, migrating it to the active array.\",\"params\":{\"childAddress\":\"Address of the child token's collection smart contract\",\"childId\":\"ID of the child token in the child token's collection smart contract\",\"childIndex\":\"Index of the newly accepted child token in the parent token's active children array\",\"tokenId\":\"ID of the token that accepted a new child token\"}},\"ChildAssetEquipped(uint256,uint64,uint64,uint256,address,uint64)\":{\"params\":{\"assetId\":\"ID of the asset associated with the token we are equipping into\",\"childAddress\":\"Address of the child token's collection\",\"childAssetId\":\"ID of the asset associated with the token we are equipping\",\"childId\":\"ID of the child token we are equipping into the slot\",\"slotPartId\":\"ID of the slot we are using to equip\",\"tokenId\":\"ID of the token that had an asset equipped\"}},\"ChildAssetUnequipped(uint256,uint64,uint64,uint256,address,uint64)\":{\"params\":{\"assetId\":\"ID of the asset associated with the token we are unequipping out of\",\"childAddress\":\"Address of the collection that a token that is being unequipped belongs to\",\"childAssetId\":\"ID of the asset associated with the token we are unequipping\",\"childId\":\"ID of the token being unequipped\",\"slotPartId\":\"ID of the slot we are unequipping from\",\"tokenId\":\"ID of the token that had an asset unequipped\"}},\"ChildProposed(uint256,uint256,address,uint256)\":{\"details\":\"Emitted when a child NFT is added to a token's pending array.\",\"params\":{\"childAddress\":\"Address of the proposed child token's collection smart contract\",\"childId\":\"ID of the child token in the child token's collection smart contract\",\"childIndex\":\"Index of the proposed child token in the parent token's pending children array\",\"tokenId\":\"ID of the token that received a new pending child token\"}},\"ChildTransferred(uint256,uint256,address,uint256,bool,bool)\":{\"details\":\"Emitted when a token transfers a child from itself, transferring ownership to the root owner.\",\"params\":{\"childAddress\":\"Address of the child token's collection smart contract\",\"childId\":\"ID of the child token in the child token's collection smart contract\",\"childIndex\":\"Index of a child in the array from which it is being transferred\",\"fromPending\":\"A boolean value signifying whether the token was in the pending child tokens array (`true`) or  in the active child tokens array (`false`)\",\"toZero\":\"A boolean value signifying whether the token is being transferred to the `0x0` address (`true`) or  not (`false`)\",\"tokenId\":\"ID of the token that transferred a child token\"}},\"NestTransfer(address,address,uint256,uint256,uint256)\":{\"details\":\"Emitted when `tokenId` token is transferred from `from` to `to`.\",\"params\":{\"from\":\"Address of the previous immediate owner, which is a smart contract if the token was nested.\",\"fromTokenId\":\"ID of the previous parent token. If the token was not nested before, the value should be `0`\",\"to\":\"Address of the new immediate owner, which is a smart contract if the token is being nested.\",\"toTokenId\":\"ID of the new parent token. If the token is not being nested, the value should be `0`\",\"tokenId\":\"ID of the token being transferred\"}},\"SetEquippableToAll(uint64)\":{\"details\":\"It is emitted when a given part is marked as equippable by any.\",\"params\":{\"partId\":\"ID of the part marked as equippable by any address\"}},\"SetEquippables(uint64,address[])\":{\"details\":\"It is emitted when the existing list of addresses marked as equippable for `partId` is overwritten by a new one.\",\"params\":{\"equippableAddresses\":\"The new, full, list of addresses that can equip this part\",\"partId\":\"ID of the part whose list of equippable addresses was overwritten\"}},\"Soulbound(uint256,bool)\":{\"params\":{\"state\":\"A boolean value signifying whether the token became soulbound (`true`) or transferrable (`false`)\",\"tokenId\":\"ID of the token\"}},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `tokenId` token is transferred from `from` to `to`.\"},\"ValidParentEquippableGroupIdSet(uint64,uint64,address)\":{\"params\":{\"equippableGroupId\":\"ID of the equippable group being marked as equippable into the slot associated with  `slotPartId` of the `parentAddress` collection\",\"parentAddress\":\"Address of the collection into which the parts belonging to `equippableGroupId` can be  equipped\",\"slotPartId\":\"ID of the slot part of the catalog into which the parts belonging to the equippable group  associated with `equippableGroupId` can be equipped\"}}},\"kind\":\"dev\",\"methods\":{\"RMRK_INTERFACE()\":{\"returns\":{\"rmrkInterface\":\"Interface identifier for implementations of the @rmrk-team/evm-contracts package\"}},\"VERSION()\":{\"returns\":{\"version\":\"Version identifier for implementations of the @rmrk-team/evm-contracts package\"}},\"acceptAsset(uint256,uint256,uint64)\":{\"details\":\"Migrates the asset from the token's pending asset array to the token's active asset array.Active assets cannot be removed by anyone, but can be replaced by a new asset.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.  - `index` must be in range of the length of the pending asset array.Emits an {AssetAccepted} event.\",\"params\":{\"assetId\":\"ID of the asset that is being accepted\",\"index\":\"Index of the asset in the pending array to accept\",\"tokenId\":\"ID of the token for which to accept the pending asset\"}},\"acceptChild(uint256,uint256,address,uint256)\":{\"details\":\"This moves the child token from parent token's pending child tokens array into the active child tokens  array.\",\"params\":{\"childAddress\":\"Address of the collection smart contract of the child token expected to be located at the  specified index of the given parent token's pending children array\",\"childId\":\"ID of the child token expected to be located at the specified index of the given parent token's  pending children array\",\"childIndex\":\"Index of a child tokem in the given parent's pending children array\",\"parentId\":\"ID of the parent token for which the child token is being accepted\"}},\"addChild(uint256,uint256,bytes)\":{\"details\":\"This adds the child token into the given parent token's pending child tokens array.Requirements:  - `directOwnerOf` on the child contract must resolve to the called contract.  - the pending array of the parent contract must not be full.\",\"params\":{\"childId\":\"ID of the new proposed child token\",\"data\":\"Additional data with no specified format\",\"parentId\":\"ID of the parent token to receive the new child token\"}},\"approve(address,uint256)\":{\"details\":\"Gives permission to `to` to transfer `tokenId` token to another account.The approval is cleared when the token is transferred.Only a single account can be approved at a time, so approving the zero address clears previous approvals.Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist.Emits an {Approval} event.\",\"params\":{\"to\":\"Address receiving the approval\",\"tokenId\":\"ID of the token for which the approval is being granted\"}},\"approveForAssets(address,uint256)\":{\"details\":\"This can only be called by the owner of the token or by an account that has been granted permission to  manage all of the owner's assets.\",\"params\":{\"to\":\"Address of the account to receive the approval to the specified token\",\"tokenId\":\"ID of the token for which we are granting the permission\"}},\"balanceOf(address)\":{\"params\":{\"owner\":\"Address of the account being checked\"},\"returns\":{\"balance\":\"The balance of the given account\"}},\"burn(uint256)\":{\"details\":\"In case the token has any child tokens, the execution will be reverted.\",\"params\":{\"tokenId\":\"ID of the token to burn\"}},\"burn(uint256,uint256)\":{\"details\":\"When a token is burned, all of its child tokens are recursively burned as well.When specifying the maximum recursive burns, the execution will be reverted if there are more children to be  burned.Setting the `maxRecursiveBurn` value to 0 will only attempt to burn the specified token and revert if there  are any child tokens present.The approvals are cleared when the token is burned.Requirements:  - `tokenId` must exist.Emits a {Transfer} event.\",\"params\":{\"maxRecursiveBurns\":\"Maximum number of tokens to recursively burn\",\"tokenId\":\"ID of the token to burn\"},\"returns\":{\"burnedChildren\":\"Number of recursively burned children\"}},\"canTokenBeEquippedWithAssetIntoSlot(address,uint256,uint64,uint64)\":{\"params\":{\"assetId\":\"ID of the asset associated with the token we want to equip\",\"parent\":\"Address of the parent token's smart contract\",\"slotId\":\"ID of the slot that we want to equip the token into\",\"tokenId\":\"ID of the token we want to equip\"},\"returns\":{\"canBeEquipped\":\"A boolean indicating whether the token with the given asset can be equipped into the desired slot\"}},\"checkIsEquippable(uint64,address)\":{\"details\":\"Returns true if a collection may equip asset with `partId`.\",\"params\":{\"partId\":\"The ID of the part that we are checking\",\"targetAddress\":\"The address that we are checking for whether the part can be equipped into it or not\"},\"returns\":{\"isEquippable\":\"The status indicating whether the `targetAddress` can be equipped into `Part` with `partId` or not\"}},\"checkIsEquippableToAll(uint64)\":{\"details\":\"Returns true if part is equippable to all.\",\"params\":{\"partId\":\"ID of the part that we are checking\"},\"returns\":{\"isEquippable\":\"The status indicating whether the part with `partId` can be equipped by any address or not\"}},\"childOf(uint256,uint256)\":{\"details\":\"Returns a single Child struct locating at `index` of parent token's active child tokens array.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]\",\"params\":{\"index\":\"Index of the child token in the parent token's active child tokens array\",\"parentId\":\"ID of the parent token for which the child is being retrieved\"},\"returns\":{\"child\":\"A Child struct containing data about the specified child\"}},\"childrenOf(uint256)\":{\"details\":\"Returns array of Child structs existing for parent token.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]\",\"params\":{\"parentId\":\"ID of the parent token for which to retrieve the active child tokens\"},\"returns\":{\"children\":\"An array of Child structs containing the parent token's active child tokens\"}},\"directOwnerOf(uint256)\":{\"details\":\"If the immediate owner is another token, the address returned, should be the one of the parent token's  collection smart contract.\",\"params\":{\"tokenId\":\"ID of the token for which the RMRK owner is being retrieved\"},\"returns\":{\"isNFT\":\"The boolean value signifying whether the owner is an NFT or not\",\"owner_\":\"Address of the given token's owner\",\"parentId\":\"The ID of the parent token. Should be `0` if the owner is an externally owned account\"}},\"equip((uint256,uint256,uint64,uint64,uint64))\":{\"details\":\"The `IntakeEquip` stuct contains the following data:  [      tokenId,      childIndex,      assetId,      slotPartId,      childAssetId  ]\",\"params\":{\"data\":\"An `IntakeEquip` struct specifying the equip data\"}},\"getActiveAssetPriorities(uint256)\":{\"details\":\"Asset priorities are a non-sequential array of uint64 values with an array size equal to active asset  priorites.\",\"params\":{\"tokenId\":\"ID of the token for which to retrieve the priorities of the active assets\"},\"returns\":{\"priorities\":\"An array of priorities of the active assets of the given token\"}},\"getActiveAssets(uint256)\":{\"details\":\"Asset data is stored by reference, in order to access the data corresponding to the ID, call  `getAssetMetadata(tokenId, assetId)`.You can safely get 10k\",\"params\":{\"tokenId\":\"ID of the token to retrieve the IDs of the active assets\"},\"returns\":{\"assetIds\":\"An array of active asset IDs of the given token\"}},\"getApproved(uint256)\":{\"details\":\"Requirements:  - `tokenId` must exist.\",\"params\":{\"tokenId\":\"ID of the token to check for approval\"},\"returns\":{\"approved\":\"Address of the account approved to manage the token\"}},\"getApprovedForAssets(uint256)\":{\"details\":\"Requirements:  - `tokenId` must exist.\",\"params\":{\"tokenId\":\"ID of the token for which to retrieve the approved address\"},\"returns\":{\"approved\":\"Address of the account that is approved to manage the specified token's assets\"}},\"getAssetAndEquippableData(uint256,uint64)\":{\"params\":{\"assetId\":\"ID of the asset of which we are retrieving\",\"tokenId\":\"ID of the token for which to retrieve the asset\"},\"returns\":{\"catalogAddress\":\"The address of the catalog the part belongs to\",\"equippableGroupId\":\"ID of the equippable group this asset belongs to\",\"metadataURI\":\"The metadata URI of the asset\",\"partIds\":\"An array of IDs of parts included in the asset\"}},\"getAssetMetadata(uint256,uint64)\":{\"details\":\"Assets are stored by reference mapping `_assets[assetId]`.Can be overriden to implement enumerate, fallback or other custom logic.\",\"params\":{\"assetId\":\"Asset Id, must be in the active assets array\",\"tokenId\":\"ID of the token from which to retrieve the asset metadata\"},\"returns\":{\"metadata\":\"The metadata of the asset belonging to the specified index in the token's active assets  array\"}},\"getAssetReplacements(uint256,uint64)\":{\"details\":\"Asset data is stored by reference, in order to access the data corresponding to the ID, call  `getAssetMetadata(tokenId, assetId)`.\",\"params\":{\"newAssetId\":\"ID of the pending asset which will be accepted\",\"tokenId\":\"ID of the token to check\"},\"returns\":{\"replacesAssetId\":\"ID of the asset which will be replaced\"}},\"getEquipment(uint256,address,uint64)\":{\"details\":\"The `Equipment` struct consists of the following data:  [      assetId,      childAssetId,      childId,      childEquippableAddress  ]\",\"params\":{\"slotPartId\":\"ID of the `Slot` part that we are checking for equipped objects\",\"targetCatalogAddress\":\"Address of the `Catalog` associated with the `Slot` part of the token\",\"tokenId\":\"ID of the token for which we are retrieving the equipped object\"},\"returns\":{\"equipment\":\"The `Equipment` struct containing data about the equipped object\"}},\"getMetadataURI()\":{\"returns\":{\"_0\":\"Catalog metadata URI\"}},\"getPart(uint64)\":{\"params\":{\"partId\":\"ID of the part that we are retrieving\"},\"returns\":{\"part\":\"The `Part` struct associated with given `partId`\"}},\"getParts(uint64[])\":{\"params\":{\"partIds\":\"An array of part IDs that we want to retrieve\"},\"returns\":{\"parts\":\"An array of `Part` structs associated with given `partIds`\"}},\"getPendingAssets(uint256)\":{\"details\":\"Asset data is stored by reference, in order to access the data corresponding to the ID, call  `getAssetMetadata(tokenId, assetId)`.\",\"params\":{\"tokenId\":\"ID of the token to retrieve the IDs of the pending assets\"},\"returns\":{\"assetIds\":\"An array of pending asset IDs of the given token\"}},\"getType()\":{\"returns\":{\"_0\":\"`itemType` of the associated Catalog\"}},\"isApprovedForAll(address,address)\":{\"params\":{\"operator\":\"Address being checked for approval\",\"owner\":\"Address of the owner of the tokens\"},\"returns\":{\"isApproved\":\"A boolean value signifying whether the *operator* is allowed to manage the tokens of the *owner* (`true`)  or not (`false`)\"}},\"isApprovedForAllForAssets(address,address)\":{\"details\":\"See {setApprovalForAllForAssets}.\",\"params\":{\"operator\":\"Address of the account that we are checking whether it has the operator role or not\",\"owner\":\"Address of the account that we are checking for whether it has granted the operator role\"},\"returns\":{\"isApproved\":\"A boolean value indicating whether the account we are checking has been granted the operator role\"}},\"isChildEquipped(uint256,address,uint256)\":{\"details\":\"This is used to prevent from transferring a child that is equipped.\",\"params\":{\"childAddress\":\"Address of the child token's smart contract\",\"childId\":\"ID of the child token\",\"tokenId\":\"ID of the parent token for which we are querying for\"},\"returns\":{\"isEquipped\":\"A boolean value indicating whether the child token is equipped into the given token or not\"}},\"isTransferable(uint256,address,address)\":{\"details\":\"If this function returns `false`, the transfer of the token MUST revert execution.If the tokenId does not exist, this method MUST revert execution, unless the token is being checked for  minting.\",\"params\":{\"from\":\"Address from which the token is being transferred\",\"to\":\"Address to which the token is being transferred\",\"tokenId\":\"ID of the token being checked\"},\"returns\":{\"isTransferable_\":\"Boolean value indicating whether the given token is transferable\"}},\"nestTransferFrom(address,address,uint256,uint256,bytes)\":{\"params\":{\"data\":\"Additional data with no specified format, sent in the addChild call\",\"destinationId\":\"ID of the token to receive the token being transferred\",\"from\":\"Address of the direct owner of the token to be transferred\",\"to\":\"Address of the receiving token's collection smart contract\",\"tokenId\":\"ID of the token being transferred\"}},\"ownerOf(uint256)\":{\"details\":\"The *root* owner of the token is an externally owned account (EOA). If the given token is child of another  NFT, this will return an EOA address. Otherwise, if the token is owned by an EOA, this EOA will be returned.\",\"params\":{\"tokenId\":\"ID of the token for which the *root* owner has been retrieved\"},\"returns\":{\"owner_\":\"The *root* owner of the token\"}},\"pendingChildOf(uint256,uint256)\":{\"details\":\"Returns a single Child struct locating at `index` of parent token's active child tokens array.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]\",\"params\":{\"index\":\"Index of the child token in the parent token's pending child tokens array\",\"parentId\":\"ID of the parent token for which the pending child token is being retrieved\"},\"returns\":{\"child\":\"A Child struct containting data about the specified child\"}},\"pendingChildrenOf(uint256)\":{\"details\":\"Returns array of pending Child structs existing for given parent.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]\",\"params\":{\"parentId\":\"ID of the parent token for which to retrieve the pending child tokens\"},\"returns\":{\"children\":\"An array of Child structs containing the parent token's pending child tokens\"}},\"rejectAllAssets(uint256,uint256)\":{\"details\":\"Effecitvely deletes the pending array.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.Emits a {AssetRejected} event with assetId = 0.\",\"params\":{\"maxRejections\":\"Maximum number of expected assets to reject, used to prevent from rejecting assets which  arrive just before this operation.\",\"tokenId\":\"ID of the token of which to clear the pending array.\"}},\"rejectAllChildren(uint256,uint256)\":{\"details\":\"Removes the children from the pending array mapping.This does not update the ownership storage data on children. If necessary, ownership can be reclaimed by the  rootOwner of the previous parent.Requirements: Requirements: - `parentId` must exist\",\"params\":{\"maxRejections\":\"Maximum number of expected children to reject, used to prevent from rejecting children which  arrive just before this operation.\",\"parentId\":\"ID of the parent token for which to reject all of the pending tokens.\"}},\"rejectAsset(uint256,uint256,uint64)\":{\"details\":\"Removes the asset from the token's pending asset array.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.  - `index` must be in range of the length of the pending asset array.Emits a {AssetRejected} event.\",\"params\":{\"assetId\":\"ID of the asset that is being rejected\",\"index\":\"Index of the asset in the pending array to be rejected\",\"tokenId\":\"ID of the token that the asset is being rejected from\"}},\"safeTransferFrom(address,address,uint256)\":{\"details\":\"Requirements:  - `from` cannot be the zero address.  - `to` cannot be the zero address.  - `tokenId` token must exist and be owned by `from`.  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.  - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.Emits a {Transfer} event.\",\"params\":{\"from\":\"Address to transfer the tokens from\",\"to\":\"Address to transfer the tokens to\",\"tokenId\":\"ID of the token to transfer\"}},\"safeTransferFrom(address,address,uint256,bytes)\":{\"details\":\"Requirements:  - `from` cannot be the zero address.  - `to` cannot be the zero address.  - `tokenId` token must exist and be owned by `from`.  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.  - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.Emits a {Transfer} event.\",\"params\":{\"data\":\"Additional data without a specified format to be sent along with the token transaction\",\"from\":\"Address to transfer the tokens from\",\"to\":\"Address to transfer the tokens to\",\"tokenId\":\"ID of the token to transfer\"}},\"setApprovalForAll(address,bool)\":{\"details\":\"Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.Requirements: - The `operator` cannot be the caller.Emits an {ApprovalForAll} event.\",\"params\":{\"approved\":\"A boolean value signifying whether the approval is being granted (`true`) or (`revoked`)\",\"operator\":\"Address of the operator being managed\"}},\"setApprovalForAllForAssets(address,bool)\":{\"details\":\"Operators can call {acceptAsset}, {rejectAsset}, {rejectAllAssets} or {setPriority} for any token  owned by the caller.Requirements:  - The `operator` cannot be the caller.Emits an {ApprovalForAllForAssets} event.\",\"params\":{\"approved\":\"The boolean value indicating whether the operator role is being granted (`true`) or revoked  (`false`)\",\"operator\":\"Address of the account to which the operator role is granted or revoked from\"}},\"setPriority(uint256,uint64[])\":{\"details\":\"The priority array is a non-sequential list of `uint64`s, where the lowest value is considered highest  priority.Value `0` of a priority is a special case equivalent to unitialized.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.  - The length of `priorities` must be equal the length of the active assets array.Emits a {AssetPrioritySet} event.\",\"params\":{\"priorities\":\"An array of priority values\",\"tokenId\":\"ID of the token to set the priorities for\"}},\"transferChild(uint256,address,uint256,uint256,address,uint256,bool,bytes)\":{\"details\":\"When transferring a child token, the owner of the token is set to `to`, or is not updated in the event of  `to` being the `0x0` address.\",\"params\":{\"childAddress\":\"Address of the child token's collection smart contract.\",\"childId\":\"ID of the child token in its own collection smart contract.\",\"childIndex\":\"Index of a token we are transferring, in the array it belongs to (can be either active array or  pending array)\",\"data\":\"Additional data with no specified format, sent in call to `_to`\",\"destinationId\":\"ID of the token to receive this child token (MUST be 0 if the destination is not a token)\",\"isPending\":\"A boolean value indicating whether the child token being transferred is in the pending array of  the parent token (`true`) or in the active array (`false`)\",\"to\":\"Address to which to transfer the token to\",\"tokenId\":\"ID of the parent token from which the child token is being transferred\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Requirements:  - `from` cannot be the zero address.  - `to` cannot be the zero address.  - `tokenId` token must be owned by `from`.  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.Emits a {Transfer} event.\",\"params\":{\"from\":\"Address from which to transfer the token from\",\"to\":\"Address to which to transfer the token to\",\"tokenId\":\"ID of the token to transfer\"}},\"unequip(uint256,uint64,uint64)\":{\"details\":\"This can only be called by the owner of the token or by an account that has been granted permission to  manage the given token by the current owner.\",\"params\":{\"assetId\":\"ID of the parent's asset that contains the `Slot` into which the child is equipped\",\"slotPartId\":\"ID of the `Slot` from which to unequip the child\",\"tokenId\":\"ID of the parent from which the child is being unequipped\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"ERC721AddressZeroIsNotaValidOwner()\":[{\"notice\":\"Attempting to grant the token to 0x0 address\"}],\"ERC721ApprovalToCurrentOwner()\":[{\"notice\":\"Attempting to grant approval to the current owner of the token\"}],\"ERC721ApproveCallerIsNotOwnerNorApprovedForAll()\":[{\"notice\":\"Attempting to grant approval when not being owner or approved for all should not be permitted\"}],\"ERC721ApproveToCaller()\":[{\"notice\":\"Attempting to grant approval to self\"}],\"ERC721InvalidTokenId()\":[{\"notice\":\"Attempting to use an invalid token ID\"}],\"ERC721MintToTheZeroAddress()\":[{\"notice\":\"Attempting to mint to 0x0 address\"}],\"ERC721NotApprovedOrOwner()\":[{\"notice\":\"Attempting to manage a token without being its owner or approved by the owner\"}],\"ERC721TokenAlreadyMinted()\":[{\"notice\":\"Attempting to mint an already minted token\"}],\"ERC721TransferFromIncorrectOwner()\":[{\"notice\":\"Attempting to transfer the token from an address that is not the owner\"}],\"ERC721TransferToNonReceiverImplementer()\":[{\"notice\":\"Attempting to safe transfer to an address that is unable to receive the token\"}],\"ERC721TransferToTheZeroAddress()\":[{\"notice\":\"Attempting to transfer the token to a 0x0 address\"}],\"RMRKApprovalForAssetsToCurrentOwner()\":[{\"notice\":\"Attempting to grant approval of assets to their current owner\"}],\"RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll()\":[{\"notice\":\"Attempting to grant approval of assets without being the caller or approved for all\"}],\"RMRKAssetAlreadyExists()\":[{\"notice\":\"Attempting to add an asset using an ID that has already been used\"}],\"RMRKBadConfig()\":[{\"notice\":\"Attempting to incorrectly configue a Catalog item\"}],\"RMRKBadPriorityListLength()\":[{\"notice\":\"Attempting to set the priorities with an array of length that doesn't match the length of active assets array\"}],\"RMRKCannotTransferSoulbound()\":[{\"notice\":\"Attempting to transfer a soulbound (non-transferrable) token\"}],\"RMRKCatalogRequiredForParts()\":[{\"notice\":\"Attempting to add an asset entry with `Part`s, without setting the `Catalog` address\"}],\"RMRKChildAlreadyExists()\":[{\"notice\":\"Attempting to accept a child that has already been accepted\"}],\"RMRKChildIndexOutOfRange()\":[{\"notice\":\"Attempting to interact with a child, using index that is higher than the number of children\"}],\"RMRKEquippableEquipNotAllowedByCatalog()\":[{\"notice\":\"Attempting to equip a `Part` with a child not approved by the Catalog\"}],\"RMRKIdZeroForbidden()\":[{\"notice\":\"Attempting to use ID 0, which is not supported\"}],\"RMRKIndexOutOfRange()\":[{\"notice\":\"Attempting to interact with an asset, using index greater than number of assets\"}],\"RMRKIsNotContract()\":[{\"notice\":\"Attempting to interact with an end-user account when the contract account is expected\"}],\"RMRKMaxPendingAssetsReached()\":[{\"notice\":\"Attempting to add a pending asset after the number of pending assets has reached the limit (default limit is  128)\"}],\"RMRKMaxPendingChildrenReached()\":[{\"notice\":\"Attempting to add a pending child after the number of pending children has reached the limit (default limit is 128)\"}],\"RMRKMaxRecursiveBurnsReached(address,uint256)\":[{\"notice\":\"Attempting to burn a total number of recursive children higher than maximum set\"}],\"RMRKMustUnequipFirst()\":[{\"notice\":\"Attempting to transfer a child before it is unequipped\"}],\"RMRKNestableTooDeep()\":[{\"notice\":\"Attempting to nest a child over the nestable limit (current limit is 100 levels of nesting)\"}],\"RMRKNestableTransferToDescendant()\":[{\"notice\":\"Attempting to nest the token to own descendant, which would create a loop and leave the looped tokens in limbo\"}],\"RMRKNestableTransferToNonRMRKNestableImplementer()\":[{\"notice\":\"Attempting to nest the token to a smart contract that doesn't support nesting\"}],\"RMRKNestableTransferToSelf()\":[{\"notice\":\"Attempting to nest the token into itself\"}],\"RMRKNoAssetMatchingId()\":[{\"notice\":\"Attempting to interact with an asset that can not be found\"}],\"RMRKNotApprovedForAssetsOrOwner()\":[{\"notice\":\"Attempting to manage an asset without owning it or having been granted permission by the owner to do so\"}],\"RMRKNotApprovedOrDirectOwner()\":[{\"notice\":\"Attempting to interact with a token without being its owner or having been granted permission by the  owner to do so\"}],\"RMRKNotEquipped()\":[{\"notice\":\"Attempting to unequip an item that isn't equipped\"}],\"RMRKPartAlreadyExists()\":[{\"notice\":\"Attempting to add a `Part` with an ID that is already used\"}],\"RMRKPartDoesNotExist()\":[{\"notice\":\"Attempting to use a `Part` that doesn't exist\"}],\"RMRKPartIsNotSlot()\":[{\"notice\":\"Attempting to use a `Part` that is `Fixed` when `Slot` kind of `Part` should be used\"}],\"RMRKPendingChildIndexOutOfRange()\":[{\"notice\":\"Attempting to interact with a pending child using an index greater than the size of pending array\"}],\"RMRKSlotAlreadyUsed()\":[{\"notice\":\"Attempting to equip an item into a slot that already has an item equipped\"}],\"RMRKTargetAssetCannotReceiveSlot()\":[{\"notice\":\"Attempting to equip an item into a `Slot` that the target asset does not implement\"}],\"RMRKTokenCannotBeEquippedWithAssetIntoSlot()\":[{\"notice\":\"Attempting to equip a child into a `Slot` and parent that the child's collection doesn't support\"}],\"RMRKTokenDoesNotHaveAsset()\":[{\"notice\":\"Attempting to compose a NFT of a token without active assets\"}],\"RMRKUnexpectedAssetId()\":[{\"notice\":\"Attempting to accept or reject an asset which does not match the one at the specified index\"}],\"RMRKUnexpectedChildId()\":[{\"notice\":\"Attempting to accept or transfer a child which does not match the one at the specified index\"}],\"RMRKUnexpectedNumberOfAssets()\":[{\"notice\":\"Attempting to reject all pending assets but more assets than expected are pending\"}],\"RMRKUnexpectedNumberOfChildren()\":[{\"notice\":\"Attempting to reject all pending children but children assets than expected are pending\"}]},\"events\":{\"AddedEquippables(uint64,address[])\":{\"notice\":\"Event to announce new equippables to the part.\"},\"AddedPart(uint64,uint8,uint8,address[],string)\":{\"notice\":\"Event to announce addition of a new part.\"},\"AllChildrenRejected(uint256)\":{\"notice\":\"Used to notify listeners that all pending child tokens of a given token have been rejected.\"},\"ApprovalForAllForAssets(address,address,bool)\":{\"notice\":\"Used to notify listeners that owner has granted approval to the user to manage assets of all of their  tokens.\"},\"ApprovalForAssets(address,address,uint256)\":{\"notice\":\"Used to notify listeners that owner has granted an approval to the user to manage the assets of a  given token.\"},\"AssetAccepted(uint256,uint64,uint64)\":{\"notice\":\"Used to notify listeners that an asset object at `assetId` is accepted by the token and migrated  from token's pending assets array to active assets array of the token.\"},\"AssetAddedToTokens(uint256[],uint64,uint64)\":{\"notice\":\"Used to notify listeners that an asset object at `assetId` is added to token's pending asset  array.\"},\"AssetPrioritySet(uint256)\":{\"notice\":\"Used to notify listeners that token's prioritiy array is reordered.\"},\"AssetRejected(uint256,uint64)\":{\"notice\":\"Used to notify listeners that an asset object at `assetId` is rejected from token and is dropped  from the pending assets array of the token.\"},\"AssetSet(uint64)\":{\"notice\":\"Used to notify listeners that an asset object is initialized at `assetId`.\"},\"ChildAccepted(uint256,uint256,address,uint256)\":{\"notice\":\"Used to notify listeners that a new child token was accepted by the parent token.\"},\"ChildAssetEquipped(uint256,uint64,uint64,uint256,address,uint64)\":{\"notice\":\"Used to notify listeners that a child's asset has been equipped into one of its parent assets.\"},\"ChildAssetUnequipped(uint256,uint64,uint64,uint256,address,uint64)\":{\"notice\":\"Used to notify listeners that a child's asset has been unequipped from one of its parent assets.\"},\"ChildProposed(uint256,uint256,address,uint256)\":{\"notice\":\"Used to notify listeners that a new token has been added to a given token's pending children array.\"},\"ChildTransferred(uint256,uint256,address,uint256,bool,bool)\":{\"notice\":\"Used to notify listeners a child token has been transferred from parent token.\"},\"NestTransfer(address,address,uint256,uint256,uint256)\":{\"notice\":\"Used to notify listeners that the token is being transferred.\"},\"SetEquippableToAll(uint64)\":{\"notice\":\"Event to announce that a given part can be equipped by any address.\"},\"SetEquippables(uint64,address[])\":{\"notice\":\"Event to announce the overriding of equippable addresses of the part.\"},\"Soulbound(uint256,bool)\":{\"notice\":\"Emitted when a token's soulbound state changes.\"},\"ValidParentEquippableGroupIdSet(uint64,uint64,address)\":{\"notice\":\"Used to notify listeners that the assets belonging to a `equippableGroupId` have been marked as  equippable into a given slot and parent\"}},\"kind\":\"user\",\"methods\":{\"RMRK_INTERFACE()\":{\"notice\":\"Interface identifier of the @rmrk-team/evm-contracts package\"},\"VERSION()\":{\"notice\":\"Version of the @rmrk-team/evm-contracts package\"},\"acceptAsset(uint256,uint256,uint64)\":{\"notice\":\"Accepts a asset at from the pending array of given token.\"},\"acceptChild(uint256,uint256,address,uint256)\":{\"notice\":\"Used to accept a pending child token for a given parent token.\"},\"addChild(uint256,uint256,bytes)\":{\"notice\":\"Used to add a child token to a given parent token.\"},\"approve(address,uint256)\":{\"notice\":\"Used to grant a one-time approval to manage one's token.\"},\"approveForAssets(address,uint256)\":{\"notice\":\"Used to grant approvals for specific tokens to a specified address.\"},\"balanceOf(address)\":{\"notice\":\"Used to retrieve the number of tokens in `owner`'s account.\"},\"burn(uint256)\":{\"notice\":\"Used to burn a given token.\"},\"burn(uint256,uint256)\":{\"notice\":\"Used to burn a given token.\"},\"canTokenBeEquippedWithAssetIntoSlot(address,uint256,uint64,uint64)\":{\"notice\":\"Used to verify whether a token can be equipped into a given parent's slot.\"},\"checkIsEquippable(uint64,address)\":{\"notice\":\"Used to check whether the given address is allowed to equip the desired `Part`.\"},\"checkIsEquippableToAll(uint64)\":{\"notice\":\"Used to check if the part is equippable by all addresses.\"},\"childOf(uint256,uint256)\":{\"notice\":\"Used to retrieve a specific active child token for a given parent token.\"},\"childrenOf(uint256)\":{\"notice\":\"Used to retrieve the active child tokens of a given parent token.\"},\"directOwnerOf(uint256)\":{\"notice\":\"Used to retrieve the immediate owner of the given token.\"},\"equip((uint256,uint256,uint64,uint64,uint64))\":{\"notice\":\"Used to equip a child into a token.\"},\"getActiveAssetPriorities(uint256)\":{\"notice\":\"Used to retrieve the priorities of the active resoources of a given token.\"},\"getActiveAssets(uint256)\":{\"notice\":\"Used to retrieve IDs of the active assets of given token.\"},\"getApproved(uint256)\":{\"notice\":\"Used to retrieve the account approved to manage given token.\"},\"getApprovedForAssets(uint256)\":{\"notice\":\"Used to retrieve the address of the account approved to manage assets of a given token.\"},\"getAssetAndEquippableData(uint256,uint64)\":{\"notice\":\"Used to get the asset and equippable data associated with given `assetId`.\"},\"getAssetMetadata(uint256,uint64)\":{\"notice\":\"Used to fetch the asset metadata of the specified token's active asset with the given index.\"},\"getAssetReplacements(uint256,uint64)\":{\"notice\":\"Used to retrieve the asset that will be replaced if a given asset from the token's pending array  is accepted.\"},\"getEquipment(uint256,address,uint64)\":{\"notice\":\"Used to get the Equipment object equipped into the specified slot of the desired token.\"},\"getMetadataURI()\":{\"notice\":\"Used to return the metadata URI of the associated Catalog.\"},\"getPart(uint64)\":{\"notice\":\"Used to retrieve a `Part` with id `partId`\"},\"getParts(uint64[])\":{\"notice\":\"Used to retrieve multiple parts at the same time.\"},\"getPendingAssets(uint256)\":{\"notice\":\"Used to retrieve IDs of the pending assets of given token.\"},\"getType()\":{\"notice\":\"Used to return the `itemType` of the associated Catalog\"},\"isApprovedForAll(address,address)\":{\"notice\":\"Used to check if the given address is allowed to manage the tokens of the specified address.\"},\"isApprovedForAllForAssets(address,address)\":{\"notice\":\"Used to check whether the address has been granted the operator role by a given address or not.\"},\"isChildEquipped(uint256,address,uint256)\":{\"notice\":\"Used to check whether the token has a given child equipped.\"},\"isTransferable(uint256,address,address)\":{\"notice\":\"Used to check whether the given token is transferable or not.\"},\"nestTransferFrom(address,address,uint256,uint256,bytes)\":{\"notice\":\"Used to transfer the token into another token.\"},\"ownerOf(uint256)\":{\"notice\":\"Used to retrieve the *root* owner of a given token.\"},\"pendingChildOf(uint256,uint256)\":{\"notice\":\"Used to retrieve a specific pending child token from a given parent token.\"},\"pendingChildrenOf(uint256)\":{\"notice\":\"Used to retrieve the pending child tokens of a given parent token.\"},\"rejectAllAssets(uint256,uint256)\":{\"notice\":\"Rejects all assets from the pending array of a given token.\"},\"rejectAllChildren(uint256,uint256)\":{\"notice\":\"Used to reject all pending children of a given parent token.\"},\"rejectAsset(uint256,uint256,uint64)\":{\"notice\":\"Rejects a asset from the pending array of given token.\"},\"safeTransferFrom(address,address,uint256)\":{\"notice\":\"Used to safely transfer a given token token from `from` to `to`.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"notice\":\"Used to safely transfer a given token token from `from` to `to`.\"},\"setApprovalForAll(address,bool)\":{\"notice\":\"Used to approve or remove `operator` as an operator for the caller.\"},\"setApprovalForAllForAssets(address,bool)\":{\"notice\":\"Used to add or remove an operator of assets for the caller.\"},\"setPriority(uint256,uint64[])\":{\"notice\":\"Sets a new priority array for a given token.\"},\"transferChild(uint256,address,uint256,uint256,address,uint256,bool,bytes)\":{\"notice\":\"Used to transfer a child token from a given parent token.\"},\"transferFrom(address,address,uint256)\":{\"notice\":\"Transfers a given token from `from` to `to`.\"},\"unequip(uint256,uint64,uint64)\":{\"notice\":\"Used to unequip child from parent token.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Equippable.sol\":\"Equippale\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":400},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x516a22876c1fab47f49b1bc22b4614491cd05338af8bd2e7b382da090a079990\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xd5fa74b4fb323776fa4a8158800fec9d5ac0fec0d6dd046dd93798632ada265f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x51b758a8815ecc9596c66c37d56b1d33883a444631a3f916b9fe65cb863ef7c4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/AbstractMultiAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC5773} from \\\"./IERC5773.sol\\\";\\nimport {RMRKLib} from \\\"./RMRKLib.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"./RMRKErrors.sol\\\";\\n\\n/**\\n * @title AbstractMultiAsset\\n * @author RMRK team\\n * @notice Abstract Smart contract implementing most of the common logic for contracts implementing IERC5773\\n */\\nabstract contract AbstractMultiAsset is Context, IERC5773 {\\n    using RMRKLib for uint64[];\\n\\n    /// Mapping of uint64 Ids to asset metadata\\n    mapping(uint64 => string) internal _assets;\\n\\n    /// Mapping of tokenId to new asset, to asset to be replaced\\n    mapping(uint256 => mapping(uint64 => uint64)) internal _assetReplacements;\\n\\n    /// Mapping of tokenId to an array of active assets\\n    /// @dev Active recurses is unbounded, getting all would reach gas limit at around 30k items\\n    /// so we leave this as internal in case a custom implementation needs to implement pagination\\n    mapping(uint256 => uint64[]) internal _activeAssets;\\n\\n    /// Mapping of tokenId to an array of pending assets\\n    mapping(uint256 => uint64[]) internal _pendingAssets;\\n\\n    /// Mapping of tokenId to an array of priorities for active assets\\n    mapping(uint256 => uint64[]) internal _activeAssetPriorities;\\n\\n    /// Mapping of tokenId to assetId to whether the token has this asset assigned\\n    mapping(uint256 => mapping(uint64 => bool)) internal _tokenAssets;\\n\\n    /// Mapping from owner to operator approvals for assets\\n    mapping(address => mapping(address => bool))\\n        private _operatorApprovalsForAssets;\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function getAssetMetadata(\\n        uint256 tokenId,\\n        uint64 assetId\\n    ) public view virtual returns (string memory metadata) {\\n        if (!_tokenAssets[tokenId][assetId]) revert RMRKTokenDoesNotHaveAsset();\\n        metadata = _assets[assetId];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function getActiveAssets(\\n        uint256 tokenId\\n    ) public view virtual returns (uint64[] memory assetIds) {\\n        assetIds = _activeAssets[tokenId];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function getPendingAssets(\\n        uint256 tokenId\\n    ) public view virtual returns (uint64[] memory assetIds) {\\n        assetIds = _pendingAssets[tokenId];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function getActiveAssetPriorities(\\n        uint256 tokenId\\n    ) public view virtual returns (uint64[] memory priorities) {\\n        priorities = _activeAssetPriorities[tokenId];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function getAssetReplacements(\\n        uint256 tokenId,\\n        uint64 newAssetId\\n    ) public view virtual returns (uint64 replacesAssetId) {\\n        replacesAssetId = _assetReplacements[tokenId][newAssetId];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function isApprovedForAllForAssets(\\n        address owner,\\n        address operator\\n    ) public view virtual returns (bool isApproved) {\\n        isApproved = _operatorApprovalsForAssets[owner][operator];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function setApprovalForAllForAssets(\\n        address operator,\\n        bool approved\\n    ) public virtual {\\n        if (_msgSender() == operator)\\n            revert RMRKApprovalForAssetsToCurrentOwner();\\n\\n        _operatorApprovalsForAssets[_msgSender()][operator] = approved;\\n        emit ApprovalForAllForAssets(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @notice Used to accept a pending asset.\\n     * @dev The call is reverted if there is no pending asset at a given index.\\n     * @dev Emits ***AssetAccepted*** event.\\n     * @param tokenId ID of the token for which to accept the pending asset\\n     * @param index Index of the asset in the pending array to accept\\n     * @param assetId ID of the asset to accept in token's pending array\\n     */\\n    function _acceptAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) internal virtual {\\n        _validatePendingAssetAtIndex(tokenId, index, assetId);\\n        _beforeAcceptAsset(tokenId, index, assetId);\\n\\n        uint64 replacesId = _assetReplacements[tokenId][assetId];\\n        uint256 replaceIndex;\\n        bool replacefound;\\n        if (replacesId != uint64(0))\\n            (replaceIndex, replacefound) = _activeAssets[tokenId].indexOf(\\n                replacesId\\n            );\\n\\n        if (replacefound) {\\n            // We don't want to remove and then push a new asset.\\n            // This way we also keep the priority of the original asset\\n            _activeAssets[tokenId][replaceIndex] = assetId;\\n            delete _tokenAssets[tokenId][replacesId];\\n        } else {\\n            // We use the current size as next priority, by default priorities would be [0,1,2...]\\n            _activeAssetPriorities[tokenId].push(\\n                uint64(_activeAssets[tokenId].length)\\n            );\\n            _activeAssets[tokenId].push(assetId);\\n            replacesId = uint64(0);\\n        }\\n        _removePendingAsset(tokenId, index, assetId);\\n\\n        emit AssetAccepted(tokenId, assetId, replacesId);\\n        _afterAcceptAsset(tokenId, index, assetId);\\n    }\\n\\n    /**\\n     * @notice Used to reject the specified asset from the pending array.\\n     * @dev The call is reverted if there is no pending asset at a given index.\\n     * @dev Emits ***AssetRejected*** event.\\n     * @param tokenId ID of the token that the asset is being rejected from\\n     * @param index Index of the asset in the pending array to be rejected\\n     * @param assetId ID of the asset expected to be in the index\\n     */\\n    function _rejectAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) internal virtual {\\n        _validatePendingAssetAtIndex(tokenId, index, assetId);\\n        _beforeRejectAsset(tokenId, index, assetId);\\n\\n        _removePendingAsset(tokenId, index, assetId);\\n        delete _tokenAssets[tokenId][assetId];\\n\\n        emit AssetRejected(tokenId, assetId);\\n        _afterRejectAsset(tokenId, index, assetId);\\n    }\\n\\n    /**\\n     * @notice Used to validate the index on the pending assets array\\n     * @dev The call is reverted if the index is out of range or the asset Id is not present at the index.\\n     * @param tokenId ID of the token that the asset is validated from\\n     * @param index Index of the asset in the pending array\\n     * @param assetId Id of the asset expected to be in the index\\n     */\\n    function _validatePendingAssetAtIndex(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) private view {\\n        if (index >= _pendingAssets[tokenId].length)\\n            revert RMRKIndexOutOfRange();\\n        if (assetId != _pendingAssets[tokenId][index])\\n            revert RMRKUnexpectedAssetId();\\n    }\\n\\n    /**\\n     * @notice Used to remove the asset at the index on the pending assets array\\n     * @param tokenId ID of the token that the asset is being removed from\\n     * @param index Index of the asset in the pending array\\n     * @param assetId Id of the asset expected to be in the index\\n     */\\n    function _removePendingAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) private {\\n        _pendingAssets[tokenId].removeItemByIndex(index);\\n        delete _assetReplacements[tokenId][assetId];\\n    }\\n\\n    /**\\n     * @notice Used to reject all of the pending assets for the given token.\\n     * @dev When rejecting all assets, the pending array is indiscriminately cleared.\\n     * @dev If the number of pending assets is greater than the value of `maxRejections`, the exectuion will be\\n     *  reverted.\\n     * @dev Emits ***AssetRejected*** event.\\n     * @param tokenId ID of the token to reject all of the pending assets.\\n     * @param maxRejections Maximum number of expected assets to reject, used to prevent from\\n     *  rejecting assets which arrive just before this operation.\\n     */\\n    function _rejectAllAssets(\\n        uint256 tokenId,\\n        uint256 maxRejections\\n    ) internal virtual {\\n        uint256 len = _pendingAssets[tokenId].length;\\n        if (len > maxRejections) revert RMRKUnexpectedNumberOfAssets();\\n\\n        _beforeRejectAllAssets(tokenId);\\n\\n        for (uint256 i; i < len; ) {\\n            uint64 assetId = _pendingAssets[tokenId][i];\\n            delete _assetReplacements[tokenId][assetId];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        delete (_pendingAssets[tokenId]);\\n\\n        emit AssetRejected(tokenId, uint64(0));\\n        _afterRejectAllAssets(tokenId);\\n    }\\n\\n    /**\\n     * @notice Used to specify the priorities for a given token's active assets.\\n     * @dev If the length of the priorities array doesn't match the length of the active assets array, the execution\\n     *  will be reverted.\\n     * @dev The position of the priority value in the array corresponds the position of the asset in the active\\n     *  assets array it will be applied to.\\n     * @dev Emits ***AssetPrioritySet*** event.\\n     * @param tokenId ID of the token for which the priorities are being set\\n     * @param priorities Array of priorities for the assets\\n     */\\n    function _setPriority(\\n        uint256 tokenId,\\n        uint64[] calldata priorities\\n    ) internal virtual {\\n        uint256 length = priorities.length;\\n        if (length != _activeAssets[tokenId].length)\\n            revert RMRKBadPriorityListLength();\\n\\n        _beforeSetPriority(tokenId, priorities);\\n        _activeAssetPriorities[tokenId] = priorities;\\n\\n        emit AssetPrioritySet(tokenId);\\n        _afterSetPriority(tokenId, priorities);\\n    }\\n\\n    /**\\n     * @notice Used to add an asset entry.\\n     * @dev If the specified ID is already used by another asset, the execution will be reverted.\\n     * @dev This internal function warrants custom access control to be implemented when used.\\n     * @dev Emits ***AssetSet*** event.\\n     * @param id ID of the asset to assign to the new asset\\n     * @param metadataURI Metadata URI of the asset\\n     */\\n    function _addAssetEntry(\\n        uint64 id,\\n        string memory metadataURI\\n    ) internal virtual {\\n        if (id == uint64(0)) revert RMRKIdZeroForbidden();\\n        if (bytes(_assets[id]).length > 0) revert RMRKAssetAlreadyExists();\\n\\n        _beforeAddAsset(id, metadataURI);\\n        _assets[id] = metadataURI;\\n\\n        emit AssetSet(id);\\n        _afterAddAsset(id, metadataURI);\\n    }\\n\\n    /**\\n     * @notice Used to add an asset to a token.\\n     * @dev If the given asset is already added to the token, the execution will be reverted.\\n     * @dev If the asset ID is invalid, the execution will be reverted.\\n     * @dev If the token already has the maximum amount of pending assets (128), the execution will be\\n     *  reverted.\\n     * @dev Emits ***AssetAddedToTokens*** event.\\n     * @param tokenId ID of the token to add the asset to\\n     * @param assetId ID of the asset to add to the token\\n     * @param replacesAssetWithId ID of the asset to replace from the token's list of active assets\\n     */\\n    function _addAssetToToken(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 replacesAssetWithId\\n    ) internal virtual {\\n        if (_tokenAssets[tokenId][assetId]) revert RMRKAssetAlreadyExists();\\n\\n        if (bytes(_assets[assetId]).length == uint256(0))\\n            revert RMRKNoAssetMatchingId();\\n\\n        if (_pendingAssets[tokenId].length >= 128)\\n            revert RMRKMaxPendingAssetsReached();\\n\\n        _beforeAddAssetToToken(tokenId, assetId, replacesAssetWithId);\\n        _tokenAssets[tokenId][assetId] = true;\\n        _pendingAssets[tokenId].push(assetId);\\n\\n        if (replacesAssetWithId != uint64(0)) {\\n            _assetReplacements[tokenId][assetId] = replacesAssetWithId;\\n        }\\n\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = tokenId;\\n        emit AssetAddedToTokens(tokenIds, assetId, replacesAssetWithId);\\n        _afterAddAssetToToken(tokenId, assetId, replacesAssetWithId);\\n    }\\n\\n    /**\\n     * @notice Hook that is called before an asset is added.\\n     * @param id ID of the asset\\n     * @param metadataURI Metadata URI of the asset\\n     */\\n    function _beforeAddAsset(\\n        uint64 id,\\n        string memory metadataURI\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after an asset is added.\\n     * @param id ID of the asset\\n     * @param metadataURI Metadata URI of the asset\\n     */\\n    function _afterAddAsset(\\n        uint64 id,\\n        string memory metadataURI\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before adding an asset to a token's pending assets array.\\n     * @dev If the asset doesn't intend to replace another asset, the `replacesAssetWithId` value should be `0`.\\n     * @param tokenId ID of the token to which the asset is being added\\n     * @param assetId ID of the asset that is being added\\n     * @param replacesAssetWithId ID of the asset that this asset is attempting to replace\\n     */\\n    function _beforeAddAssetToToken(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 replacesAssetWithId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after an asset has been added to a token's pending assets array.\\n     * @dev If the asset doesn't intend to replace another asset, the `replacesAssetWithId` value should be `0`.\\n     * @param tokenId ID of the token to which the asset is has been added\\n     * @param assetId ID of the asset that is has been added\\n     * @param replacesAssetWithId ID of the asset that this asset is attempting to replace\\n     */\\n    function _afterAddAssetToToken(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 replacesAssetWithId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before an asset is accepted to a token's active assets array.\\n     * @param tokenId ID of the token for which the asset is being accepted\\n     * @param index Index of the asset in the token's pending assets array\\n     * @param assetId ID of the asset expected to be located at the specified `index`\\n     */\\n    function _beforeAcceptAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after an asset is accepted to a token's active assets array.\\n     * @param tokenId ID of the token for which the asset has been accepted\\n     * @param index Index of the asset in the token's pending assets array\\n     * @param assetId ID of the asset expected to have been located at the specified `index`\\n     */\\n    function _afterAcceptAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before rejecting an asset.\\n     * @param tokenId ID of the token from which the asset is being rejected\\n     * @param index Index of the asset in the token's pending assets array\\n     * @param assetId ID of the asset expected to be located at the specified `index`\\n     */\\n    function _beforeRejectAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after rejecting an asset.\\n     * @param tokenId ID of the token from which the asset has been rejected\\n     * @param index Index of the asset in the token's pending assets array\\n     * @param assetId ID of the asset expected to have been located at the specified `index`\\n     */\\n    function _afterRejectAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before rejecting all assets of a token.\\n     * @param tokenId ID of the token from which all of the assets are being rejected\\n     */\\n    function _beforeRejectAllAssets(uint256 tokenId) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after rejecting all assets of a token.\\n     * @param tokenId ID of the token from which all of the assets have been rejected\\n     */\\n    function _afterRejectAllAssets(uint256 tokenId) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before the priorities for token's assets is set.\\n     * @param tokenId ID of the token for which the asset priorities are being set\\n     * @param priorities[] An array of priorities for token's active resources\\n     */\\n    function _beforeSetPriority(\\n        uint256 tokenId,\\n        uint64[] calldata priorities\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after the priorities for token's assets is set.\\n     * @param tokenId ID of the token for which the asset priorities have been set\\n     * @param priorities[] An array of priorities for token's active resources\\n     */\\n    function _afterSetPriority(\\n        uint256 tokenId,\\n        uint64[] calldata priorities\\n    ) internal virtual {}\\n}\",\"keccak256\":\"0x6c18aff7ff097784f13692a3f7b6bd9f9725dd6280ceedfa8748aa798d995d0a\",\"license\":\"Apache-2.0\"},\"contracts/Equippable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./RMRKEquippable.sol\\\";\\nimport \\\"./RMRKSoulboundPerToken.sol\\\";\\nimport \\\"./RMRKCatalog.sol\\\";\\n\\ncontract Equippale is\\n    RMRKEquippable,\\n    RMRKSoulboundPerToken,\\n    RMRKCatalog(\\\"google.com\\\", \\\"slot\\\")\\n{\\n    uint64 tokenId = 1;\\n    uint64 childId = 1;\\n    uint64 assetId = 1;\\n    uint64 groupId = 1;\\n    uint64 partId = 1;\\n    uint64[] parentTokens;\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 token_id\\n    ) internal virtual override(RMRKNestable, RMRKSoulbound) {\\n        if (!isTransferable(token_id, from, to))\\n            revert RMRKCannotTransferSoulbound();\\n    }\\n\\n    function mint(\\n        string memory metadataURI,\\n        address[] memory equippables\\n    ) public {\\n        uint64[] memory partIds = new uint64[](3);\\n        _mint(msg.sender, tokenId, \\\"0x64\\\");\\n        uint64 length = partId + 3;\\n        uint index = 0;\\n        for (uint64 parts = partId; parts < length; parts++) {\\n            addPart(equippables, metadataURI, parts);\\n            partIds[index] = parts;\\n            index++;\\n            partId++;\\n        }\\n        _addAssetEntry(tokenId, groupId, address(this), metadataURI, partIds);\\n        _addAssetToToken(tokenId, assetId, assetId);\\n        _acceptAsset(tokenId, 0, assetId);\\n        parentTokens.push(tokenId);\\n        tokenId++;\\n        assetId++;\\n    }\\n\\n    function getParentTokens() public view returns (uint64[] memory) {\\n        return parentTokens;\\n    }\\n\\n    function mintChild(uint64 token_id, string memory metadataURI) public {\\n        uint64[] memory part;\\n        _mint(msg.sender, tokenId, \\\"0x64\\\");\\n        _addAssetEntry(tokenId, groupId, address(this), metadataURI, part);\\n        _addAssetToToken(tokenId, assetId, assetId);\\n        _acceptAsset(tokenId, 0, assetId);\\n        addChild(token_id, tokenId);\\n        acceptChild(token_id, 0, address(this), tokenId);\\n        tokenId++;\\n        assetId++;\\n    }\\n\\n    function addChild(uint64 token_id, uint64 child_id) internal {\\n        IERC7401 destContract = IERC7401(address(this));\\n        destContract.addChild(token_id, child_id, \\\"0x64\\\");\\n    }\\n\\n    function addPart(\\n        address[] memory equippables,\\n        string memory metadataURI,\\n        uint64 _partId\\n    ) public {\\n        Part memory partData = Part({\\n            itemType: ItemType.Slot,\\n            z: 2,\\n            equippable: equippables,\\n            metadataURI: metadataURI\\n        });\\n        IntakeStruct memory partIntake = IntakeStruct({\\n            partId: partId,\\n            part: partData\\n        });\\n        _addPart(partIntake);\\n        _setEquippableToAll(_partId);\\n    }\\n\\n    function equipToken(\\n        uint64 equippableGroupId,\\n        address parentAddress,\\n        uint64 slotPartId,\\n        IntakeEquip memory data\\n    ) public {\\n        setValidParentForEquippableGroup(\\n            equippableGroupId,\\n            parentAddress,\\n            slotPartId\\n        );\\n        equip(data);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    )\\n        public\\n        view\\n        virtual\\n        override(RMRKEquippable, RMRKSoulbound, RMRKCatalog)\\n        returns (bool)\\n    {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    function setValidParentForEquippableGroup(\\n        uint64 equippableGroupId,\\n        address parentAddress,\\n        uint64 slotPartId\\n    ) public {\\n        _setValidParentForEquippableGroup(\\n            equippableGroupId,\\n            parentAddress,\\n            slotPartId\\n        );\\n    }\\n\\n    function getTokenId() public view returns (uint64) {\\n        return tokenId;\\n    }\\n}\\n\",\"keccak256\":\"0x94d117f32df6cef185281efa3cbd695424b19a2b4364cab25867d73ab5e0d189\",\"license\":\"MIT\"},\"contracts/IERC5773.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IERC5773\\n * @author RMRK team\\n * @notice Interface smart contract of the RMRK multi asset module.\\n */\\ninterface IERC5773 is IERC165 {\\n    /**\\n     * @notice Used to notify listeners that an asset object is initialized at `assetId`.\\n     * @param assetId ID of the asset that was initialized\\n     */\\n    event AssetSet(uint64 indexed assetId);\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is added to token's pending asset\\n     *  array.\\n     * @param tokenIds An array of token IDs that received a new pending asset\\n     * @param assetId ID of the asset that has been added to the token's pending assets array\\n     * @param replacesId ID of the asset that would be replaced\\n     */\\n    event AssetAddedToTokens(\\n        uint256[] tokenIds,\\n        uint64 indexed assetId,\\n        uint64 indexed replacesId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is accepted by the token and migrated\\n     *  from token's pending assets array to active assets array of the token.\\n     * @param tokenId ID of the token that had a new asset accepted\\n     * @param assetId ID of the asset that was accepted\\n     * @param replacesId ID of the asset that was replaced\\n     */\\n    event AssetAccepted(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed replacesId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that an asset object at `assetId` is rejected from token and is dropped\\n     *  from the pending assets array of the token.\\n     * @param tokenId ID of the token that had an asset rejected\\n     * @param assetId ID of the asset that was rejected\\n     */\\n    event AssetRejected(uint256 indexed tokenId, uint64 indexed assetId);\\n\\n    /**\\n     * @notice Used to notify listeners that token's prioritiy array is reordered.\\n     * @param tokenId ID of the token that had the asset priority array updated\\n     */\\n    event AssetPrioritySet(uint256 indexed tokenId);\\n\\n    /**\\n     * @notice Used to notify listeners that owner has granted an approval to the user to manage the assets of a\\n     *  given token.\\n     * @dev Approvals must be cleared on transfer\\n     * @param owner Address of the account that has granted the approval for all token's assets\\n     * @param approved Address of the account that has been granted approval to manage the token's assets\\n     * @param tokenId ID of the token on which the approval was granted\\n     */\\n    event ApprovalForAssets(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that owner has granted approval to the user to manage assets of all of their\\n     *  tokens.\\n     * @param owner Address of the account that has granted the approval for all assets on all of their tokens\\n     * @param operator Address of the account that has been granted the approval to manage the token's assets on all of\\n     *  the tokens\\n     * @param approved Boolean value signifying whether the permission has been granted (`true`) or revoked (`false`)\\n     */\\n    event ApprovalForAllForAssets(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @notice Accepts an asset at from the pending array of given token.\\n     * @dev Migrates the asset from the token's pending asset array to the token's active asset array.\\n     * @dev Active assets cannot be removed by anyone, but can be replaced by a new asset.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits an {AssetAccepted} event.\\n     * @param tokenId ID of the token for which to accept the pending asset\\n     * @param index Index of the asset in the pending array to accept\\n     * @param assetId ID of the asset expected to be in the index\\n     */\\n    function acceptAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) external;\\n\\n    /**\\n     * @notice Rejects an asset from the pending array of given token.\\n     * @dev Removes the asset from the token's pending asset array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits a {AssetRejected} event.\\n     * @param tokenId ID of the token that the asset is being rejected from\\n     * @param index Index of the asset in the pending array to be rejected\\n     * @param assetId ID of the asset expected to be in the index\\n     */\\n    function rejectAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) external;\\n\\n    /**\\n     * @notice Rejects all assets from the pending array of a given token.\\n     * @dev Effecitvely deletes the pending array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     * @dev Emits a {AssetRejected} event with assetId = 0.\\n     * @param tokenId ID of the token of which to clear the pending array.\\n     * @param maxRejections Maximum number of expected assets to reject, used to prevent from rejecting assets which\\n     *  arrive just before this operation.\\n     */\\n    function rejectAllAssets(uint256 tokenId, uint256 maxRejections) external;\\n\\n    /**\\n     * @notice Sets a new priority array for a given token.\\n     * @dev The priority array is a non-sequential list of `uint64`s, where the lowest value is considered highest\\n     *  priority.\\n     * @dev Value `0` of a priority is a special case equivalent to unitialized.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - The length of `priorities` must be equal the length of the active assets array.\\n     * @dev Emits a {AssetPrioritySet} event.\\n     * @param tokenId ID of the token to set the priorities for\\n     * @param priorities An array of priorities of active assets. The succesion of items in the priorities array\\n     *  matches that of the succesion of items in the active array\\n     */\\n    function setPriority(\\n        uint256 tokenId,\\n        uint64[] calldata priorities\\n    ) external;\\n\\n    /**\\n     * @notice Used to retrieve IDs of the active assets of given token.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @dev You can safely get 10k\\n     * @param tokenId ID of the token to retrieve the IDs of the active assets\\n     * @return assetIds An array of active asset IDs of the given token\\n     */\\n    function getActiveAssets(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory assetIds);\\n\\n    /**\\n     * @notice Used to retrieve IDs of the pending assets of given token.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @param tokenId ID of the token to retrieve the IDs of the pending assets\\n     * @return assetIds An array of pending asset IDs of the given token\\n     */\\n    function getPendingAssets(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory assetIds);\\n\\n    /**\\n     * @notice Used to retrieve the priorities of the active resoources of a given token.\\n     * @dev Asset priorities are a non-sequential array of uint64 values with an array size equal to active asset\\n     *  priorites.\\n     * @param tokenId ID of the token for which to retrieve the priorities of the active assets\\n     * @return priorities An array of priorities of the active assets of the given token\\n     */\\n    function getActiveAssetPriorities(\\n        uint256 tokenId\\n    ) external view returns (uint64[] memory priorities);\\n\\n    /**\\n     * @notice Used to retrieve the asset that will be replaced if a given asset from the token's pending array\\n     *  is accepted.\\n     * @dev Asset data is stored by reference, in order to access the data corresponding to the ID, call\\n     *  `getAssetMetadata(tokenId, assetId)`.\\n     * @param tokenId ID of the token to check\\n     * @param newAssetId ID of the pending asset which will be accepted\\n     * @return replacesAssetWithId ID of the asset which will be replaced\\n     */\\n    function getAssetReplacements(\\n        uint256 tokenId,\\n        uint64 newAssetId\\n    ) external view returns (uint64 replacesAssetWithId);\\n\\n    /**\\n     * @notice Used to fetch the asset metadata of the specified token's active asset with the given index.\\n     * @dev Assets are stored by reference mapping `_assets[assetId]`.\\n     * @dev Can be overriden to implement enumerate, fallback or other custom logic.\\n     * @param tokenId ID of the token from which to retrieve the asset metadata\\n     * @param assetId Asset Id, must be in the active assets array\\n     * @return metadata The metadata of the asset belonging to the specified index in the token's active assets\\n     *  array\\n     */\\n    function getAssetMetadata(\\n        uint256 tokenId,\\n        uint64 assetId\\n    ) external view returns (string memory metadata);\\n\\n    // Approvals\\n\\n    /**\\n     * @notice Used to grant permission to the user to manage token's assets.\\n     * @dev This differs from transfer approvals, as approvals are not cleared when the approved party accepts or\\n     *  rejects an asset, or sets asset priorities. This approval is cleared on token transfer.\\n     * @dev Only a single account can be approved at a time, so approving the `0x0` address clears previous approvals.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be an approved operator.\\n     *  - `tokenId` must exist.\\n     * @dev Emits an {ApprovalForAssets} event.\\n     * @param to Address of the account to grant the approval to\\n     * @param tokenId ID of the token for which the approval to manage the assets is granted\\n     */\\n    function approveForAssets(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @notice Used to retrieve the address of the account approved to manage assets of a given token.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @param tokenId ID of the token for which to retrieve the approved address\\n     * @return approved Address of the account that is approved to manage the specified token's assets\\n     */\\n    function getApprovedForAssets(\\n        uint256 tokenId\\n    ) external view returns (address approved);\\n\\n    /**\\n     * @notice Used to add or remove an operator of assets for the caller.\\n     * @dev Operators can call {acceptAsset}, {rejectAsset}, {rejectAllAssets} or {setPriority} for any token\\n     *  owned by the caller.\\n     * @dev Requirements:\\n     *\\n     *  - The `operator` cannot be the caller.\\n     * @dev Emits an {ApprovalForAllForAssets} event.\\n     * @param operator Address of the account to which the operator role is granted or revoked from\\n     * @param approved The boolean value indicating whether the operator role is being granted (`true`) or revoked\\n     *  (`false`)\\n     */\\n    function setApprovalForAllForAssets(\\n        address operator,\\n        bool approved\\n    ) external;\\n\\n    /**\\n     * @notice Used to check whether the address has been granted the operator role by a given address or not.\\n     * @dev See {setApprovalForAllForAssets}.\\n     * @param owner Address of the account that we are checking for whether it has granted the operator role\\n     * @param operator Address of the account that we are checking whether it has the operator role or not\\n     * @return isApproved A boolean value indicating whether the account we are checking has been granted the operator role\\n     */\\n    function isApprovedForAllForAssets(\\n        address owner,\\n        address operator\\n    ) external view returns (bool isApproved);\\n}\",\"keccak256\":\"0x3bdf56b2724091dc847b8dcc6059afbf4742fce8d000ffaf49c368adb21dfe96\",\"license\":\"Apache-2.0\"},\"contracts/IERC6220.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC5773} from \\\"./IERC5773.sol\\\";\\n\\n/**\\n * @title IERC6220\\n * @author RMRK team\\n * @notice Interface smart contract of the RMRK equippable module.\\n */\\ninterface IERC6220 is IERC5773 {\\n    /**\\n     * @notice Used to store the core structure of the `Equippable` RMRK lego.\\n     * @return assetId The ID of the asset equipping a child\\n     * @return childAssetId The ID of the asset used as equipment\\n     * @return childId The ID of token that is equipped\\n     * @return childEquippableAddress Address of the collection to which the child asset belongs to\\n     */\\n    struct Equipment {\\n        uint64 assetId;\\n        uint64 childAssetId;\\n        uint256 childId;\\n        address childEquippableAddress;\\n    }\\n\\n    /**\\n     * @notice Used to provide a struct for inputing equip data.\\n     * @dev Only used for input and not storage of data.\\n     * @return tokenId ID of the token we are managing\\n     * @return childIndex Index of a child in the list of token's active children\\n     * @return assetId ID of the asset that we are equipping into\\n     * @return slotPartId ID of the slot part that we are using to equip\\n     * @return childAssetId ID of the asset that we are equipping\\n     */\\n    struct IntakeEquip {\\n        uint256 tokenId;\\n        uint256 childIndex;\\n        uint64 assetId;\\n        uint64 slotPartId;\\n        uint64 childAssetId;\\n    }\\n\\n    /**\\n     * @notice Used to notify listeners that a child's asset has been equipped into one of its parent assets.\\n     * @param tokenId ID of the token that had an asset equipped\\n     * @param assetId ID of the asset associated with the token we are equipping into\\n     * @param slotPartId ID of the slot we are using to equip\\n     * @param childId ID of the child token we are equipping into the slot\\n     * @param childAddress Address of the child token's collection\\n     * @param childAssetId ID of the asset associated with the token we are equipping\\n     */\\n    event ChildAssetEquipped(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed slotPartId,\\n        uint256 childId,\\n        address childAddress,\\n        uint64 childAssetId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that a child's asset has been unequipped from one of its parent assets.\\n     * @param tokenId ID of the token that had an asset unequipped\\n     * @param assetId ID of the asset associated with the token we are unequipping out of\\n     * @param slotPartId ID of the slot we are unequipping from\\n     * @param childId ID of the token being unequipped\\n     * @param childAddress Address of the collection that a token that is being unequipped belongs to\\n     * @param childAssetId ID of the asset associated with the token we are unequipping\\n     */\\n    event ChildAssetUnequipped(\\n        uint256 indexed tokenId,\\n        uint64 indexed assetId,\\n        uint64 indexed slotPartId,\\n        uint256 childId,\\n        address childAddress,\\n        uint64 childAssetId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that the assets belonging to a `equippableGroupId` have been marked as\\n     *  equippable into a given slot and parent\\n     * @param equippableGroupId ID of the equippable group being marked as equippable into the slot associated with\\n     *  `slotPartId` of the `parentAddress` collection\\n     * @param slotPartId ID of the slot part of the catalog into which the parts belonging to the equippable group\\n     *  associated with `equippableGroupId` can be equipped\\n     * @param parentAddress Address of the collection into which the parts belonging to `equippableGroupId` can be\\n     *  equipped\\n     */\\n    event ValidParentEquippableGroupIdSet(\\n        uint64 indexed equippableGroupId,\\n        uint64 indexed slotPartId,\\n        address parentAddress\\n    );\\n\\n    /**\\n     * @notice Used to equip a child into a token.\\n     * @dev The `IntakeEquip` stuct contains the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @param data An `IntakeEquip` struct specifying the equip data\\n     */\\n    function equip(IntakeEquip memory data) external;\\n\\n    /**\\n     * @notice Used to unequip child from parent token.\\n     * @dev This can only be called by the owner of the token or by an account that has been granted permission to\\n     *  manage the given token by the current owner.\\n     * @param tokenId ID of the parent from which the child is being unequipped\\n     * @param assetId ID of the parent's asset that contains the `Slot` into which the child is equipped\\n     * @param slotPartId ID of the `Slot` from which to unequip the child\\n     */\\n    function unequip(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) external;\\n\\n    /**\\n     * @notice Used to check whether the token has a given child equipped.\\n     * @dev This is used to prevent from transferring a child that is equipped.\\n     * @param tokenId ID of the parent token for which we are querying for\\n     * @param childAddress Address of the child token's smart contract\\n     * @param childId ID of the child token\\n     * @return isEquipped A boolean value indicating whether the child token is equipped into the given token or not\\n     */\\n    function isChildEquipped(\\n        uint256 tokenId,\\n        address childAddress,\\n        uint256 childId\\n    ) external view returns (bool isEquipped);\\n\\n    /**\\n     * @notice Used to verify whether a token can be equipped into a given parent's slot.\\n     * @param parent Address of the parent token's smart contract\\n     * @param tokenId ID of the token we want to equip\\n     * @param assetId ID of the asset associated with the token we want to equip\\n     * @param slotId ID of the slot that we want to equip the token into\\n     * @return canBeEquipped A boolean indicating whether the token with the given asset can be equipped into the desired slot\\n     */\\n    function canTokenBeEquippedWithAssetIntoSlot(\\n        address parent,\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotId\\n    ) external view returns (bool canBeEquipped);\\n\\n    /**\\n     * @notice Used to get the Equipment object equipped into the specified slot of the desired token.\\n     * @dev The `Equipment` struct consists of the following data:\\n     *  [\\n     *      assetId,\\n     *      childAssetId,\\n     *      childId,\\n     *      childEquippableAddress\\n     *  ]\\n     * @param tokenId ID of the token for which we are retrieving the equipped object\\n     * @param targetCatalogAddress Address of the `Catalog` associated with the `Slot` part of the token\\n     * @param slotPartId ID of the `Slot` part that we are checking for equipped objects\\n     * @return equipment The `Equipment` struct containing data about the equipped object\\n     */\\n    function getEquipment(\\n        uint256 tokenId,\\n        address targetCatalogAddress,\\n        uint64 slotPartId\\n    ) external view returns (Equipment memory equipment);\\n\\n    /**\\n     * @notice Used to get the asset and equippable data associated with given `assetId`.\\n     * @param tokenId ID of the token for which to retrieve the asset\\n     * @param assetId ID of the asset of which we are retrieving\\n     * @return metadataURI The metadata URI of the asset\\n     * @return equippableGroupId ID of the equippable group this asset belongs to\\n     * @return catalogAddress The address of the catalog the part belongs to\\n     * @return partIds An array of IDs of parts included in the asset\\n     */\\n    function getAssetAndEquippableData(\\n        uint256 tokenId,\\n        uint64 assetId\\n    )\\n        external\\n        view\\n        returns (\\n            string memory metadataURI,\\n            uint64 equippableGroupId,\\n            address catalogAddress,\\n            uint64[] memory partIds\\n        );\\n}\\n\",\"keccak256\":\"0x873846d5c79014c452e121a49613c6e13fa21e897ab02e7cc5d12a571b1cc2b9\",\"license\":\"Apache-2.0\"},\"contracts/IERC6454.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IERC6454\\n * @author RMRK team\\n * @notice A minimal extension to identify the transferability of Non-Fungible Tokens.\\n */\\ninterface IERC6454 is IERC165 {\\n    /**\\n     * @notice Used to check whether the given token is transferable or not.\\n     * @dev If this function returns `false`, the transfer of the token MUST revert execution.\\n     * @dev If the tokenId does not exist, this method MUST revert execution, unless the token is being checked for\\n     *  minting.\\n     * @param tokenId ID of the token being checked\\n     * @param from Address from which the token is being transferred\\n     * @param to Address to which the token is being transferred\\n     * @return isTransferable_ Boolean value indicating whether the given token is transferable\\n     */\\n    function isTransferable(\\n        uint256 tokenId,\\n        address from,\\n        address to\\n    ) external view returns (bool isTransferable_);\\n}\",\"keccak256\":\"0x1484cf73a9d4e8c7648f4f9687cedb6f2cbf47807683ac7452f32071b711b998\",\"license\":\"Apache-2.0\"},\"contracts/IERC7401.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IERC7401\\n * @author RMRK team\\n * @notice Interface smart contract of the RMRK nestable module.\\n */\\ninterface IERC7401 is IERC165 {\\n    /**\\n     * @notice The core struct of RMRK ownership.\\n     * @dev The `DirectOwner` struct is used to store information of the next immediate owner, be it the parent token or\\n     *  the externally owned account.\\n     * @dev If the token is owned by the externally owned account, the `tokenId` should equal `0`.\\n     * @param tokenId ID of the parent token\\n     * @param ownerAddress Address of the owner of the token. If the owner is another token, then the address should be\\n     *  the one of the parent token's collection smart contract. If the owner is externally owned account, the address\\n     *  should be the address of this account\\n     * @param isNft A boolean value signifying whether the token is owned by another token (`true`) or by an externally\\n     *  owned account (`false`)\\n     */\\n    struct DirectOwner {\\n        uint256 tokenId;\\n        address ownerAddress;\\n    }\\n\\n    /**\\n     * @notice Used to notify listeners that the token is being transferred.\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     * @param from Address of the previous immediate owner, which is a smart contract if the token was nested.\\n     * @param to Address of the new immediate owner, which is a smart contract if the token is being nested.\\n     * @param fromTokenId ID of the previous parent token. If the token was not nested before, the value should be `0`\\n     * @param toTokenId ID of the new parent token. If the token is not being nested, the value should be `0`\\n     * @param tokenId ID of the token being transferred\\n     */\\n    event NestTransfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 fromTokenId,\\n        uint256 toTokenId,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that a new token has been added to a given token's pending children array.\\n     * @dev Emitted when a child NFT is added to a token's pending array.\\n     * @param tokenId ID of the token that received a new pending child token\\n     * @param childIndex Index of the proposed child token in the parent token's pending children array\\n     * @param childAddress Address of the proposed child token's collection smart contract\\n     * @param childId ID of the child token in the child token's collection smart contract\\n     */\\n    event ChildProposed(\\n        uint256 indexed tokenId,\\n        uint256 childIndex,\\n        address indexed childAddress,\\n        uint256 indexed childId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that a new child token was accepted by the parent token.\\n     * @dev Emitted when a parent token accepts a token from its pending array, migrating it to the active array.\\n     * @param tokenId ID of the token that accepted a new child token\\n     * @param childIndex Index of the newly accepted child token in the parent token's active children array\\n     * @param childAddress Address of the child token's collection smart contract\\n     * @param childId ID of the child token in the child token's collection smart contract\\n     */\\n    event ChildAccepted(\\n        uint256 indexed tokenId,\\n        uint256 childIndex,\\n        address indexed childAddress,\\n        uint256 indexed childId\\n    );\\n\\n    /**\\n     * @notice Used to notify listeners that all pending child tokens of a given token have been rejected.\\n     * @dev Emitted when a token removes all a child tokens from its pending array.\\n     * @param tokenId ID of the token that rejected all of the pending children\\n     */\\n    event AllChildrenRejected(uint256 indexed tokenId);\\n\\n    /**\\n     * @notice Used to notify listeners a child token has been transferred from parent token.\\n     * @dev Emitted when a token transfers a child from itself, transferring ownership to the root owner.\\n     * @param tokenId ID of the token that transferred a child token\\n     * @param childIndex Index of a child in the array from which it is being transferred\\n     * @param childAddress Address of the child token's collection smart contract\\n     * @param childId ID of the child token in the child token's collection smart contract\\n     * @param fromPending A boolean value signifying whether the token was in the pending child tokens array (`true`) or\\n     *  in the active child tokens array (`false`)\\n     * @param toZero A boolean value signifying whether the token is being transferred to the `0x0` address (`true`) or\\n     *  not (`false`)\\n     */\\n    event ChildTransferred(\\n        uint256 indexed tokenId,\\n        uint256 childIndex,\\n        address indexed childAddress,\\n        uint256 indexed childId,\\n        bool fromPending,\\n        bool toZero\\n    );\\n\\n    /**\\n     * @notice The core child token struct, holding the information about the child tokens.\\n     * @return tokenId ID of the child token in the child token's collection smart contract\\n     * @return contractAddress Address of the child token's smart contract\\n     */\\n    struct Child {\\n        uint256 tokenId;\\n        address contractAddress;\\n    }\\n\\n    /**\\n     * @notice Used to retrieve the *root* owner of a given token.\\n     * @dev The *root* owner of the token is an externally owned account (EOA). If the given token is child of another\\n     *  NFT, this will return an EOA address. Otherwise, if the token is owned by an EOA, this EOA will be returned.\\n     * @param tokenId ID of the token for which the *root* owner has been retrieved\\n     * @return owner_ The *root* owner of the token\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner_);\\n\\n    /**\\n     * @notice Used to retrieve the immediate owner of the given token.\\n     * @dev If the immediate owner is another token, the address returned, should be the one of the parent token's\\n     *  collection smart contract.\\n     * @param tokenId ID of the token for which the RMRK owner is being retrieved\\n     * @return owner Address of the given token's owner\\n     * @return parentId The ID of the parent token. Should be `0` if the owner is an externally owned account\\n     * @return isNFT The boolean value signifying whether the owner is an NFT or not\\n     */\\n    function directOwnerOf(\\n        uint256 tokenId\\n    ) external view returns (address owner, uint256 parentId, bool isNFT);\\n\\n    /**\\n     * @notice Used to burn a given token.\\n     * @dev When a token is burned, all of its child tokens are recursively burned as well.\\n     * @dev When specifying the maximum recursive burns, the execution will be reverted if there are more children to be\\n     *  burned.\\n     * @dev Setting the `maxRecursiveBurn` value to 0 will only attempt to burn the specified token and revert if there\\n     *  are any child tokens present.\\n     * @dev The approvals are cleared when the token is burned.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @dev Emits a {Transfer} event.\\n     * @param tokenId ID of the token to burn\\n     * @param maxRecursiveBurns Maximum number of tokens to recursively burn\\n     * @return burnedChildren Number of recursively burned children\\n     */\\n    function burn(\\n        uint256 tokenId,\\n        uint256 maxRecursiveBurns\\n    ) external returns (uint256 burnedChildren);\\n\\n    /**\\n     * @notice Used to add a child token to a given parent token.\\n     * @dev This adds the child token into the given parent token's pending child tokens array.\\n     * @dev Requirements:\\n     *\\n     *  - `directOwnerOf` on the child contract must resolve to the called contract.\\n     *  - the pending array of the parent contract must not be full.\\n     * @param parentId ID of the parent token to receive the new child token\\n     * @param childId ID of the new proposed child token\\n     * @param data Additional data with no specified format\\n     */\\n    function addChild(\\n        uint256 parentId,\\n        uint256 childId,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @notice Used to accept a pending child token for a given parent token.\\n     * @dev This moves the child token from parent token's pending child tokens array into the active child tokens\\n     *  array.\\n     * @param parentId ID of the parent token for which the child token is being accepted\\n     * @param childIndex Index of a child tokem in the given parent's pending children array\\n     * @param childAddress Address of the collection smart contract of the child token expected to be located at the\\n     *  specified index of the given parent token's pending children array\\n     * @param childId ID of the child token expected to be located at the specified index of the given parent token's\\n     *  pending children array\\n     */\\n    function acceptChild(\\n        uint256 parentId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId\\n    ) external;\\n\\n    /**\\n     * @notice Used to reject all pending children of a given parent token.\\n     * @dev Removes the children from the pending array mapping.\\n     * @dev This does not update the ownership storage data on children. If necessary, ownership can be reclaimed by the\\n     *  rootOwner of the previous parent.\\n     * @dev Requirements:\\n     *\\n     * Requirements:\\n     *\\n     * - `parentId` must exist\\n     * @param parentId ID of the parent token for which to reject all of the pending tokens.\\n     * @param maxRejections Maximum number of expected children to reject, used to prevent from rejecting children which\\n     *  arrive just before this operation.\\n     */\\n    function rejectAllChildren(\\n        uint256 parentId,\\n        uint256 maxRejections\\n    ) external;\\n\\n    /**\\n     * @notice Used to transfer a child token from a given parent token.\\n     * @dev When transferring a child token, the owner of the token is set to `to`, or is not updated in the event of\\n     *  `to` being the `0x0` address.\\n     * @param tokenId ID of the parent token from which the child token is being transferred\\n     * @param to Address to which to transfer the token to\\n     * @param destinationId ID of the token to receive this child token (MUST be 0 if the destination is not a token)\\n     * @param childIndex Index of a token we are transferring, in the array it belongs to (can be either active array or\\n     *  pending array)\\n     * @param childAddress Address of the child token's collection smart contract.\\n     * @param childId ID of the child token in its own collection smart contract.\\n     * @param isPending A boolean value indicating whether the child token being transferred is in the pending array of\\n     *  the parent token (`true`) or in the active array (`false`)\\n     * @param data Additional data with no specified format, sent in call to `_to`\\n     */\\n    function transferChild(\\n        uint256 tokenId,\\n        address to,\\n        uint256 destinationId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId,\\n        bool isPending,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @notice Used to retrieve the active child tokens of a given parent token.\\n     * @dev Returns array of Child structs existing for parent token.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @param parentId ID of the parent token for which to retrieve the active child tokens\\n     * @return children An array of Child structs containing the parent token's active child tokens\\n     */\\n    function childrenOf(\\n        uint256 parentId\\n    ) external view returns (Child[] memory children);\\n\\n    /**\\n     * @notice Used to retrieve the pending child tokens of a given parent token.\\n     * @dev Returns array of pending Child structs existing for given parent.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @param parentId ID of the parent token for which to retrieve the pending child tokens\\n     * @return children An array of Child structs containing the parent token's pending child tokens\\n     */\\n    function pendingChildrenOf(\\n        uint256 parentId\\n    ) external view returns (Child[] memory children);\\n\\n    /**\\n     * @notice Used to retrieve a specific active child token for a given parent token.\\n     * @dev Returns a single Child struct locating at `index` of parent token's active child tokens array.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @param parentId ID of the parent token for which the child is being retrieved\\n     * @param index Index of the child token in the parent token's active child tokens array\\n     * @return child A Child struct containing data about the specified child\\n     */\\n    function childOf(\\n        uint256 parentId,\\n        uint256 index\\n    ) external view returns (Child memory child);\\n\\n    /**\\n     * @notice Used to retrieve a specific pending child token from a given parent token.\\n     * @dev Returns a single Child struct locating at `index` of parent token's active child tokens array.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @param parentId ID of the parent token for which the pending child token is being retrieved\\n     * @param index Index of the child token in the parent token's pending child tokens array\\n     * @return child A Child struct containting data about the specified child\\n     */\\n    function pendingChildOf(\\n        uint256 parentId,\\n        uint256 index\\n    ) external view returns (Child memory child);\\n\\n    /**\\n     * @notice Used to transfer the token into another token.\\n     * @param from Address of the direct owner of the token to be transferred\\n     * @param to Address of the receiving token's collection smart contract\\n     * @param tokenId ID of the token being transferred\\n     * @param destinationId ID of the token to receive the token being transferred\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function nestTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 destinationId,\\n        bytes memory data\\n    ) external;\\n}\",\"keccak256\":\"0xd1b301afc5f5acfb6f1193f376b2d29fdf5f078b01b4fcbb511b29f01e56b467\",\"license\":\"Apache-2.0\"},\"contracts/IRMRKCatalog.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title IRMRKCatalog\\n * @author RMRK team\\n * @notice An interface Catalog for RMRK equippable module.\\n */\\ninterface IRMRKCatalog is IERC165 {\\n    /**\\n     * @notice Event to announce addition of a new part.\\n     * @dev It is emitted when a new part is added.\\n     * @param partId ID of the part that was added\\n     * @param itemType Enum value specifying whether the part is `None`, `Slot` and `Fixed`\\n     * @param zIndex An uint specifying the z value of the part. It is used to specify the depth which the part should\\n     *  be rendered at\\n     * @param equippableAddresses An array of addresses that can equip this part\\n     * @param metadataURI The metadata URI of the part\\n     */\\n    event AddedPart(\\n        uint64 indexed partId,\\n        ItemType indexed itemType,\\n        uint8 zIndex,\\n        address[] equippableAddresses,\\n        string metadataURI\\n    );\\n\\n    /**\\n     * @notice Event to announce new equippables to the part.\\n     * @dev It is emitted when new addresses are marked as equippable for `partId`.\\n     * @param partId ID of the part that had new equippable addresses added\\n     * @param equippableAddresses An array of the new addresses that can equip this part\\n     */\\n    event AddedEquippables(\\n        uint64 indexed partId,\\n        address[] equippableAddresses\\n    );\\n\\n    /**\\n     * @notice Event to announce the overriding of equippable addresses of the part.\\n     * @dev It is emitted when the existing list of addresses marked as equippable for `partId` is overwritten by a new one.\\n     * @param partId ID of the part whose list of equippable addresses was overwritten\\n     * @param equippableAddresses The new, full, list of addresses that can equip this part\\n     */\\n    event SetEquippables(uint64 indexed partId, address[] equippableAddresses);\\n\\n    /**\\n     * @notice Event to announce that a given part can be equipped by any address.\\n     * @dev It is emitted when a given part is marked as equippable by any.\\n     * @param partId ID of the part marked as equippable by any address\\n     */\\n    event SetEquippableToAll(uint64 indexed partId);\\n\\n    /**\\n     * @notice Used to define a type of the item. Possible values are `None`, `Slot` or `Fixed`.\\n     * @dev Used for fixed and slot parts.\\n     */\\n    enum ItemType {\\n        None,\\n        Slot,\\n        Fixed\\n    }\\n\\n    /**\\n     * @notice The integral structure of a standard RMRK catalog item defining it.\\n     * @dev Requires a minimum of 3 storage slots per catalog item, equivalent to roughly 60,000 gas as of Berlin hard\\n     *  fork (April 14, 2021), though 5-7 storage slots is more realistic, given the standard length of an IPFS URI.\\n     *  This will result in between 25,000,000 and 35,000,000 gas per 250 assets--the maximum block size of Ethereum\\n     *  mainnet is 30M at peak usage.\\n     * @return itemType The item type of the part\\n     * @return z The z value of the part defining how it should be rendered when presenting the full NFT\\n     * @return equippable The array of addresses allowed to be equipped in this part\\n     * @return metadataURI The metadata URI of the part\\n     */\\n    struct Part {\\n        ItemType itemType; //1 byte\\n        uint8 z; //1 byte\\n        address[] equippable; //n Collections that can be equipped into this slot\\n        string metadataURI; //n bytes 32+\\n    }\\n\\n    /**\\n     * @notice The structure used to add a new `Part`.\\n     * @dev The part is added with specified ID, so you have to make sure that you are using an unused `partId`,\\n     *  otherwise the addition of the part vill be reverted.\\n     * @dev The full `IntakeStruct` looks like this:\\n     *  [\\n     *          partID,\\n     *      [\\n     *          itemType,\\n     *          z,\\n     *          [\\n     *               permittedCollectionAddress0,\\n     *               permittedCollectionAddress1,\\n     *               permittedCollectionAddress2\\n     *           ],\\n     *           metadataURI\\n     *       ]\\n     *   ]\\n     * @return partId ID to be assigned to the `Part`\\n     * @return part A `Part` to be added\\n     */\\n    struct IntakeStruct {\\n        uint64 partId;\\n        Part part;\\n    }\\n\\n    /**\\n     * @notice Used to return the metadata URI of the associated Catalog.\\n     * @return Catalog metadata URI\\n     */\\n    function getMetadataURI() external view returns (string memory);\\n\\n    /**\\n     * @notice Used to return the `itemType` of the associated Catalog\\n     * @return `itemType` of the associated Catalog\\n     */\\n    function getType() external view returns (string memory);\\n\\n    /**\\n     * @notice Used to check whether the given address is allowed to equip the desired `Part`.\\n     * @dev Returns true if a collection may equip asset with `partId`.\\n     * @param partId The ID of the part that we are checking\\n     * @param targetAddress The address that we are checking for whether the part can be equipped into it or not\\n     * @return isEquippable The status indicating whether the `targetAddress` can be equipped into `Part` with `partId` or not\\n     */\\n    function checkIsEquippable(\\n        uint64 partId,\\n        address targetAddress\\n    ) external view returns (bool isEquippable);\\n\\n    /**\\n     * @notice Used to check if the part is equippable by all addresses.\\n     * @dev Returns true if part is equippable to all.\\n     * @param partId ID of the part that we are checking\\n     * @return isEquippableToAll The status indicating whether the part with `partId` can be equipped by any address or not\\n     */\\n    function checkIsEquippableToAll(\\n        uint64 partId\\n    ) external view returns (bool isEquippableToAll);\\n\\n    /**\\n     * @notice Used to retrieve a `Part` with id `partId`\\n     * @param partId ID of the part that we are retrieving\\n     * @return part The `Part` struct associated with given `partId`\\n     */\\n    function getPart(uint64 partId) external view returns (Part memory part);\\n\\n    /**\\n     * @notice Used to retrieve multiple parts at the same time.\\n     * @param partIds An array of part IDs that we want to retrieve\\n     * @return part An array of `Part` structs associated with given `partIds`\\n     */\\n    function getParts(\\n        uint64[] memory partIds\\n    ) external view returns (Part[] memory part);\\n}\",\"keccak256\":\"0x35f97a75d2297949e4f97f1269ba9065f124559015b74251ac8112ad2de7a6cc\",\"license\":\"Apache-2.0\"},\"contracts/RMRKCatalog.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport {IRMRKCatalog, IERC165} from \\\"./IRMRKCatalog.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./RMRKErrors.sol\\\";\\n\\n/**\\n * @title RMRKCatalog\\n * @author RMRK team\\n * @notice Catalog contract for RMRK equippable module.\\n */\\ncontract RMRKCatalog is IRMRKCatalog {\\n    using Address for address;\\n\\n    /**\\n     * @notice Mapping of uint64 `partId` to IRMRKCatalog `Part` struct\\n     */\\n    mapping(uint64 => Part) private _parts;\\n\\n    /**\\n     * @notice Mapping of uint64 `partId` to boolean flag, indicating that a given `Part` can be equippable by any\\n     *  address\\n     */\\n    mapping(uint64 => bool) private _isEquippableToAll;\\n\\n    uint64[] private _partIds;\\n\\n    string private _metadataURI;\\n    string private _type;\\n\\n    /**\\n     * @notice Used to initialize the Catalog.\\n     * @param metadataURI Base metadata URI of the Catalog\\n     * @param type_ Type of Catalog\\n     */\\n    constructor(string memory metadataURI, string memory type_) {\\n        _setMetadataURI(metadataURI);\\n        _setType(type_);\\n    }\\n\\n    /**\\n     * @notice Used to limit execution of functions intended for the `Slot` parts to only execute when used with such\\n     *  parts.\\n     * @dev Reverts execution of a function if the part with associated `partId` is uninitailized or is `Fixed`.\\n     * @param partId ID of the part that we want the function to interact with\\n     */\\n    modifier onlySlot(uint64 partId) {\\n        _onlySlot(partId);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Used to verify that an operation is only executed on slot Parts.\\n     * @dev If the Part is not Slot type, the execution will be reverted.\\n     * @param partId ID of the part to check\\n     */\\n    function _onlySlot(uint64 partId) private view {\\n        ItemType itemType = _parts[partId].itemType;\\n        if (itemType == ItemType.None) revert RMRKPartDoesNotExist();\\n        if (itemType == ItemType.Fixed) revert RMRKPartIsNotSlot();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual returns (bool) {\\n        return\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IRMRKCatalog).interfaceId;\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getMetadataURI() external view returns (string memory) {\\n        return _metadataURI;\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getType() external view returns (string memory) {\\n        return _type;\\n    }\\n\\n    /**\\n     * @notice Internal helper function that sets the base metadata URI of the contract.\\n     * @param metadataURI Base metadata URI of the contract\\n     */\\n    function _setMetadataURI(string memory metadataURI) internal {\\n        _metadataURI = metadataURI;\\n    }\\n\\n    /**\\n     * @notice Internal helper function that sets the type of the contract.\\n     * @param type_ Type of the contract\\n     */\\n    function _setType(string memory type_) internal {\\n        _type = type_;\\n    }\\n\\n    /**\\n     * @notice Internal helper function that adds `Part` entries to storage.\\n     * @dev Delegates to { _addPart } below.\\n     * @param partIntake An array of `IntakeStruct` structs, consisting of `partId` and a nested `Part` struct\\n     */\\n    function _addPartList(IntakeStruct[] memory partIntake) internal {\\n        uint256 len = partIntake.length;\\n        for (uint256 i; i < len; ) {\\n            _addPart(partIntake[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function that adds a single `Part` to storage.\\n     * @param partIntake `IntakeStruct` struct consisting of `partId` and a nested `Part` struct\\n     *\\n     */\\n    function _addPart(IntakeStruct memory partIntake) internal {\\n        uint64 partId = partIntake.partId;\\n        Part memory part = partIntake.part;\\n\\n        if (partId == uint64(0)) revert RMRKIdZeroForbidden();\\n        if (_parts[partId].itemType != ItemType.None)\\n            revert RMRKPartAlreadyExists();\\n        if (part.itemType == ItemType.None) revert RMRKBadConfig();\\n        if (part.itemType == ItemType.Fixed && part.equippable.length != 0)\\n            revert RMRKBadConfig();\\n\\n        _parts[partId] = part;\\n        _partIds.push(partId);\\n\\n        emit AddedPart(\\n            partId,\\n            part.itemType,\\n            part.z,\\n            part.equippable,\\n            part.metadataURI\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal function used to add multiple `equippableAddresses` to a single catalog entry.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***AddedEquippables*** event.\\n     * @param partId ID of the `Part` that we are adding the equippable addresses to\\n     * @param equippableAddresses An array of addresses that can be equipped into the `Part` associated with the `partId`\\n     */\\n    function _addEquippableAddresses(\\n        uint64 partId,\\n        address[] memory equippableAddresses\\n    ) internal onlySlot(partId) {\\n        if (equippableAddresses.length <= 0) revert RMRKZeroLengthIdsPassed();\\n\\n        uint256 len = equippableAddresses.length;\\n        for (uint256 i; i < len; ) {\\n            _parts[partId].equippable.push(equippableAddresses[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        delete _isEquippableToAll[partId];\\n\\n        emit AddedEquippables(partId, equippableAddresses);\\n    }\\n\\n    /**\\n     * @notice Internal function used to set the new list of `equippableAddresses`.\\n     * @dev Overwrites existing `equippableAddresses`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***SetEquippable*** event.\\n     * @param partId ID of the `Part`s that we are overwiting the `equippableAddresses` for\\n     * @param equippableAddresses A full array of addresses that can be equipped into this `Part`\\n     */\\n    function _setEquippableAddresses(\\n        uint64 partId,\\n        address[] memory equippableAddresses\\n    ) internal onlySlot(partId) {\\n        if (equippableAddresses.length <= 0) revert RMRKZeroLengthIdsPassed();\\n        _parts[partId].equippable = equippableAddresses;\\n        delete _isEquippableToAll[partId];\\n\\n        emit SetEquippables(partId, equippableAddresses);\\n    }\\n\\n    /**\\n     * @notice Internal function used to remove all of the `equippableAddresses` for a `Part` associated with the `partId`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***SetEquippable*** event.\\n     * @param partId ID of the part that we are clearing the `equippableAddresses` from\\n     */\\n    function _resetEquippableAddresses(\\n        uint64 partId\\n    ) internal onlySlot(partId) {\\n        delete _parts[partId].equippable;\\n        delete _isEquippableToAll[partId];\\n\\n        emit SetEquippables(partId, new address[](0));\\n    }\\n\\n    /**\\n     * @notice Sets the isEquippableToAll flag to true, meaning that any collection may be equipped into the `Part` with this\\n     *  `partId`.\\n     * @dev Can only be called on `Part`s of `Slot` type.\\n     * @dev Emits ***SetEquippableToAll*** event.\\n     * @param partId ID of the `Part` that we are setting as equippable by any address\\n     */\\n    function _setEquippableToAll(uint64 partId) internal onlySlot(partId) {\\n        _isEquippableToAll[partId] = true;\\n        emit SetEquippableToAll(partId);\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function checkIsEquippableToAll(\\n        uint64 partId\\n    ) public view returns (bool isEquippable) {\\n        isEquippable = _isEquippableToAll[partId];\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function checkIsEquippable(\\n        uint64 partId,\\n        address targetAddress\\n    ) public view returns (bool isEquippable) {\\n        // If this is equippable to all, we're good\\n        isEquippable = _isEquippableToAll[partId];\\n\\n        // Otherwise, must check against each of the equippable for the part\\n        if (!isEquippable && _parts[partId].itemType == ItemType.Slot) {\\n            address[] memory equippable = _parts[partId].equippable;\\n            uint256 len = equippable.length;\\n            for (uint256 i; i < len; ) {\\n                if (targetAddress == equippable[i]) {\\n                    isEquippable = true;\\n                    break;\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getPart(uint64 partId) public view returns (Part memory part) {\\n        part = (_parts[partId]);\\n    }\\n\\n    /**\\n     * @inheritdoc IRMRKCatalog\\n     */\\n    function getParts(\\n        uint64[] memory partIds\\n    ) public view returns (Part[] memory parts) {\\n        uint256 numParts = partIds.length;\\n        parts = new Part[](numParts);\\n\\n        for (uint256 i; i < numParts; ) {\\n            uint64 partId = partIds[i];\\n            parts[i] = _parts[partId];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1d99244727972b56a041ca4edf4ee183c03986eabba81f48c98548ad75fc4cbc\",\"license\":\"Apache-2.0\"},\"contracts/RMRKCore.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title RMRKCore\\n * @author RMRK team\\n * @notice Smart contract of the RMRK core module.\\n * @dev This is currently just a passthrough contract which allows for granular editing of base-level ERC721 functions.\\n */\\ncontract RMRKCore {\\n    string private constant _VERSION = \\\"2.3.2\\\";\\n    bytes4 private constant _RMRK_INTERFACE = 0x524D524B; // \\\"RMRK\\\" in ASCII hex\\n\\n    /**\\n     * @notice Version of the @rmrk-team/evm-contracts package\\n     * @return version Version identifier for implementations of the @rmrk-team/evm-contracts package\\n     */\\n    function VERSION() public pure returns (string memory version) {\\n        version = _VERSION;\\n    }\\n\\n    /**\\n     * @notice Interface identifier of the @rmrk-team/evm-contracts package\\n     * @return rmrkInterface Interface identifier for implementations of the @rmrk-team/evm-contracts package\\n     */\\n    function RMRK_INTERFACE() public pure returns (bytes4 rmrkInterface) {\\n        rmrkInterface = _RMRK_INTERFACE;\\n    }\\n}\",\"keccak256\":\"0x96ed0062d33f751a844208620d25c83318f8a68d03f97d4b0b34d991c1ab8874\",\"license\":\"Apache-2.0\"},\"contracts/RMRKEquippable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n//Generally all interactions should propagate downstream\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {IERC5773} from \\\"./IERC5773.sol\\\";\\nimport {IERC6220} from \\\"./IERC6220.sol\\\";\\nimport {IERC7401} from \\\"./IERC7401.sol\\\";\\nimport {IRMRKCatalog} from \\\"./IRMRKCatalog.sol\\\";\\nimport {RMRKLib} from \\\"./RMRKLib.sol\\\";\\nimport {AbstractMultiAsset} from \\\"./AbstractMultiAsset.sol\\\";\\nimport {RMRKNestable} from \\\"./RMRKNestable.sol\\\";\\nimport {ReentrancyGuard} from \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./RMRKErrors.sol\\\";\\n\\n/**\\n * @title RMRKEquippable\\n * @author RMRK team\\n * @notice Smart contract of the RMRK Equippable module.\\n */\\ncontract RMRKEquippable is\\n    ReentrancyGuard,\\n    RMRKNestable,\\n    AbstractMultiAsset,\\n    IERC6220\\n{\\n    using RMRKLib for uint64[];\\n\\n    // ------------------- ASSETS --------------\\n\\n    // ------------------- ASSET APPROVALS --------------\\n\\n    /**\\n     * @notice Mapping from token ID to approver address to approved address for assets.\\n     * @dev The approver is necessary so approvals are invalidated for nested children on transfer.\\n     * @dev WARNING: If a child NFT returns the original root owner, old permissions would be active again.\\n     */\\n    mapping(uint256 => mapping(address => address))\\n        private _tokenApprovalsForAssets;\\n\\n    // ------------------- EQUIPPABLE --------------\\n    /// Mapping of uint64 asset ID to corresponding catalog address.\\n    mapping(uint64 => address) internal _catalogAddresses;\\n    /// Mapping of uint64 ID to asset object.\\n    mapping(uint64 => uint64) internal _equippableGroupIds;\\n    /// Mapping of assetId to catalog parts applicable to this asset, both fixed and slot\\n    mapping(uint64 => uint64[]) internal _partIds;\\n\\n    /// Mapping of token ID to catalog address to slot part ID to equipment information. Used to compose an NFT.\\n    mapping(uint256 => mapping(address => mapping(uint64 => Equipment)))\\n        internal _equipments;\\n\\n    /// Mapping of token ID to child (nestable) address to child ID to count of equipped items. Used to check if equipped.\\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256)))\\n        internal _equipCountPerChild;\\n\\n    /// Mapping of `equippableGroupId` to parent contract address and valid `slotId`.\\n    mapping(uint64 => mapping(address => uint64)) internal _validParentSlots;\\n\\n    /**\\n     * @notice Used to verify that the caller is either the owner of the given token or approved to manage the token's assets\\n     *  of the owner.\\n     * @param tokenId ID of the token that we are checking\\n     */\\n    function _onlyApprovedForAssetsOrOwner(uint256 tokenId) internal view {\\n        if (!_isApprovedForAssetsOrOwner(_msgSender(), tokenId))\\n            revert RMRKNotApprovedForAssetsOrOwner();\\n    }\\n\\n    /**\\n     * @notice Used to ensure that the caller is either the owner of the given token or approved to manage the token's assets\\n     *  of the owner.\\n     * @dev If that is not the case, the execution of the function will be reverted.\\n     * @param tokenId ID of the token that we are checking\\n     */\\n    modifier onlyApprovedForAssetsOrOwner(uint256 tokenId) {\\n        _onlyApprovedForAssetsOrOwner(tokenId);\\n        _;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(IERC165, RMRKNestable) returns (bool) {\\n        return\\n            RMRKNestable.supportsInterface(interfaceId) ||\\n            interfaceId == type(IERC5773).interfaceId ||\\n            interfaceId == type(IERC6220).interfaceId;\\n    }\\n\\n    // ------------------------------- ASSETS ------------------------------\\n\\n    // --------------------------- ASSET HANDLERS -------------------------\\n\\n    /**\\n     * @notice Accepts a asset at from the pending array of given token.\\n     * @dev Migrates the asset from the token's pending asset array to the token's active asset array.\\n     * @dev Active assets cannot be removed by anyone, but can be replaced by a new asset.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits an {AssetAccepted} event.\\n     * @param tokenId ID of the token for which to accept the pending asset\\n     * @param index Index of the asset in the pending array to accept\\n     * @param assetId ID of the asset that is being accepted\\n     */\\n    function acceptAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) public virtual onlyApprovedForAssetsOrOwner(tokenId) {\\n        _acceptAsset(tokenId, index, assetId);\\n    }\\n\\n    /**\\n     * @notice Rejects a asset from the pending array of given token.\\n     * @dev Removes the asset from the token's pending asset array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - `index` must be in range of the length of the pending asset array.\\n     * @dev Emits a {AssetRejected} event.\\n     * @param tokenId ID of the token that the asset is being rejected from\\n     * @param index Index of the asset in the pending array to be rejected\\n     * @param assetId ID of the asset that is being rejected\\n     */\\n    function rejectAsset(\\n        uint256 tokenId,\\n        uint256 index,\\n        uint64 assetId\\n    ) public virtual onlyApprovedForAssetsOrOwner(tokenId) {\\n        _rejectAsset(tokenId, index, assetId);\\n    }\\n\\n    /**\\n     * @notice Rejects all assets from the pending array of a given token.\\n     * @dev Effecitvely deletes the pending array.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     * @dev Emits a {AssetRejected} event with assetId = 0.\\n     * @param tokenId ID of the token of which to clear the pending array.\\n     * @param maxRejections Maximum number of expected assets to reject, used to prevent from rejecting assets which\\n     *  arrive just before this operation.\\n     */\\n    function rejectAllAssets(\\n        uint256 tokenId,\\n        uint256 maxRejections\\n    ) public virtual onlyApprovedForAssetsOrOwner(tokenId) {\\n        _rejectAllAssets(tokenId, maxRejections);\\n    }\\n\\n    /**\\n     * @notice Sets a new priority array for a given token.\\n     * @dev The priority array is a non-sequential list of `uint64`s, where the lowest value is considered highest\\n     *  priority.\\n     * @dev Value `0` of a priority is a special case equivalent to unitialized.\\n     * @dev Requirements:\\n     *\\n     *  - The caller must own the token or be approved to manage the token's assets\\n     *  - `tokenId` must exist.\\n     *  - The length of `priorities` must be equal the length of the active assets array.\\n     * @dev Emits a {AssetPrioritySet} event.\\n     * @param tokenId ID of the token to set the priorities for\\n     * @param priorities An array of priority values\\n     */\\n    function setPriority(\\n        uint256 tokenId,\\n        uint64[] calldata priorities\\n    ) public virtual onlyApprovedForAssetsOrOwner(tokenId) {\\n        _setPriority(tokenId, priorities);\\n    }\\n\\n    // --------------------------- ASSET INTERNALS -------------------------\\n\\n    /**\\n     * @notice Used to add a asset entry.\\n     * @dev This internal function warrants custom access control to be implemented when used.\\n     * @param id ID of the asset being added\\n     * @param equippableGroupId ID of the equippable group being marked as equippable into the slot associated with\\n     *  `Parts` of the `Slot` type\\n     * @param catalogAddress Address of the `Catalog` associated with the asset\\n     * @param metadataURI The metadata URI of the asset\\n     * @param partIds An array of IDs of fixed and slot parts to be included in the asset\\n     */\\n    function _addAssetEntry(\\n        uint64 id,\\n        uint64 equippableGroupId,\\n        address catalogAddress,\\n        string memory metadataURI,\\n        uint64[] memory partIds\\n    ) internal virtual {\\n        _addAssetEntry(id, metadataURI);\\n\\n        if (catalogAddress == address(0) && partIds.length != 0)\\n            revert RMRKCatalogRequiredForParts();\\n\\n        _catalogAddresses[id] = catalogAddress;\\n        _equippableGroupIds[id] = equippableGroupId;\\n        _partIds[id] = partIds;\\n    }\\n\\n    // ----------------------- ASSET APPROVALS ------------------------\\n\\n    /**\\n     * @notice Used to grant approvals for specific tokens to a specified address.\\n     * @dev This can only be called by the owner of the token or by an account that has been granted permission to\\n     *  manage all of the owner's assets.\\n     * @param to Address of the account to receive the approval to the specified token\\n     * @param tokenId ID of the token for which we are granting the permission\\n     */\\n    function approveForAssets(address to, uint256 tokenId) public virtual {\\n        address owner = ownerOf(tokenId);\\n        if (to == owner) revert RMRKApprovalForAssetsToCurrentOwner();\\n\\n        if (\\n            _msgSender() != owner &&\\n            !isApprovedForAllForAssets(owner, _msgSender())\\n        ) revert RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll();\\n        _approveForAssets(to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC5773\\n     */\\n    function getApprovedForAssets(\\n        uint256 tokenId\\n    ) public view virtual returns (address approved) {\\n        _requireMinted(tokenId);\\n        approved = _tokenApprovalsForAssets[tokenId][ownerOf(tokenId)];\\n    }\\n\\n    /**\\n     * @notice Internal function to check whether the queried user is either:\\n     *   1. The root owner of the token associated with `tokenId`.\\n     *   2. Is approved for all assets of the current owner via the `setApprovalForAllForAssets` function.\\n     *   3. Is granted approval for the specific tokenId for asset management via the `approveForAssets` function.\\n     * @param user Address of the user we are checking for permission\\n     * @param tokenId ID of the token to query for permission for a given `user`\\n     * @return A boolean value indicating whether the user is approved to manage the token or not\\n     */\\n    function _isApprovedForAssetsOrOwner(\\n        address user,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool) {\\n        address owner = ownerOf(tokenId);\\n        return (user == owner ||\\n            isApprovedForAllForAssets(owner, user) ||\\n            getApprovedForAssets(tokenId) == user);\\n    }\\n\\n    /**\\n     * @notice Internal function for granting approvals for a specific token.\\n     * @param to Address of the account we are granting an approval to\\n     * @param tokenId ID of the token we are granting the approval for\\n     */\\n    function _approveForAssets(address to, uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n        _tokenApprovalsForAssets[tokenId][owner] = to;\\n        emit ApprovalForAssets(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @notice Used to clear the approvals on a given token.\\n     * @param tokenId ID of the token we are clearing the approvals of\\n     */\\n    function _cleanApprovals(uint256 tokenId) internal virtual override {\\n        _approveForAssets(address(0), tokenId);\\n    }\\n\\n    // ------------------------------- EQUIPPING ------------------------------\\n\\n    /**\\n     * @inheritdoc RMRKNestable\\n     */\\n    function _transferChild(\\n        uint256 tokenId,\\n        address to,\\n        uint256 destinationId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId,\\n        bool isPending,\\n        bytes memory data\\n    ) internal virtual override {\\n        if (!isPending) {\\n            if (isChildEquipped(tokenId, childAddress, childId))\\n                revert RMRKMustUnequipFirst();\\n        }\\n        super._transferChild(\\n            tokenId,\\n            to,\\n            destinationId,\\n            childIndex,\\n            childAddress,\\n            childId,\\n            isPending,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6220\\n     */\\n    function equip(\\n        IntakeEquip memory data\\n    ) public virtual onlyApprovedForAssetsOrOwner(data.tokenId) nonReentrant {\\n        _equip(data);\\n    }\\n\\n    /**\\n     * @notice Private function used to equip a child into a token.\\n     * @dev If the `Slot` already has an item equipped, the execution will be reverted.\\n     * @dev If the child can't be used in the given `Slot`, the execution will be reverted.\\n     * @dev If the catalog doesn't allow this equip to happen, the execution will be reverted.\\n     * @dev The `IntakeEquip` stuct contains the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @dev Emits ***ChildAssetEquipped*** event.\\n     * @param data An `IntakeEquip` struct specifying the equip data\\n     */\\n    function _equip(IntakeEquip memory data) internal virtual {\\n        address catalogAddress = _catalogAddresses[data.assetId];\\n        uint64 slotPartId = data.slotPartId;\\n        if (\\n            _equipments[data.tokenId][catalogAddress][slotPartId]\\n                .childEquippableAddress != address(0)\\n        ) revert RMRKSlotAlreadyUsed();\\n\\n        // Check from parent's asset perspective:\\n        _checkAssetAcceptsSlot(data.assetId, slotPartId);\\n\\n        IERC7401.Child memory child = childOf(data.tokenId, data.childIndex);\\n\\n        // Check from child perspective intention to be used in part\\n        // We add reentrancy guard because of this call, it happens before updating state\\n        if (\\n            !IERC6220(child.contractAddress)\\n                .canTokenBeEquippedWithAssetIntoSlot(\\n                    address(this),\\n                    child.tokenId,\\n                    data.childAssetId,\\n                    slotPartId\\n                )\\n        ) revert RMRKTokenCannotBeEquippedWithAssetIntoSlot();\\n\\n        // Check from catalog perspective\\n        if (\\n            !IRMRKCatalog(catalogAddress).checkIsEquippable(\\n                slotPartId,\\n                child.contractAddress\\n            )\\n        ) revert RMRKEquippableEquipNotAllowedByCatalog();\\n\\n        _beforeEquip(data);\\n        Equipment memory newEquip = Equipment({\\n            assetId: data.assetId,\\n            childAssetId: data.childAssetId,\\n            childId: child.tokenId,\\n            childEquippableAddress: child.contractAddress\\n        });\\n\\n        _equipments[data.tokenId][catalogAddress][slotPartId] = newEquip;\\n        _equipCountPerChild[data.tokenId][child.contractAddress][\\n            child.tokenId\\n        ] += 1;\\n\\n        emit ChildAssetEquipped(\\n            data.tokenId,\\n            data.assetId,\\n            slotPartId,\\n            child.tokenId,\\n            child.contractAddress,\\n            data.childAssetId\\n        );\\n        _afterEquip(data);\\n    }\\n\\n    /**\\n     * @notice Private function to check if a given asset accepts a given slot or not.\\n     * @dev Execution will be reverted if the `Slot` does not apply for the asset.\\n     * @param assetId ID of the asset\\n     * @param slotPartId ID of the `Slot`\\n     */\\n    function _checkAssetAcceptsSlot(\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) private view {\\n        (, bool found) = _partIds[assetId].indexOf(slotPartId);\\n        if (!found) revert RMRKTargetAssetCannotReceiveSlot();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6220\\n     */\\n    function unequip(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) public virtual onlyApprovedForAssetsOrOwner(tokenId) {\\n        _unequip(tokenId, assetId, slotPartId);\\n    }\\n\\n    /**\\n     * @notice Private function used to unequip child from parent token.\\n     * @dev Emits ***ChildAssetUnequipped*** event.\\n     * @param tokenId ID of the parent from which the child is being unequipped\\n     * @param assetId ID of the parent's asset that contains the `Slot` into which the child is equipped\\n     * @param slotPartId ID of the `Slot` from which to unequip the child\\n     */\\n    function _unequip(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) internal virtual {\\n        address targetCatalogAddress = _catalogAddresses[assetId];\\n        Equipment memory equipment = _equipments[tokenId][targetCatalogAddress][\\n            slotPartId\\n        ];\\n        if (equipment.childEquippableAddress == address(0))\\n            revert RMRKNotEquipped();\\n        _beforeUnequip(tokenId, assetId, slotPartId);\\n\\n        delete _equipments[tokenId][targetCatalogAddress][slotPartId];\\n        _equipCountPerChild[tokenId][equipment.childEquippableAddress][\\n            equipment.childId\\n        ] -= 1;\\n\\n        emit ChildAssetUnequipped(\\n            tokenId,\\n            assetId,\\n            slotPartId,\\n            equipment.childId,\\n            equipment.childEquippableAddress,\\n            equipment.childAssetId\\n        );\\n        _afterUnequip(tokenId, assetId, slotPartId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6220\\n     */\\n    function isChildEquipped(\\n        uint256 tokenId,\\n        address childAddress,\\n        uint256 childId\\n    ) public view virtual returns (bool isEquipped) {\\n        isEquipped = _equipCountPerChild[tokenId][childAddress][childId] != 0;\\n    }\\n\\n    // --------------------- ADMIN VALIDATION ---------------------\\n\\n    /**\\n     * @notice Internal function used to declare that the assets belonging to a given `equippableGroupId` are\\n     *  equippable into the `Slot` associated with the `partId` of the collection at the specified `parentAddress`.\\n     * @dev Emits ***ValidParentEquippableGroupIdSet*** event.\\n     * @param equippableGroupId ID of the equippable group\\n     * @param parentAddress Address of the parent into which the equippable group can be equipped into\\n     * @param slotPartId ID of the `Slot` that the items belonging to the equippable group can be equipped into\\n     */\\n    function _setValidParentForEquippableGroup(\\n        uint64 equippableGroupId,\\n        address parentAddress,\\n        uint64 slotPartId\\n    ) internal virtual {\\n        if (equippableGroupId == uint64(0) || slotPartId == uint64(0))\\n            revert RMRKIdZeroForbidden();\\n        _validParentSlots[equippableGroupId][parentAddress] = slotPartId;\\n        emit ValidParentEquippableGroupIdSet(\\n            equippableGroupId,\\n            slotPartId,\\n            parentAddress\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6220\\n     */\\n    function canTokenBeEquippedWithAssetIntoSlot(\\n        address parent,\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotId\\n    ) public view virtual returns (bool canBeEquipped) {\\n        uint64 equippableGroupId = _equippableGroupIds[assetId];\\n        uint64 equippableSlot = _validParentSlots[equippableGroupId][parent];\\n        if (equippableSlot == slotId) {\\n            (, bool found) = getActiveAssets(tokenId).indexOf(assetId);\\n            canBeEquipped = found;\\n        }\\n    }\\n\\n    // --------------------- Getting Extended Assets ---------------------\\n\\n    /**\\n     * @inheritdoc IERC6220\\n     */\\n    function getAssetAndEquippableData(\\n        uint256 tokenId,\\n        uint64 assetId\\n    )\\n        public\\n        view\\n        virtual\\n        returns (\\n            string memory metadataURI,\\n            uint64 equippableGroupId,\\n            address catalogAddress,\\n            uint64[] memory partIds\\n        )\\n    {\\n        metadataURI = getAssetMetadata(tokenId, assetId);\\n        equippableGroupId = _equippableGroupIds[assetId];\\n        catalogAddress = _catalogAddresses[assetId];\\n        partIds = _partIds[assetId];\\n    }\\n\\n    ////////////////////////////////////////\\n    //              UTILS\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @inheritdoc IERC6220\\n     */\\n    function getEquipment(\\n        uint256 tokenId,\\n        address targetCatalogAddress,\\n        uint64 slotPartId\\n    ) public view virtual returns (Equipment memory equipment) {\\n        equipment = _equipments[tokenId][targetCatalogAddress][slotPartId];\\n    }\\n\\n    // HOOKS\\n\\n    /**\\n     * @notice A hook to be called before a equipping a asset to the token.\\n     * @dev The `IntakeEquip` struct consist of the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @param data The `IntakeEquip` struct containing data of the asset that is being equipped\\n     */\\n    function _beforeEquip(IntakeEquip memory data) internal virtual {}\\n\\n    /**\\n     * @notice A hook to be called after equipping a asset to the token.\\n     * @dev The `IntakeEquip` struct consist of the following data:\\n     *  [\\n     *      tokenId,\\n     *      childIndex,\\n     *      assetId,\\n     *      slotPartId,\\n     *      childAssetId\\n     *  ]\\n     * @param data The `IntakeEquip` struct containing data of the asset that was equipped\\n     */\\n    function _afterEquip(IntakeEquip memory data) internal virtual {}\\n\\n    /**\\n     * @notice A hook to be called before unequipping a asset from the token.\\n     * @param tokenId ID of the token from which the asset is being unequipped\\n     * @param assetId ID of the asset being unequipped\\n     * @param slotPartId ID of the slot from which the asset is being unequipped\\n     */\\n    function _beforeUnequip(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice A hook to be called after unequipping a asset from the token.\\n     * @param tokenId ID of the token from which the asset was unequipped\\n     * @param assetId ID of the asset that was unequipped\\n     * @param slotPartId ID of the slot from which the asset was unequipped\\n     */\\n    function _afterUnequip(\\n        uint256 tokenId,\\n        uint64 assetId,\\n        uint64 slotPartId\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x5fbe231a9a2fe0d7b0d57ef6154d9f56b5b6e7cc2b41af0d83051d5e53c84819\",\"license\":\"Apache-2.0\"},\"contracts/RMRKErrors.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/// @title RMRKErrors\\n/// @author RMRK team\\n/// @notice A collection of errors used in the RMRK suite\\n/// @dev Errors are kept in a centralised file in order to provide a central point of reference and to avoid error\\n///  naming collisions due to inheritance\\n\\n/// Attempting to grant the token to 0x0 address\\nerror ERC721AddressZeroIsNotaValidOwner();\\n/// Attempting to grant approval to the current owner of the token\\nerror ERC721ApprovalToCurrentOwner();\\n/// Attempting to grant approval when not being owner or approved for all should not be permitted\\nerror ERC721ApproveCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to grant approval to self\\nerror ERC721ApproveToCaller();\\n/// Attempting to use an invalid token ID\\nerror ERC721InvalidTokenId();\\n/// Attempting to mint to 0x0 address\\nerror ERC721MintToTheZeroAddress();\\n/// Attempting to manage a token without being its owner or approved by the owner\\nerror ERC721NotApprovedOrOwner();\\n/// Attempting to mint an already minted token\\nerror ERC721TokenAlreadyMinted();\\n/// Attempting to transfer the token from an address that is not the owner\\nerror ERC721TransferFromIncorrectOwner();\\n/// Attempting to safe transfer to an address that is unable to receive the token\\nerror ERC721TransferToNonReceiverImplementer();\\n/// Attempting to transfer the token to a 0x0 address\\nerror ERC721TransferToTheZeroAddress();\\n/// Attempting to grant approval of assets to their current owner\\nerror RMRKApprovalForAssetsToCurrentOwner();\\n/// Attempting to grant approval of assets without being the caller or approved for all\\nerror RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll();\\n/// Attempting to incorrectly configue a Catalog item\\nerror RMRKBadConfig();\\n/// Attempting to set the priorities with an array of length that doesn't match the length of active assets array\\nerror RMRKBadPriorityListLength();\\n/// Attempting to add an asset entry with `Part`s, without setting the `Catalog` address\\nerror RMRKCatalogRequiredForParts();\\n/// Attempting to transfer a soulbound (non-transferrable) token\\nerror RMRKCannotTransferSoulbound();\\n/// Attempting to accept a child that has already been accepted\\nerror RMRKChildAlreadyExists();\\n/// Attempting to interact with a child, using index that is higher than the number of children\\nerror RMRKChildIndexOutOfRange();\\n/// Attempting to find the index of a child token on a parent which does not own it.\\nerror RMRKChildNotFoundInParent();\\n/// Attempting to equip a `Part` with a child not approved by the Catalog\\nerror RMRKEquippableEquipNotAllowedByCatalog();\\n/// Attempting to use ID 0, which is not supported\\n/// @dev The ID 0 in RMRK suite is reserved for empty values. Guarding against its use ensures the expected operation\\nerror RMRKIdZeroForbidden();\\n/// Attempting to interact with an asset, using index greater than number of assets\\nerror RMRKIndexOutOfRange();\\n/// Attempting to reclaim a child that can't be reclaimed\\nerror RMRKInvalidChildReclaim();\\n/// Attempting to interact with an end-user account when the contract account is expected\\nerror RMRKIsNotContract();\\n/// Attempting to interact with a contract that had its operation locked\\nerror RMRKLocked();\\n/// Attempting to add a pending child after the number of pending children has reached the limit (default limit is 128)\\nerror RMRKMaxPendingChildrenReached();\\n/// Attempting to add a pending asset after the number of pending assets has reached the limit (default limit is\\n///  128)\\nerror RMRKMaxPendingAssetsReached();\\n/// Attempting to burn a total number of recursive children higher than maximum set\\n/// @param childContract Address of the collection smart contract in which the maximum number of recursive burns was reached\\n/// @param childId ID of the child token at which the maximum number of recursive burns was reached\\nerror RMRKMaxRecursiveBurnsReached(address childContract, uint256 childId);\\n/// Attempting to mint a number of tokens that would cause the total supply to be greater than maximum supply\\nerror RMRKMintOverMax();\\n/// Attempting to mint zero tokens\\nerror RMRKMintZero();\\n/// Attempting to pass complementary arrays of different lengths\\nerror RMRKMismachedArrayLength();\\n/// Attempting to transfer a child before it is unequipped\\nerror RMRKMustUnequipFirst();\\n/// Attempting to nest a child over the nestable limit (current limit is 100 levels of nesting)\\nerror RMRKNestableTooDeep();\\n/// Attempting to nest the token to own descendant, which would create a loop and leave the looped tokens in limbo\\nerror RMRKNestableTransferToDescendant();\\n/// Attempting to nest the token to a smart contract that doesn't support nesting\\nerror RMRKNestableTransferToNonRMRKNestableImplementer();\\n/// Attempting to nest the token into itself\\nerror RMRKNestableTransferToSelf();\\n/// Attempting to interact with an asset that can not be found\\nerror RMRKNoAssetMatchingId();\\n/// Attempting to manage an asset without owning it or having been granted permission by the owner to do so\\nerror RMRKNotApprovedForAssetsOrOwner();\\n/// Attempting to interact with a token without being its owner or having been granted permission by the\\n///  owner to do so\\n/// @dev When a token is nested, only the direct owner (NFT parent) can mange it. In that case, approved addresses are\\n///  not allowed to manage it, in order to ensure the expected behaviour\\nerror RMRKNotApprovedOrDirectOwner();\\n/// Attempting to compose an asset wihtout having an associated Catalog\\nerror RMRKNotComposableAsset();\\n/// Attempting to unequip an item that isn't equipped\\nerror RMRKNotEquipped();\\n/// Attempting to interact with a management function without being the smart contract's owner\\nerror RMRKNotOwner();\\n/// Attempting to interact with a function without being the owner or contributor of the collection\\nerror RMRKNotOwnerOrContributor();\\n/// Attempting to transfer the ownership to the 0x0 address\\nerror RMRKNewOwnerIsZeroAddress();\\n/// Attempting to assign a 0x0 address as a contributor\\nerror RMRKNewContributorIsZeroAddress();\\n/// Attempting an operation requiring the token being nested, while it is not\\nerror RMRKParentIsNotNFT();\\n/// Attempting to add a `Part` with an ID that is already used\\nerror RMRKPartAlreadyExists();\\n/// Attempting to use a `Part` that doesn't exist\\nerror RMRKPartDoesNotExist();\\n/// Attempting to use a `Part` that is `Fixed` when `Slot` kind of `Part` should be used\\nerror RMRKPartIsNotSlot();\\n/// Attempting to interact with a pending child using an index greater than the size of pending array\\nerror RMRKPendingChildIndexOutOfRange();\\n/// Attempting to add an asset using an ID that has already been used\\nerror RMRKAssetAlreadyExists();\\n/// Attempting to equip an item into a slot that already has an item equipped\\nerror RMRKSlotAlreadyUsed();\\n/// Attempting to equip an item into a `Slot` that the target asset does not implement\\nerror RMRKTargetAssetCannotReceiveSlot();\\n/// Attempting to equip a child into a `Slot` and parent that the child's collection doesn't support\\nerror RMRKTokenCannotBeEquippedWithAssetIntoSlot();\\n/// Attempting to compose a NFT of a token without active assets\\nerror RMRKTokenDoesNotHaveAsset();\\n/// Attempting to determine the asset with the top priority on a token without assets\\nerror RMRKTokenHasNoAssets();\\n/// Attempting to accept or transfer a child which does not match the one at the specified index\\nerror RMRKUnexpectedChildId();\\n/// Attempting to reject all pending assets but more assets than expected are pending\\nerror RMRKUnexpectedNumberOfAssets();\\n/// Attempting to reject all pending children but children assets than expected are pending\\nerror RMRKUnexpectedNumberOfChildren();\\n/// Attempting to accept or reject an asset which does not match the one at the specified index\\nerror RMRKUnexpectedAssetId();\\n/// Attempting an operation expecting a parent to the token which is not the actual one\\nerror RMRKUnexpectedParent();\\n/// Attempting not to pass an empty array of equippable addresses when adding or setting the equippable addresses\\nerror RMRKZeroLengthIdsPassed();\\n/// Attempting to set the royalties to a value higher than 100% (10000 in basis points)\\nerror RMRKRoyaltiesTooHigh();\\n/// Attempting to do a bulk operation on a token that is not owned by the caller\\nerror RMRKCanOnlyDoBulkOperationsOnOwnedTokens();\\n/// Attempting to do a bulk operation with multiple tokens at a time\\nerror RMRKCanOnlyDoBulkOperationsWithOneTokenAtATime();\\n/// Attempting to pay with native token with a value different than expected\\nerror RMRKWrongValueSent();\\n// Attempting to send native token to a recipient that is unable to receive it\\nerror TransferFailed();\",\"keccak256\":\"0x5ccf6f776fd1671316fad0d7371af3e5194403a8ce2577b12be237ed78b2ce4b\",\"license\":\"Apache-2.0\"},\"contracts/RMRKLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title RMRKLib\\n * @author RMRK team\\n * @notice RMRK library smart contract.\\n */\\nlibrary RMRKLib {\\n    error IndexOutOfBounds();\\n\\n    /**\\n     * @notice Used to remove an item from the array using the specified index.\\n     * @dev The item is removed by replacing it with the last item and removing the last element.\\n     * @param array An array of items containing the item to be removed\\n     * @param index Index of the item to remove\\n     */\\n    function removeItemByIndex(uint64[] storage array, uint256 index) internal {\\n        //Check to see if this is already gated by require in all calls\\n        if (index >= array.length) revert IndexOutOfBounds();\\n        array[index] = array[array.length - 1];\\n        array.pop();\\n    }\\n\\n    /**\\n     * @notice Used to determine the index of the item in the array by spedifying its value.\\n     * @dev This was adapted from Cryptofin-Solidity `arrayUtils`.\\n     * @dev If the item is not found the index returned will equal `0`.\\n     * @param A The array containing the item to be found\\n     * @param a The value of the item to find the index of\\n     * @return The index of the item in the array\\n     * @return A boolean value specifying whether the item was found\\n     */\\n    function indexOf(\\n        uint64[] memory A,\\n        uint64 a\\n    ) internal pure returns (uint256, bool) {\\n        uint256 length = A.length;\\n        for (uint256 i; i < length; ) {\\n            if (A[i] == a) {\\n                return (i, true);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (0, false);\\n    }\\n}\",\"keccak256\":\"0x85d6166c1a7931135f6d1da218624ff3ebbb3ec922b644599561d42e3b6e4608\",\"license\":\"Apache-2.0\"},\"contracts/RMRKNestable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n//Generally all interactions should propagate downstream\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC7401} from \\\"./IERC7401.sol\\\";\\nimport {RMRKCore} from \\\"./RMRKCore.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"./RMRKErrors.sol\\\";\\n\\n/**\\n * @title RMRKNestable\\n * @author RMRK team\\n * @notice Smart contract of the RMRK Nestable module.\\n * @dev This contract is hierarchy agnostic and can support an arbitrary number of nested levels up and down, as long as\\n *  gas limits allow it.\\n */\\ncontract RMRKNestable is Context, IERC165, IERC721, IERC7401, RMRKCore {\\n    uint256 private constant _MAX_LEVELS_TO_CHECK_FOR_INHERITANCE_LOOP = 100;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approver address to approved address\\n    // The approver is necessary so approvals are invalidated for nested children on transfer\\n    // WARNING: If a child NFT returns to a previous root owner, old permissions would be active again\\n    mapping(uint256 => mapping(address => address)) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // ------------------- NESTABLE --------------\\n\\n    // Mapping from token ID to DirectOwner struct\\n    mapping(uint256 => DirectOwner) private _RMRKOwners;\\n\\n    // Mapping of tokenId to array of active children structs\\n    mapping(uint256 => Child[]) internal _activeChildren;\\n\\n    // Mapping of tokenId to array of pending children structs\\n    mapping(uint256 => Child[]) internal _pendingChildren;\\n\\n    // Mapping of child token address to child token ID to whether they are pending or active on any token\\n    // We might have a first extra mapping from token ID, but since the same child cannot be nested into multiple tokens\\n    //  we can strip it for size/gas savings.\\n    mapping(address => mapping(uint256 => uint256)) internal _childIsInActive;\\n\\n    // -------------------------- MODIFIERS ----------------------------\\n\\n    /**\\n     * @notice Used to verify that the caller is either the owner of the token or approved to manage it by its owner.\\n     * @dev If the caller is not the owner of the token or approved to manage it by its owner, the execution will be\\n     *  reverted.\\n     * @param tokenId ID of the token to check\\n     */\\n    function _onlyApprovedOrOwner(uint256 tokenId) internal view {\\n        if (!_isApprovedOrOwner(_msgSender(), tokenId))\\n            revert ERC721NotApprovedOrOwner();\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is either the owner of the token or approved to manage it by its owner.\\n     * @param tokenId ID of the token to check\\n     */\\n    modifier onlyApprovedOrOwner(uint256 tokenId) {\\n        _onlyApprovedOrOwner(tokenId);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is approved to manage the given token or it its direct owner.\\n     * @dev This does not delegate to ownerOf, which returns the root owner, but rater uses an owner from DirectOwner\\n     *  struct.\\n     * @dev The execution is reverted if the caller is not immediate owner or approved to manage the given token.\\n     * @dev Used for parent-scoped transfers.\\n     * @param tokenId ID of the token to check.\\n     */\\n    function _onlyApprovedOrDirectOwner(uint256 tokenId) internal view {\\n        if (!_isApprovedOrDirectOwner(_msgSender(), tokenId))\\n            revert RMRKNotApprovedOrDirectOwner();\\n    }\\n\\n    /**\\n     * @notice Used to verify that the caller is approved to manage the given token or is its direct owner.\\n     * @param tokenId ID of the token to check\\n     */\\n    modifier onlyApprovedOrDirectOwner(uint256 tokenId) {\\n        _onlyApprovedOrDirectOwner(tokenId);\\n        _;\\n    }\\n\\n    // ------------------------------- ERC721 ---------------------------------\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual returns (bool) {\\n        return\\n            interfaceId == type(IERC165).interfaceId ||\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC7401).interfaceId;\\n    }\\n\\n    /**\\n     * @notice Used to retrieve the number of tokens in `owner`'s account.\\n     * @param owner Address of the account being checked\\n     * @return balance The balance of the given account\\n     */\\n    function balanceOf(\\n        address owner\\n    ) public view virtual returns (uint256 balance) {\\n        if (owner == address(0)) revert ERC721AddressZeroIsNotaValidOwner();\\n        balance = _balances[owner];\\n    }\\n\\n    ////////////////////////////////////////\\n    //              TRANSFERS\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @notice Transfers a given token from `from` to `to`.\\n     * @dev Requirements:\\n     *\\n     *  - `from` cannot be the zero address.\\n     *  - `to` cannot be the zero address.\\n     *  - `tokenId` token must be owned by `from`.\\n     *  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * @dev Emits a {Transfer} event.\\n     * @param from Address from which to transfer the token from\\n     * @param to Address to which to transfer the token to\\n     * @param tokenId ID of the token to transfer\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual onlyApprovedOrDirectOwner(tokenId) {\\n        _transfer(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @notice Used to safely transfer a given token token from `from` to `to`.\\n     * @dev Requirements:\\n     *\\n     *  - `from` cannot be the zero address.\\n     *  - `to` cannot be the zero address.\\n     *  - `tokenId` token must exist and be owned by `from`.\\n     *  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *  - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     * @dev Emits a {Transfer} event.\\n     * @param from Address to transfer the tokens from\\n     * @param to Address to transfer the tokens to\\n     * @param tokenId ID of the token to transfer\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @notice Used to safely transfer a given token token from `from` to `to`.\\n     * @dev Requirements:\\n     *\\n     *  - `from` cannot be the zero address.\\n     *  - `to` cannot be the zero address.\\n     *  - `tokenId` token must exist and be owned by `from`.\\n     *  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *  - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     * @dev Emits a {Transfer} event.\\n     * @param from Address to transfer the tokens from\\n     * @param to Address to transfer the tokens to\\n     * @param tokenId ID of the token to transfer\\n     * @param data Additional data without a specified format to be sent along with the token transaction\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual onlyApprovedOrDirectOwner(tokenId) {\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function nestTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 destinationId,\\n        bytes memory data\\n    ) public virtual onlyApprovedOrDirectOwner(tokenId) {\\n        _nestTransfer(from, to, tokenId, destinationId, data);\\n    }\\n\\n    /**\\n     * @notice Used to safely transfer the token form `from` to `to`.\\n     * @dev The function checks that contract recipients are aware of the ERC721 protocol to prevent tokens from being\\n     *  forever locked.\\n     * @dev This internal function is equivalent to {safeTransferFrom}, and can be used to e.g. implement alternative\\n     *  mechanisms to perform token transfer, such as signature-based.\\n     * @dev Requirements:\\n     *\\n     *  - `from` cannot be the zero address.\\n     *  - `to` cannot be the zero address.\\n     *  - `tokenId` token must exist and be owned by `from`.\\n     *  - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     * @dev Emits a {Transfer} event.\\n     * @param from Address of the account currently owning the given token\\n     * @param to Address to transfer the token to\\n     * @param tokenId ID of the token to transfer\\n     * @param data Additional data with no specified format, sent in call to `to`\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId, data);\\n        if (!_checkOnERC721Received(from, to, tokenId, data))\\n            revert ERC721TransferToNonReceiverImplementer();\\n    }\\n\\n    /**\\n     * @notice Used to transfer the token from `from` to `to`.\\n     * @dev As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     * @dev Requirements:\\n     *\\n     *  - `to` cannot be the zero address.\\n     *  - `tokenId` token must be owned by `from`.\\n     * @dev Emits a {Transfer} event.\\n     * @param from Address of the account currently owning the given token\\n     * @param to Address to transfer the token to\\n     * @param tokenId ID of the token to transfer\\n     * @param data Additional data with no specified format, sent in call to `to`\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        (address immediateOwner, uint256 parentId, ) = directOwnerOf(tokenId);\\n        if (immediateOwner != from) revert ERC721TransferFromIncorrectOwner();\\n        if (to == address(0)) revert ERC721TransferToTheZeroAddress();\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n        _beforeNestedTokenTransfer(from, to, parentId, 0, tokenId, data);\\n\\n        _balances[from] -= 1;\\n        _updateOwnerAndClearApprovals(tokenId, 0, to);\\n        _balances[to] += 1;\\n\\n        emit Transfer(from, to, tokenId);\\n        emit NestTransfer(from, to, parentId, 0, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n        _afterNestedTokenTransfer(from, to, parentId, 0, tokenId, data);\\n    }\\n\\n    /**\\n     * @notice Used to transfer a token into another token.\\n     * @dev Attempting to nest a token into `0x0` address will result in reverted transaction.\\n     * @dev Attempting to nest a token into itself will result in reverted transaction.\\n     * @param from Address of the account currently owning the given token\\n     * @param to Address of the receiving token's collection smart contract\\n     * @param tokenId ID of the token to transfer\\n     * @param destinationId ID of the token receiving the given token\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function _nestTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 destinationId,\\n        bytes memory data\\n    ) internal virtual {\\n        (address immediateOwner, uint256 parentId, ) = directOwnerOf(tokenId);\\n        if (immediateOwner != from) revert ERC721TransferFromIncorrectOwner();\\n        if (to == address(this) && tokenId == destinationId)\\n            revert RMRKNestableTransferToSelf();\\n\\n        _checkDestination(to);\\n        _checkForInheritanceLoop(tokenId, to, destinationId);\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n        _beforeNestedTokenTransfer(\\n            immediateOwner,\\n            to,\\n            parentId,\\n            destinationId,\\n            tokenId,\\n            data\\n        );\\n        _balances[from] -= 1;\\n        _updateOwnerAndClearApprovals(tokenId, destinationId, to);\\n        _balances[to] += 1;\\n\\n        // Sending to NFT:\\n        _sendToNFT(immediateOwner, to, parentId, destinationId, tokenId, data);\\n    }\\n\\n    /**\\n     * @notice Used to send a token to another token.\\n     * @dev If the token being sent is currently owned by an externally owned account, the `parentId` should equal `0`.\\n     * @dev Emits {Transfer} event.\\n     * @dev Emits {NestTransfer} event.\\n     * @param from Address from which the token is being sent\\n     * @param to Address of the collection smart contract of the token to receive the given token\\n     * @param parentId ID of the current parent token of the token being sent\\n     * @param destinationId ID of the tokento receive the token being sent\\n     * @param tokenId ID of the token being sent\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function _sendToNFT(\\n        address from,\\n        address to,\\n        uint256 parentId,\\n        uint256 destinationId,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private {\\n        IERC7401 destContract = IERC7401(to);\\n        destContract.addChild(destinationId, tokenId, data);\\n\\n        emit Transfer(from, to, tokenId);\\n        emit NestTransfer(from, to, parentId, destinationId, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n        _afterNestedTokenTransfer(\\n            from,\\n            to,\\n            parentId,\\n            destinationId,\\n            tokenId,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @notice Used to check if nesting a given token into a specified token would create an inheritance loop.\\n     * @dev If a loop would occur, the tokens would be unmanageable, so the execution is reverted if one is detected.\\n     * @dev The check for inheritance loop is bounded to guard against too much gas being consumed.\\n     * @param currentId ID of the token that would be nested\\n     * @param targetContract Address of the collection smart contract of the token into which the given token would be\\n     *  nested\\n     * @param targetId ID of the token into which the given token would be nested\\n     */\\n    function _checkForInheritanceLoop(\\n        uint256 currentId,\\n        address targetContract,\\n        uint256 targetId\\n    ) private view {\\n        for (uint256 i; i < _MAX_LEVELS_TO_CHECK_FOR_INHERITANCE_LOOP; ) {\\n            (\\n                address nextOwner,\\n                uint256 nextOwnerTokenId,\\n                bool isNft\\n            ) = IERC7401(targetContract).directOwnerOf(targetId);\\n            // If there's a final address, we're good. There's no loop.\\n            if (!isNft) {\\n                return;\\n            }\\n            // Ff the current nft is an ancestor at some point, there is an inheritance loop\\n            if (nextOwner == address(this) && nextOwnerTokenId == currentId) {\\n                revert RMRKNestableTransferToDescendant();\\n            }\\n            // We reuse the parameters to save some contract size\\n            targetContract = nextOwner;\\n            targetId = nextOwnerTokenId;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        revert RMRKNestableTooDeep();\\n    }\\n\\n    ////////////////////////////////////////\\n    //              MINTING\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @notice Used to safely mint the token to the specified address while passing the additional data to contract\\n     *  recipients.\\n     * @param to Address to which to mint the token\\n     * @param tokenId ID of the token to mint\\n     * @param data Additional data to send with the tokens\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId, data);\\n        if (!_checkOnERC721Received(address(0), to, tokenId, data))\\n            revert ERC721TransferToNonReceiverImplementer();\\n    }\\n\\n    /**\\n     * @notice Used to mint a specified token to a given address.\\n     * @dev WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must not exist.\\n     *  - `to` cannot be the zero address.\\n     * @dev Emits a {Transfer} event.\\n     * @dev Emits a {NestTransfer} event.\\n     * @param to Address to mint the token to\\n     * @param tokenId ID of the token to mint\\n     * @param data Additional data with no specified format, sent in call to `to`\\n     */\\n    function _mint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _innerMint(to, tokenId, 0, data);\\n\\n        emit Transfer(address(0), to, tokenId);\\n        emit NestTransfer(address(0), to, 0, 0, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n        _afterNestedTokenTransfer(address(0), to, 0, 0, tokenId, data);\\n    }\\n\\n    /**\\n     * @notice Used to mint a child token to a given parent token.\\n     * @param to Address of the collection smart contract of the token into which to mint the child token\\n     * @param tokenId ID of the token to mint\\n     * @param destinationId ID of the token into which to mint the new child token\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function _nestMint(\\n        address to,\\n        uint256 tokenId,\\n        uint256 destinationId,\\n        bytes memory data\\n    ) internal virtual {\\n        _checkDestination(to);\\n        _innerMint(to, tokenId, destinationId, data);\\n        _sendToNFT(address(0), to, 0, destinationId, tokenId, data);\\n    }\\n\\n    /**\\n     * @notice Used to mint a child token into a given parent token.\\n     * @dev Requirements:\\n     *\\n     *  - `to` cannot be the zero address.\\n     *  - `tokenId` must not exist.\\n     *  - `tokenId` must not be `0`.\\n     * @param to Address of the collection smart contract of the token into which to mint the child token\\n     * @param tokenId ID of the token to mint\\n     * @param destinationId ID of the token into which to mint the new token\\n     * @param data Additional data with no specified format, sent in call to `to`\\n     */\\n    function _innerMint(\\n        address to,\\n        uint256 tokenId,\\n        uint256 destinationId,\\n        bytes memory data\\n    ) private {\\n        if (to == address(0)) revert ERC721MintToTheZeroAddress();\\n        if (_exists(tokenId)) revert ERC721TokenAlreadyMinted();\\n        if (tokenId == uint256(0)) revert RMRKIdZeroForbidden();\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n        _beforeNestedTokenTransfer(\\n            address(0),\\n            to,\\n            0,\\n            destinationId,\\n            tokenId,\\n            data\\n        );\\n\\n        _balances[to] += 1;\\n        _RMRKOwners[tokenId] = DirectOwner({\\n            ownerAddress: to,\\n            tokenId: destinationId\\n        });\\n    }\\n\\n    ////////////////////////////////////////\\n    //              Ownership\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function ownerOf(\\n        uint256 tokenId\\n    ) public view virtual override(IERC7401, IERC721) returns (address owner_) {\\n        (address owner, uint256 ownerTokenId, bool isNft) = directOwnerOf(\\n            tokenId\\n        );\\n        if (isNft) {\\n            owner = IERC7401(owner).ownerOf(ownerTokenId);\\n        }\\n        owner_ = owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function directOwnerOf(\\n        uint256 tokenId\\n    )\\n        public\\n        view\\n        virtual\\n        returns (address owner_, uint256 parentId, bool isNFT)\\n    {\\n        DirectOwner memory owner = _RMRKOwners[tokenId];\\n        if (owner.ownerAddress == address(0)) revert ERC721InvalidTokenId();\\n\\n        owner_ = owner.ownerAddress;\\n        parentId = owner.tokenId;\\n        isNFT = owner.tokenId != 0;\\n    }\\n\\n    ////////////////////////////////////////\\n    //              BURNING\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @notice Used to burn a given token.\\n     * @dev In case the token has any child tokens, the execution will be reverted.\\n     * @param tokenId ID of the token to burn\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        burn(tokenId, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function burn(\\n        uint256 tokenId,\\n        uint256 maxChildrenBurns\\n    )\\n        public\\n        virtual\\n        onlyApprovedOrDirectOwner(tokenId)\\n        returns (uint256 burnedChildren)\\n    {\\n        burnedChildren = _burn(tokenId, maxChildrenBurns);\\n    }\\n\\n    /**\\n     * @notice Used to burn a token.\\n     * @dev When a token is burned, its children are recursively burned as well.\\n     * @dev The approvals are cleared when the token is burned.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @dev Emits a {Transfer} event.\\n     * @dev Emits a {NestTransfer} event.\\n     * @param tokenId ID of the token to burn\\n     * @param maxChildrenBurns Maximum children to recursively burn\\n     * @return The number of recursive burns it took to burn all of the children\\n     */\\n    function _burn(\\n        uint256 tokenId,\\n        uint256 maxChildrenBurns\\n    ) internal virtual returns (uint256) {\\n        (address immediateOwner, uint256 parentId, ) = directOwnerOf(tokenId);\\n        address rootOwner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(immediateOwner, address(0), tokenId);\\n        _beforeNestedTokenTransfer(\\n            immediateOwner,\\n            address(0),\\n            parentId,\\n            0,\\n            tokenId,\\n            \\\"\\\"\\n        );\\n\\n        _balances[immediateOwner] -= 1;\\n        _approve(address(0), tokenId);\\n        _cleanApprovals(tokenId);\\n\\n        Child[] memory children = childrenOf(tokenId);\\n\\n        delete _activeChildren[tokenId];\\n        delete _pendingChildren[tokenId];\\n        delete _tokenApprovals[tokenId][rootOwner];\\n\\n        uint256 pendingRecursiveBurns;\\n        uint256 totalChildBurns;\\n\\n        uint256 length = children.length; //gas savings\\n        for (uint256 i; i < length; ) {\\n            if (totalChildBurns >= maxChildrenBurns)\\n                revert RMRKMaxRecursiveBurnsReached(\\n                    children[i].contractAddress,\\n                    children[i].tokenId\\n                );\\n            delete _childIsInActive[children[i].contractAddress][\\n                children[i].tokenId\\n            ];\\n            unchecked {\\n                // At this point we know pendingRecursiveBurns must be at least 1\\n                pendingRecursiveBurns = maxChildrenBurns - totalChildBurns;\\n            }\\n            // We substract one to the next level to count for the token being burned, then add it again on returns\\n            // This is to allow the behavior of 0 recursive burns meaning only the current token is deleted.\\n            totalChildBurns +=\\n                IERC7401(children[i].contractAddress).burn(\\n                    children[i].tokenId,\\n                    pendingRecursiveBurns - 1\\n                ) +\\n                1;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // Can't remove before burning child since child will call back to get root owner\\n        delete _RMRKOwners[tokenId];\\n\\n        emit Transfer(immediateOwner, address(0), tokenId);\\n        emit NestTransfer(immediateOwner, address(0), parentId, 0, tokenId);\\n\\n        _afterTokenTransfer(immediateOwner, address(0), tokenId);\\n        _afterNestedTokenTransfer(\\n            immediateOwner,\\n            address(0),\\n            parentId,\\n            0,\\n            tokenId,\\n            \\\"\\\"\\n        );\\n\\n        return totalChildBurns;\\n    }\\n\\n    ////////////////////////////////////////\\n    //              APPROVALS\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @notice Used to grant a one-time approval to manage one's token.\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * @dev The approval is cleared when the token is transferred.\\n     * @dev Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     * @dev Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     * @dev Emits an {Approval} event.\\n     * @param to Address receiving the approval\\n     * @param tokenId ID of the token for which the approval is being granted\\n     */\\n    function approve(address to, uint256 tokenId) public virtual {\\n        address owner = ownerOf(tokenId);\\n        if (to == owner) revert ERC721ApprovalToCurrentOwner();\\n\\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender()))\\n            revert ERC721ApproveCallerIsNotOwnerNorApprovedForAll();\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @notice Used to retrieve the account approved to manage given token.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @param tokenId ID of the token to check for approval\\n     * @return approved Address of the account approved to manage the token\\n     */\\n    function getApproved(\\n        uint256 tokenId\\n    ) public view virtual returns (address approved) {\\n        _requireMinted(tokenId);\\n\\n        approved = _tokenApprovals[tokenId][ownerOf(tokenId)];\\n    }\\n\\n    /**\\n     * @notice Used to approve or remove `operator` as an operator for the caller.\\n     * @dev Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     * @dev Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     * @dev Emits an {ApprovalForAll} event.\\n     * @param operator Address of the operator being managed\\n     * @param approved A boolean value signifying whether the approval is being granted (`true`) or (`revoked`)\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        if (_msgSender() == operator) revert ERC721ApproveToCaller();\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @notice Used to check if the given address is allowed to manage the tokens of the specified address.\\n     * @param owner Address of the owner of the tokens\\n     * @param operator Address being checked for approval\\n     * @return isApproved A boolean value signifying whether the *operator* is allowed to manage the tokens of the *owner* (`true`)\\n     *  or not (`false`)\\n     */\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) public view virtual returns (bool isApproved) {\\n        isApproved = _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @notice Used to grant an approval to manage a given token.\\n     * @dev Emits an {Approval} event.\\n     * @param to Address to which the approval is being granted\\n     * @param tokenId ID of the token for which the approval is being granted\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n        _tokenApprovals[tokenId][owner] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @notice Used to update the owner of the token and clear the approvals associated with the previous owner.\\n     * @dev The `destinationId` should equal `0` if the new owner is an externally owned account.\\n     * @param tokenId ID of the token being updated\\n     * @param destinationId ID of the token to receive the given token\\n     * @param to Address of account to receive the token\\n     */\\n    function _updateOwnerAndClearApprovals(\\n        uint256 tokenId,\\n        uint256 destinationId,\\n        address to\\n    ) internal {\\n        _RMRKOwners[tokenId] = DirectOwner({\\n            ownerAddress: to,\\n            tokenId: destinationId\\n        });\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n        _cleanApprovals(tokenId);\\n    }\\n\\n    /**\\n     * @notice Used to remove approvals for the current owner of the given token.\\n     * @param tokenId ID of the token to clear the approvals for\\n     */\\n    function _cleanApprovals(uint256 tokenId) internal virtual {}\\n\\n    ////////////////////////////////////////\\n    //              UTILS\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @notice Used to check whether the given account is allowed to manage the given token.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @param spender Address that is being checked for approval\\n     * @param tokenId ID of the token being checked\\n     * @return A boolean value indicating whether the `spender` is approved to manage the given token\\n     */\\n    function _isApprovedOrOwner(\\n        address spender,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool) {\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            isApprovedForAll(owner, spender) ||\\n            getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @notice Used to check whether the account is approved to manage the token or its direct owner.\\n     * @param spender Address that is being checked for approval or direct ownership\\n     * @param tokenId ID of the token being checked\\n     * @return A boolean value indicating whether the `spender` is approved to manage the given token or its\\n     *  direct owner\\n     */\\n    function _isApprovedOrDirectOwner(\\n        address spender,\\n        uint256 tokenId\\n    ) internal view virtual returns (bool) {\\n        (address owner, uint256 parentId, ) = directOwnerOf(tokenId);\\n        // When the parent is an NFT, only it can do operations\\n        if (parentId != 0) {\\n            return (spender == owner);\\n        }\\n        // Otherwise, the owner or approved address can\\n        return (spender == owner ||\\n            isApprovedForAll(owner, spender) ||\\n            getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @notice Used to enforce that the given token has been minted.\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     * @dev The validation checks whether the owner of a given token is a `0x0` address and considers it not minted if\\n     *  it is. This means that both tokens that haven't been minted yet as well as the ones that have already been\\n     *  burned will cause the transaction to be reverted.\\n     * @param tokenId ID of the token to check\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        if (!_exists(tokenId)) revert ERC721InvalidTokenId();\\n    }\\n\\n    /**\\n     * @notice Used to check whether the given token exists.\\n     * @dev Tokens start existing when they are minted (`_mint`) and stop existing when they are burned (`_burn`).\\n     * @param tokenId ID of the token being checked\\n     * @return exists A boolean value signifying whether the token exists\\n     */\\n    function _exists(\\n        uint256 tokenId\\n    ) internal view virtual returns (bool exists) {\\n        exists = _RMRKOwners[tokenId].ownerAddress != address(0);\\n    }\\n\\n    /**\\n     * @notice Used to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * @dev The call is not executed if the target address is not a contract.\\n     * @param from Address representing the previous owner of the given token\\n     * @param to Yarget address that will receive the tokens\\n     * @param tokenId ID of the token to be transferred\\n     * @param data Optional data to send along with the call\\n     * @return valid Boolean value signifying whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool valid) {\\n        if (to.code.length != 0) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    _msgSender(),\\n                    from,\\n                    tokenId,\\n                    data\\n                )\\n            returns (bytes4 retval) {\\n                valid = retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == uint256(0)) {\\n                    revert ERC721TransferToNonReceiverImplementer();\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            valid = true;\\n        }\\n    }\\n\\n    ////////////////////////////////////////\\n    //      CHILD MANAGEMENT PUBLIC\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function addChild(\\n        uint256 parentId,\\n        uint256 childId,\\n        bytes memory data\\n    ) public virtual {\\n        _requireMinted(parentId);\\n\\n        address childAddress = _msgSender();\\n        if (childAddress.code.length == 0) revert RMRKIsNotContract();\\n\\n        Child memory child = Child({\\n            contractAddress: childAddress,\\n            tokenId: childId\\n        });\\n\\n        _beforeAddChild(parentId, childAddress, childId, data);\\n\\n        uint256 length = pendingChildrenOf(parentId).length;\\n\\n        if (length < 128) {\\n            _pendingChildren[parentId].push(child);\\n        } else {\\n            revert RMRKMaxPendingChildrenReached();\\n        }\\n\\n        // Previous length matches the index for the new child\\n        emit ChildProposed(parentId, length, childAddress, childId);\\n\\n        _afterAddChild(parentId, childAddress, childId, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function acceptChild(\\n        uint256 parentId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId\\n    ) public virtual onlyApprovedOrOwner(parentId) {\\n        _acceptChild(parentId, childIndex, childAddress, childId);\\n    }\\n\\n    /**\\n     * @notice Used to accept a pending child token for a given parent token.\\n     * @dev This moves the child token from parent token's pending child tokens array into the active child tokens\\n     *  array.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist\\n     *  - `index` must be in range of the pending children array\\n     * @dev Emits ***ChildAccepted*** event.\\n     * @param parentId ID of the parent token for which the child token is being accepted\\n     * @param childIndex Index of a child tokem in the given parent's pending children array\\n     * @param childAddress Address of the collection smart contract of the child token expected to be located at the\\n     *  specified index of the given parent token's pending children array\\n     * @param childId ID of the child token expected to be located at the specified index of the given parent token's\\n     *  pending children array\\n     */\\n    function _acceptChild(\\n        uint256 parentId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId\\n    ) internal virtual {\\n        Child memory child = pendingChildOf(parentId, childIndex);\\n        _checkExpectedChild(child, childAddress, childId);\\n        if (_childIsInActive[childAddress][childId] != 0)\\n            revert RMRKChildAlreadyExists();\\n\\n        _beforeAcceptChild(parentId, childIndex, childAddress, childId);\\n\\n        // Remove from pending:\\n        _removeChildByIndex(_pendingChildren[parentId], childIndex);\\n\\n        // Add to active:\\n        _activeChildren[parentId].push(child);\\n        _childIsInActive[childAddress][childId] = 1; // We use 1 as true\\n\\n        emit ChildAccepted(parentId, childIndex, childAddress, childId);\\n\\n        _afterAcceptChild(parentId, childIndex, childAddress, childId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function rejectAllChildren(\\n        uint256 tokenId,\\n        uint256 maxRejections\\n    ) public virtual onlyApprovedOrOwner(tokenId) {\\n        _rejectAllChildren(tokenId, maxRejections);\\n    }\\n\\n    /**\\n     * @notice Used to reject all pending children of a given parent token.\\n     * @dev Removes the children from the pending array mapping.\\n     * @dev This does not update the ownership storage data on children. If necessary, ownership can be reclaimed by the\\n     *  rootOwner of the previous parent.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist\\n     * @dev Emits ***AllChildrenRejected*** event.\\n     * @param tokenId ID of the parent token for which to reject all of the pending tokens.\\n     * @param maxRejections Maximum number of expected children to reject, used to prevent from rejecting children which\\n     *  arrive just before this operation.\\n     */\\n    function _rejectAllChildren(\\n        uint256 tokenId,\\n        uint256 maxRejections\\n    ) internal virtual {\\n        if (_pendingChildren[tokenId].length > maxRejections)\\n            revert RMRKUnexpectedNumberOfChildren();\\n\\n        _beforeRejectAllChildren(tokenId);\\n        delete _pendingChildren[tokenId];\\n        emit AllChildrenRejected(tokenId);\\n        _afterRejectAllChildren(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function transferChild(\\n        uint256 tokenId,\\n        address to,\\n        uint256 destinationId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId,\\n        bool isPending,\\n        bytes memory data\\n    ) public virtual onlyApprovedOrOwner(tokenId) {\\n        _transferChild(\\n            tokenId,\\n            to,\\n            destinationId,\\n            childIndex,\\n            childAddress,\\n            childId,\\n            isPending,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @notice Used to transfer a child token from a given parent token.\\n     * @dev When transferring a child token, the owner of the token is set to `to`, or is not updated in the event of\\n     *  `to` being the `0x0` address.\\n     * @dev Requirements:\\n     *\\n     *  - `tokenId` must exist.\\n     * @dev Emits {ChildTransferred} event.\\n     * @param tokenId ID of the parent token from which the child token is being transferred\\n     * @param to Address to which to transfer the token to\\n     * @param destinationId ID of the token to receive this child token (MUST be 0 if the destination is not a token)\\n     * @param childIndex Index of a token we are transferring, in the array it belongs to (can be either active array or\\n     *  pending array)\\n     * @param childAddress Address of the child token's collection smart contract.\\n     * @param childId ID of the child token in its own collection smart contract.\\n     * @param isPending A boolean value indicating whether the child token being transferred is in the pending array of\\n     *  the parent token (`true`) or in the active array (`false`)\\n     * @param data Additional data with no specified format, sent in call to `_to`\\n     */\\n    function _transferChild(\\n        uint256 tokenId,\\n        address to,\\n        uint256 destinationId, // newParentId\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId,\\n        bool isPending,\\n        bytes memory data\\n    ) internal virtual {\\n        Child memory child;\\n        if (isPending) {\\n            child = pendingChildOf(tokenId, childIndex);\\n        } else {\\n            child = childOf(tokenId, childIndex);\\n        }\\n        _checkExpectedChild(child, childAddress, childId);\\n\\n        _beforeTransferChild(\\n            tokenId,\\n            childIndex,\\n            childAddress,\\n            childId,\\n            isPending,\\n            data\\n        );\\n\\n        if (isPending) {\\n            _removeChildByIndex(_pendingChildren[tokenId], childIndex);\\n        } else {\\n            delete _childIsInActive[childAddress][childId];\\n            _removeChildByIndex(_activeChildren[tokenId], childIndex);\\n        }\\n\\n        if (to != address(0)) {\\n            if (destinationId == uint256(0)) {\\n                IERC721(childAddress).safeTransferFrom(\\n                    address(this),\\n                    to,\\n                    childId,\\n                    data\\n                );\\n            } else {\\n                // Destination is an NFT\\n                IERC7401(child.contractAddress).nestTransferFrom(\\n                    address(this),\\n                    to,\\n                    child.tokenId,\\n                    destinationId,\\n                    data\\n                );\\n            }\\n        }\\n\\n        emit ChildTransferred(\\n            tokenId,\\n            childIndex,\\n            childAddress,\\n            childId,\\n            isPending,\\n            to == address(0)\\n        );\\n        _afterTransferChild(\\n            tokenId,\\n            childIndex,\\n            childAddress,\\n            childId,\\n            isPending,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @notice Used to verify that the child being accessed is the intended child.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @param child A Child struct of a child being accessed\\n     * @param expectedAddress The address expected to be the one of the child\\n     * @param expectedId The token ID expected to be the one of the child\\n     */\\n    function _checkExpectedChild(\\n        Child memory child,\\n        address expectedAddress,\\n        uint256 expectedId\\n    ) private pure {\\n        if (\\n            expectedAddress != child.contractAddress ||\\n            expectedId != child.tokenId\\n        ) revert RMRKUnexpectedChildId();\\n    }\\n\\n    ////////////////////////////////////////\\n    //      CHILD MANAGEMENT GETTERS\\n    ////////////////////////////////////////\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n\\n    function childrenOf(\\n        uint256 parentId\\n    ) public view virtual returns (Child[] memory children) {\\n        children = _activeChildren[parentId];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n\\n    function pendingChildrenOf(\\n        uint256 parentId\\n    ) public view virtual returns (Child[] memory children) {\\n        children = _pendingChildren[parentId];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function childOf(\\n        uint256 parentId,\\n        uint256 index\\n    ) public view virtual returns (Child memory child) {\\n        if (childrenOf(parentId).length <= index)\\n            revert RMRKChildIndexOutOfRange();\\n        child = _activeChildren[parentId][index];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7401\\n     */\\n    function pendingChildOf(\\n        uint256 parentId,\\n        uint256 index\\n    ) public view virtual returns (Child memory child) {\\n        if (pendingChildrenOf(parentId).length <= index)\\n            revert RMRKPendingChildIndexOutOfRange();\\n        child = _pendingChildren[parentId][index];\\n    }\\n\\n    /**\\n     * @notice Checks the destination is valid for a Nest Transfer/Mint.\\n     * @dev The destination must be a contract that implements the IERC7401 interface.\\n     * @param to Address of the destination\\n     */\\n    function _checkDestination(address to) internal view {\\n        // Checking if it is a contract before calling it seems redundant, but otherwise it would revert with no error\\n        if (to.code.length == 0) revert RMRKIsNotContract();\\n        if (!IERC165(to).supportsInterface(type(IERC7401).interfaceId))\\n            revert RMRKNestableTransferToNonRMRKNestableImplementer();\\n    }\\n\\n    // HOOKS\\n\\n    /**\\n     * @notice Hook that is called before any token transfer. This includes minting and burning.\\n     * @dev Calling conditions:\\n     *\\n     *  - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be transferred to `to`.\\n     *  - When `from` is zero, `tokenId` will be minted to `to`.\\n     *  - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     *  - `from` and `to` are never zero at the same time.\\n     *\\n     *  To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param from Address from which the token is being transferred\\n     * @param to Address to which the token is being transferred\\n     * @param tokenId ID of the token being transferred\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after any transfer of tokens. This includes minting and burning.\\n     * @dev Calling conditions:\\n     *\\n     *  - When `from` and `to` are both non-zero.\\n     *  - `from` and `to` are never zero at the same time.\\n     *\\n     *  To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param from Address from which the token has been transferred\\n     * @param to Address to which the token has been transferred\\n     * @param tokenId ID of the token that has been transferred\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before nested token transfer.\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param from Address from which the token is being transferred\\n     * @param to Address to which the token is being transferred\\n     * @param fromTokenId ID of the token from which the given token is being transferred\\n     * @param toTokenId ID of the token to which the given token is being transferred\\n     * @param tokenId ID of the token being transferred\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function _beforeNestedTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 fromTokenId,\\n        uint256 toTokenId,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after nested token transfer.\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param from Address from which the token was transferred\\n     * @param to Address to which the token was transferred\\n     * @param fromTokenId ID of the token from which the given token was transferred\\n     * @param toTokenId ID of the token to which the given token was transferred\\n     * @param tokenId ID of the token that was transferred\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function _afterNestedTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 fromTokenId,\\n        uint256 toTokenId,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before a child is added to the pending tokens array of a given token.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param tokenId ID of the token that will receive a new pending child token\\n     * @param childAddress Address of the collection smart contract of the child token expected to be located at the\\n     *  specified index of the given parent token's pending children array\\n     * @param childId ID of the child token expected to be located at the specified index of the given parent token's\\n     *  pending children array\\n     * @param data Additional data with no specified format\\n     */\\n    function _beforeAddChild(\\n        uint256 tokenId,\\n        address childAddress,\\n        uint256 childId,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after a child is added to the pending tokens array of a given token.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param tokenId ID of the token that has received a new pending child token\\n     * @param childAddress Address of the collection smart contract of the child token expected to be located at the\\n     *  specified index of the given parent token's pending children array\\n     * @param childId ID of the child token expected to be located at the specified index of the given parent token's\\n     *  pending children array\\n     * @param data Additional data with no specified format\\n     */\\n    function _afterAddChild(\\n        uint256 tokenId,\\n        address childAddress,\\n        uint256 childId,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before a child is accepted to the active tokens array of a given token.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param parentId ID of the token that will accept a pending child token\\n     * @param childIndex Index of the child token to accept in the given parent token's pending children array\\n     * @param childAddress Address of the collection smart contract of the child token expected to be located at the\\n     *  specified index of the given parent token's pending children array\\n     * @param childId ID of the child token expected to be located at the specified index of the given parent token's\\n     *  pending children array\\n     */\\n    function _beforeAcceptChild(\\n        uint256 parentId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after a child is accepted to the active tokens array of a given token.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param parentId ID of the token that has accepted a pending child token\\n     * @param childIndex Index of the child token that was accpeted in the given parent token's pending children array\\n     * @param childAddress Address of the collection smart contract of the child token that was expected to be located\\n     *  at the specified index of the given parent token's pending children array\\n     * @param childId ID of the child token that was expected to be located at the specified index of the given parent\\n     *  token's pending children array\\n     */\\n    function _afterAcceptChild(\\n        uint256 parentId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before a child is transferred from a given child token array of a given token.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param tokenId ID of the token that will transfer a child token\\n     * @param childIndex Index of the child token that will be transferred from the given parent token's children array\\n     * @param childAddress Address of the collection smart contract of the child token that is expected to be located\\n     *  at the specified index of the given parent token's children array\\n     * @param childId ID of the child token that is expected to be located at the specified index of the given parent\\n     *  token's children array\\n     * @param isPending A boolean value signifying whether the child token is being transferred from the pending child\\n     *  tokens array (`true`) or from the active child tokens array (`false`)\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function _beforeTransferChild(\\n        uint256 tokenId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId,\\n        bool isPending,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after a child is transferred from a given child token array of a given token.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param tokenId ID of the token that has transferred a child token\\n     * @param childIndex Index of the child token that was transferred from the given parent token's children array\\n     * @param childAddress Address of the collection smart contract of the child token that was expected to be located\\n     *  at the specified index of the given parent token's children array\\n     * @param childId ID of the child token that was expected to be located at the specified index of the given parent\\n     *  token's children array\\n     * @param isPending A boolean value signifying whether the child token was transferred from the pending child tokens\\n     *  array (`true`) or from the active child tokens array (`false`)\\n     * @param data Additional data with no specified format, sent in the addChild call\\n     */\\n    function _afterTransferChild(\\n        uint256 tokenId,\\n        uint256 childIndex,\\n        address childAddress,\\n        uint256 childId,\\n        bool isPending,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called before a pending child tokens array of a given token is cleared.\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param tokenId ID of the token that will reject all of the pending child tokens\\n     */\\n    function _beforeRejectAllChildren(uint256 tokenId) internal virtual {}\\n\\n    /**\\n     * @notice Hook that is called after a pending child tokens array of a given token is cleared.\\n     * @dev To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     * @param tokenId ID of the token that has rejected all of the pending child tokens\\n     */\\n    function _afterRejectAllChildren(uint256 tokenId) internal virtual {}\\n\\n    // HELPERS\\n\\n    /**\\n     * @notice Used to remove a specified child token form an array using its index within said array.\\n     * @dev The caller must ensure that the length of the array is valid compared to the index passed.\\n     * @dev The Child struct consists of the following values:\\n     *  [\\n     *      tokenId,\\n     *      contractAddress\\n     *  ]\\n     * @param array An array od Child struct containing info about the child tokens in a given child tokens array\\n     * @param index An index of the child token to remove in the accompanying array\\n     */\\n    function _removeChildByIndex(Child[] storage array, uint256 index) private {\\n        array[index] = array[array.length - 1];\\n        array.pop();\\n    }\\n}\\n\",\"keccak256\":\"0x394d6475398e2396d961556241ba850b271854bb7a663b2be15c778d9e37cf24\",\"license\":\"Apache-2.0\"},\"contracts/RMRKSoulbound.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.21;\\n\\nimport {IERC6454} from \\\"./IERC6454.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"./RMRKErrors.sol\\\";\\n\\n/**\\n * @title RMRKSoulbound\\n * @author RMRK team\\n * @notice Smart contract of the RMRK Soulbound module.\\n */\\nabstract contract RMRKSoulbound is IERC6454 {\\n    /**\\n     * @notice Hook that is called before any token transfer. This includes minting and burning.\\n     * @dev This is a hook ensuring that all transfers of tokens are reverted if the token is soulbound.\\n     * @dev The only exception of transfers being allowed is when the tokens are minted or when they are being burned.\\n     * @param from Address from which the token is originating (current owner of the token)\\n     * @param to Address to which the token would be sent\\n     * @param tokenId ID of the token that would be transferred\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        if (!isTransferable(tokenId, from, to))\\n            revert RMRKCannotTransferSoulbound();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6454\\n     */\\n    function isTransferable(\\n        uint256,\\n        address from,\\n        address to\\n    ) public view virtual returns (bool isTransferable_) {\\n        isTransferable_ = ((from == address(0) || // Exclude minting\\n            to == address(0)) && from != to); // Exclude Burning // Besides the obvious transfer to self, if both are address 0 (general transferability check), it returns false\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual returns (bool) {\\n        return interfaceId == type(IERC6454).interfaceId;\\n    }\\n}\",\"keccak256\":\"0xe09e69783740a15fdf9b99c872b923f1f62638f7caae450487ceef3f5b35c384\",\"license\":\"Apache-2.0\"},\"contracts/RMRKSoulboundPerToken.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC6454} from \\\"./IERC6454.sol\\\";\\nimport {RMRKSoulbound} from \\\"./RMRKSoulbound.sol\\\";\\n\\n/**\\n * @title RMRKSoulboundPerToken\\n * @author RMRK team\\n * @notice Smart contract of the RMRK Soulbound module where the transfers are permitted or prohibited\\u00a0on a per-token basis.\\n */\\nabstract contract RMRKSoulboundPerToken is RMRKSoulbound {\\n    /**\\n     * @notice Emitted when a token's soulbound state changes.\\n     * @param tokenId ID of the token\\n     * @param state A boolean value signifying whether the token became soulbound (`true`) or transferrable (`false`)\\n     */\\n    event Soulbound(uint256 indexed tokenId, bool state);\\n\\n    // Mapping of token ID to soulbound state\\n    mapping(uint256 => bool) private _isSoulbound;\\n\\n    /**\\n     * @notice Sets the soulbound state of a token.\\n     * @dev Custom access control has to be implemented when exposing this method in a smart contract that utillizes it.\\n     * @param tokenId ID of the token\\n     * @param state New soulbound state\\n     */\\n    function _setSoulbound(uint256 tokenId, bool state) internal virtual {\\n        _isSoulbound[tokenId] = state;\\n        emit Soulbound(tokenId, state);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC6454\\n     */\\n    function isTransferable(\\n        uint256 tokenId,\\n        address from,\\n        address to\\n    ) public view virtual override returns (bool isTransferable_) {\\n        isTransferable_ = (from == address(0) || // Exclude minting\\n            to == address(0) || // Exclude Burning\\n            !_isSoulbound[tokenId]);\\n    }\\n}\",\"keccak256\":\"0x865c00b90f55b9f8acd2d57aaab886018c6c1c7f5a72bd4b4b6ecaa2a537b769\",\"license\":\"Apache-2.0\"},\"contracts/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.21;\\n\\nerror RentrantCall();\\n\\n/**\\n * @title ReentrancyGuard\\n * @notice Smart contract used to guard against potential reentrancy exploits.\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @notice Initializes the ReentrancyGuard with the `_status` of `_NOT_ENTERED`.\\n     */\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @notice Used to ensure that the function it is applied to cannot be reentered.\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantIn();\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @notice Used to ensure that the current call is not a reentrant call.\\n     * @dev If reentrant call is detected, the execution will be reverted.\\n     */\\n    function _nonReentrantIn() private {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        if (_status == _ENTERED) revert RentrantCall();\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x14a91bf4e2ca7a5423b903c551aedb08c98f9d089e429998f9711286c0c17882\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040527801000000000000000100000000000000010000000000000001601c55601d80546001600160401b03191660011790553480156200004157600080fd5b50604080518082018252600a815269676f6f676c652e636f6d60b01b602080830191909152825180840190935260048352631cdb1bdd60e21b908301526001600055906200008f82620000a2565b6200009a81620000b4565b505062000233565b601a620000b0828262000167565b5050565b601b620000b0828262000167565b634e487b7160e01b600052604160045260246000fd5b600181811c90821680620000ed57607f821691505b6020821081036200010e57634e487b7160e01b600052602260045260246000fd5b50919050565b601f8211156200016257600081815260208120601f850160051c810160208610156200013d5750805b601f850160051c820191505b818110156200015e5782815560010162000149565b5050505b505050565b81516001600160401b03811115620001835762000183620000c2565b6200019b81620001948454620000d8565b8462000114565b602080601f831160018114620001d35760008415620001ba5750858301515b600019600386901b1c1916600185901b1785556200015e565b600085815260208120601f198616915b828110156200020457888601518255948401946001909101908401620001e3565b5085821015620002235787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b615b7380620002436000396000f3fe608060405234801561001057600080fd5b50600436106103835760003560e01c80637280281e116101de578063dc477d2f1161010f578063e7de4de4116100ad578063fb25fb7a1161007c578063fb25fb7a14610997578063fbd6060c146109d1578063fc3517c8146109e4578063ffa1ad74146109f757600080fd5b8063e7de4de4146108f7578063e97ceaa81461090a578063e985e9c51461091d578063ee1dffcf1461095957600080fd5b8063defa80c3116100e9578063defa80c314610887578063df6f556b1461089a578063e2c1167c146108d1578063e467a48f146108e457600080fd5b8063dc477d2f14610835578063dcb79d5614610861578063de8e602c1461087457600080fd5b80639806c6ec1161017c578063b390c0ab11610156578063b390c0ab146107dc578063b88d4fde146107ef578063c259a98814610802578063d297ac431461081557600080fd5b80639806c6ec14610796578063a22cb465146107b6578063a898e364146107c957600080fd5b806386a92af7116101b857806386a92af7146107535780638d4f3bf51461075b57806391a6262f14610770578063979613361461078357600080fd5b80637280281e146106425780637507e2ae146106555780638507dc281461074057600080fd5b806342842e0e116102b85780635e94354a11610256578063635490cc11610230578063635490cc146105e857806365b67eb9146105fb5780636f19951c1461060e57806370a082311461062157600080fd5b80635e94354a146105af5780635ea72f36146105c25780636352211e146105d557600080fd5b80634e60edba116102925780634e60edba1461055357806351532e5a1461057657806355bd8648146105895780635e2e32921461059c57600080fd5b806342842e0e1461050d57806342966c681461052057806344ec93441461053357600080fd5b806315dae03e1161032557806322f6da9c116102ff57806322f6da9c146104b457806323b872dd146104c75780632f32f937146104da57806338dcf74c146104fa57600080fd5b806315dae03e1461044e5780631c6443991461046357806322e6d1601461047857600080fd5b8063064c0a3a11610361578063064c0a3a146103ea578063074334fb146103fd578063081812fc14610410578063095ea7b31461043b57600080fd5b8063010a38f51461038857806301ffc9a7146103b257806305c07af6146103d5575b600080fd5b601c546001600160401b03165b6040516001600160401b0390911681526020015b60405180910390f35b6103c56103c0366004614b19565b610a18565b60405190151581526020016103a9565b6103e86103e3366004614c9e565b610a29565b005b6103e86103f8366004614d01565b610cae565b6103c561040b366004614d92565b610ccd565b61042361041e366004614de1565b610d3b565b6040516001600160a01b0390911681526020016103a9565b6103e8610449366004614dfa565b610d81565b610456610e0d565b6040516103a99190614e6c565b61046b610e9f565b6040516103a99190614ec3565b6103c5610486366004614ed6565b6001600160a01b039182166000908152600e6020908152604080832093909416825291909152205460ff1690565b6103e86104c2366004614f0f565b610f28565b6103e86104d5366004614f44565b610f43565b6104ed6104e8366004614f85565b610f68565b6040516103a99190614fa7565b6103e861050836600461504b565b610fff565b6103e861051b366004614f44565b611024565b6103e861052e366004614de1565b61103f565b610546610541366004614de1565b61104e565b6040516103a99190615067565b6105666105613660046150c7565b6110d6565b6040516103a994939291906150f3565b61046b610584366004614de1565b6111ad565b6103e8610597366004615141565b611241565b6104566105aa3660046150c7565b6113a1565b61046b6105bd366004614de1565b611490565b6103e86105d0366004614dfa565b6114f9565b6104236105e3366004614de1565b611580565b6103e86105f6366004615184565b611610565b6103e86106093660046151d3565b611725565b61054661061c366004614de1565b611730565b61063461062f36600461520f565b6117a3565b6040519081526020016103a9565b61046b610650366004614de1565b6117e8565b6106f261066336600461522c565b6040805160808082018352600080835260208084018290528385018290526060938401829052968152601387528381206001600160a01b03968716825287528381206001600160401b03958616825287528390208351918201845280548086168352600160401b9004909416958101959095526001830154918501919091526002909101549091169082015290565b6040516103a9919060006080820190506001600160401b0380845116835280602085015116602084015250604083015160408301526001600160a01b03606084015116606083015292915050565b6103e861074e366004615261565b611851565b6104566118e7565b60405163524d524b60e01b81526020016103a9565b6103c561077e36600461528f565b6118f6565b6103e8610791366004614f85565b611937565b6107a96107a43660046152d1565b61194b565b6040516103a99190615411565b6103e86107c4366004615261565b611b71565b6104ed6107d7366004614f85565b611bff565b6106346107ea366004614f85565b611c5c565b6103e86107fd366004615473565b611c72565b6103e86108103660046154de565b611c8f565b610828610823366004615503565b611ca4565b6040516103a9919061551e565b6103c5610843366004615503565b6001600160401b031660009081526018602052604090205460ff1690565b6103c561086f366004615531565b611e24565b6103e861088236600461554d565b611f4e565b6103e86108953660046155cb565b611f63565b6103956108a83660046150c7565b60009182526009602090815260408084206001600160401b039384168552909152909120541690565b6103e86108df366004615666565b611f88565b6104236108f2366004614de1565b611fdc565b6103e8610905366004614f85565b611fff565b6103e86109183660046156d0565b612013565b6103c561092b366004614ed6565b6001600160a01b03918216600090815260036020908152604080832093909416825291909152205460ff1690565b6103c561096736600461570f565b60009283526014602090815260408085206001600160a01b03909416855292815282842091845252902054151590565b6109aa6109a5366004614de1565b612029565b604080516001600160a01b03909416845260208401929092521515908201526060016103a9565b6103e86109df366004615736565b612091565b6103e86109f2366004614f0f565b6120a5565b604080518082019091526005815264191719971960d91b6020820152610456565b6000610a23826120ba565b92915050565b604080516003808252608082019092526000916020820160608036833701905050601c546040805180820190915260048152630c1e0d8d60e21b6020820152919250610a809133916001600160401b0316906120f0565b601d54600090610a9a906001600160401b03166003615799565b601d549091506000906001600160401b03165b826001600160401b0316816001600160401b03161015610b5e57610ad2858783611f88565b80848381518110610ae557610ae56157c0565b6001600160401b039092166020928302919091019091015281610b07816157d6565b601d80549194506001600160401b0390911691506000610b26836157ef565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550508080610b56906157ef565b915050610aad565b50601c54610b82906001600160401b0380821691600160c01b900416308887612182565b601c54610ba3906001600160401b0380821691600160801b90041680612229565b601c54610bc7906001600160401b0380821691600091600160801b9091041661241f565b601c8054601e805460018101825560009182527f50bb669a95c7b50b7e8a6f09454034b2b14cf2b85c730dca9a539ca82cb6e350600482040180546001600160401b0360039093166008026101000a83810219909116948316029390931790925582549091169190610c38836157ef565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050601c601081819054906101000a90046001600160401b031680929190610c82906157ef565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550505050505050565b82610cb88161265f565b610cc58686868686612689565b505050505050565b6001600160401b038083166000908152601160209081526040808320548416808452601583528184206001600160a01b038a1685529092528220549192909181169084168103610d31576000610d2c86610d26896117e8565b906127a4565b945050505b5050949350505050565b6000610d468261280d565b600082815260026020526040812090610d5e84611580565b6001600160a01b0390811682526020820192909252604001600020541692915050565b6000610d8c82611580565b9050806001600160a01b0316836001600160a01b031603610dc057604051630591db6d60e01b815260040160405180910390fd5b336001600160a01b03821614801590610de05750610dde813361092b565b155b15610dfe57604051634c12315960e11b815260040160405180910390fd5b610e088383612845565b505050565b6060601b8054610e1c90615815565b80601f0160208091040260200160405190810160405280929190818152602001828054610e4890615815565b8015610e955780601f10610e6a57610100808354040283529160200191610e95565b820191906000526020600020905b815481529060010190602001808311610e7857829003601f168201915b5050505050905090565b6060601e805480602002602001604051908101604052809291908181526020018280548015610e9557602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b031681526020019060080190602082600701049283019260010382029150808411610edc5790505050505050905090565b82610f32816128be565b610f3d8484846128e5565b50505050565b80610f4d8161265f565b610f3d84848460405180602001604052806000815250612954565b604080518082019091526000808252602082015281610f8684611730565b5111610fa55760405163653e642560e11b815260040160405180910390fd5b6000838152600560205260409020805483908110610fc557610fc56157c0565b60009182526020918290206040805180820190915260029092020180548252600101546001600160a01b0316918101919091529392505050565b805161100a816128be565b611012612ac1565b61101b82612aeb565b50506001600055565b610e0883838360405180602001604052806000815250611c72565b61104a816000611c5c565b5050565b606060066000838152602001908152602001600020805480602002602001604051908101604052809291908181526020016000905b828210156110cb5760008481526020908190206040805180820190915260028502909101805482526001908101546001600160a01b0316828401529083529092019101611083565b505050509050919050565b606060008060606110e786866113a1565b6001600160401b03808716600090815260116020908152604080832054601083528184205460128452938290208054835181860281018601909452808452969a50941697506001600160a01b03909216955090929083018282801561119d57602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b03168152602001906008019060208260070104928301926001038202915080841161115a5790505b5050505050905092959194509250565b6000818152600b602090815260409182902080548351818402810184019094528084526060939283018282801561123557602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b0316815260200190600801906020826007010492830192600103820291508084116111f25790505b50505050509050919050565b601c546040805180820190915260048152630c1e0d8d60e21b60208201526060916112779133916001600160401b0316906120f0565b601c5461129a906001600160401b0380821691600160c01b900416308585612182565b601c546112bb906001600160401b0380821691600160801b90041680612229565b601c546112df906001600160401b0380821691600091600160801b9091041661241f565b601c546112f69084906001600160401b0316612e60565b601c54611314906001600160401b0380861691600091309116612013565b601c80546001600160401b031690600061132d836157ef565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050601c601081819054906101000a90046001600160401b031680929190611377906157ef565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050505050565b6000828152600d602090815260408083206001600160401b038516845290915290205460609060ff166113e757604051631b9928fd60e31b815260040160405180910390fd5b6001600160401b0382166000908152600860205260409020805461140a90615815565b80601f016020809104026020016040519081016040528092919081815260200182805461143690615815565b80156114835780601f1061145857610100808354040283529160200191611483565b820191906000526020600020905b81548152906001019060200180831161146657829003601f168201915b5050505050905092915050565b6000818152600c602090815260409182902080548351818402810184019094528084526060939283018282801561123557600091825260209182902080546001600160401b031684529082028301929091600891018084116111f2575094979650505050505050565b600061150482611580565b9050806001600160a01b0316836001600160a01b031603611538576040516375f45abd60e01b815260040160405180910390fd5b336001600160a01b0382161480159061155857506115568133610486565b155b15611576576040516357a2e94960e11b815260040160405180910390fd5b610e088383612edd565b60008060008061158f85612029565b9250925092508015611607576040516331a9108f60e11b8152600481018390526001600160a01b03841690636352211e90602401602060405180830381865afa1580156115e0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611604919061584f565b92505b50909392505050565b6116198361280d565b33803b60000361163c5760405163b9d3114760e01b815260040160405180910390fd5b604080518082019091528381526001600160a01b038216602082015260006116638661104e565b51905060808110156116c2576000868152600660209081526040822080546001808201835591845292829020855160029094020192835590840151910180546001600160a01b0319166001600160a01b039092169190911790556116db565b60405163a53c8c0560e01b815260040160405180910390fd5b84836001600160a01b0316877fe65085e689b77b126ba0bac3b079aa8288f19f4d5445af11c76003f8ab3075dd8460405161171891815260200190565b60405180910390a4610cc5565b610e08838383612f56565b60008181526005602090815260408083208054825181850281018501909352808352606094929391929091840182156110cb5760008481526020908190206040805180820190915260028502909101805482526001908101546001600160a01b0316828401529083529092019101611083565b60006001600160a01b0382166117cc57604051633bb9143360e11b815260040160405180910390fd5b506001600160a01b031660009081526001602052604090205490565b6000818152600a602090815260409182902080548351818402810184019094528084526060939283018282801561123557600091825260209182902080546001600160401b031684529082028301929091600891018084116111f2575094979650505050505050565b6001600160a01b038216330361187a576040516375f45abd60e01b815260040160405180910390fd5b336000818152600e602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f0cff4fcf777050010027190b8061fd8bfd1de16d81b1f94e9752df1427a2623591015b60405180910390a35050565b6060601a8054610e1c90615815565b60006001600160a01b038316158061191557506001600160a01b038216155b8061192f575060008481526016602052604090205460ff16155b949350505050565b816119418161300b565b610e088383613032565b8051606090806001600160401b0381111561196857611968614b3d565b6040519080825280602002602001820160405280156119c357816020015b6119b060408051608081019091528060008152600060208201526060604082018190529081015290565b8152602001906001900390816119865790505b50915060005b81811015611b6a5760008482815181106119e5576119e56157c0565b6020908102919091018101516001600160401b03811660009081526017909252604091829020825160808101909352805491935090829060ff166002811115611a3057611a3061535d565b6002811115611a4157611a4161535d565b81528154610100900460ff166020808301919091526001830180546040805182850281018501825282815294019392830182828015611aa957602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611a8b575b50505050508152602001600282018054611ac290615815565b80601f0160208091040260200160405190810160405280929190818152602001828054611aee90615815565b8015611b3b5780601f10611b1057610100808354040283529160200191611b3b565b820191906000526020600020905b815481529060010190602001808311611b1e57829003601f168201915b505050505081525050848381518110611b5657611b566157c0565b6020908102919091010152506001016119c9565b5050919050565b6001600160a01b0382163303611b9a57604051630b7b99b960e21b815260040160405180910390fd5b3360008181526003602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3191016118db565b604080518082019091526000808252602082015281611c1d8461104e565b5111611c3c5760405163da22687f60e01b815260040160405180910390fd5b6000838152600660205260409020805483908110610fc557610fc56157c0565b600082611c688161265f565b61192f84846130a7565b81611c7c8161265f565b611c8885858585613423565b5050505050565b82611c99816128be565b610f3d848484613458565b611cce60408051608081019091528060008152600060208201526060604082018190529081015290565b6001600160401b038216600090815260176020526040908190208151608081019092528054829060ff166002811115611d0957611d0961535d565b6002811115611d1a57611d1a61535d565b81528154610100900460ff166020808301919091526001830180546040805182850281018501825282815294019392830182828015611d8257602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611d64575b50505050508152602001600282018054611d9b90615815565b80601f0160208091040260200160405190810160405280929190818152602001828054611dc790615815565b8015611e145780601f10611de957610100808354040283529160200191611e14565b820191906000526020600020905b815481529060010190602001808311611df757829003601f168201915b5050505050815250509050919050565b6001600160401b03821660009081526018602052604090205460ff1680158015611e7a575060016001600160401b03841660009081526017602052604090205460ff166002811115611e7857611e7861535d565b145b15610a23576001600160401b038316600090815260176020908152604080832060010180548251818502810185019093528083529192909190830182828015611eec57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611ece575b505083519394506000925050505b81811015611f4557828181518110611f1457611f146157c0565b60200260200101516001600160a01b0316856001600160a01b031603611f3d5760019350611f45565b600101611efa565b50505092915050565b82611f58816128be565b610f3d848484613613565b87611f6d8161300b565b611f7d898989898989898961368d565b505050505050505050565b60408051608081018252600181526002602080830191909152818301869052606082018590528251808401909352601d546001600160401b03168352820181905290611fd3816136f5565b611c8883613927565b6000611fe78261280d565b6000828152600f6020526040812090610d5e84611580565b81612009816128be565b610e08838361397e565b8361201d8161300b565b611c8885858585613a76565b6000818152600460209081526040808320815180830190925280548252600101546001600160a01b0316918101829052829182919061207b5760405163089ba7e160e41b815260040160405180910390fd5b6020810151905190959094508415159350915050565b61209c848484611725565b610f3d81610fff565b826120af816128be565b610f3d84848461241f565b60006001600160e01b031982166301ffc9a760e01b1480610a2357506001600160e01b0319821663d912401f60e01b1492915050565b6120fd8383600084613b7c565b60405182906001600160a01b038516906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a46040805160008082526020820181905284926001600160a01b038716927f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d910160405180910390a4505050565b61218c8583613c81565b6001600160a01b0383161580156121a35750805115155b156121c157604051631035ad0760e11b815260040160405180910390fd5b6001600160401b03858116600090815260106020908152604080832080546001600160a01b0319166001600160a01b03891617905560118252808320805467ffffffffffffffff191694891694909417909355601281529190208251610cc5928401906148fc565b6000838152600d602090815260408083206001600160401b038616845290915290205460ff161561226d576040516308fe3c3160e41b815260040160405180910390fd5b6001600160401b0382166000908152600860205260408120805461229090615815565b9050036122b057604051632aa5eff960e11b815260040160405180910390fd5b6000838152600b60205260409020546080116122df5760405163bade3a7b60e01b815260040160405180910390fd5b6000838152600d602090815260408083206001600160401b038681168086529184528285208054600160ff199091168117909155888652600b8552928520805493840181558552929093206004820401805460039092166008026101000a80840219909216919093021790915581161561238d5760008381526009602090815260408083206001600160401b0386811685529252909120805467ffffffffffffffff19169183169190911790555b6040805160018082528183019092526000916020808301908036833701905050905083816000815181106123c3576123c36157c0565b602002602001018181525050816001600160401b0316836001600160401b03167f4a85a0221f784dbe75db7c29c422f474c15bde9211a98e50a30018fa8dfa937b83604051612412919061586c565b60405180910390a3610f3d565b61242a838383613d47565b60008381526009602090815260408083206001600160401b03808616855292528220541690808215612502576124fc83600a60008981526020019081526020016000208054806020026020016040519081016040528092919081815260200182805480156124e957602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b0316815260200190600801906020826007010492830192600103820291508084116124a65790505b50505050506127a490919063ffffffff16565b90925090505b8015612583576000868152600a6020526040902080548591908490811061252b5761252b6157c0565b600091825260208083206004830401805460039093166008026101000a6001600160401b03818102199094169584160294909417909355888252600d835260408083209187168352925220805460ff1916905561260e565b6000868152600c60209081526040808320600a83529083208054825460018181018555938652848620600480830490910180546001600160401b0394851660086003958616810261010090810a9283029288021990931691909117909255855496870186559488529587209085040180548b84169590921690950290920a9283029202191617905592505b612619868686613def565b826001600160401b0316846001600160401b0316877f3f2709a99f6c06b4e57bbb38eb0134332f96f51a3da314f41a515adbb28b17cc60405160405180910390a4610cc5565b6126693382613e3d565b612686576040516345f3c98360e11b815260040160405180910390fd5b50565b60008061269585612029565b5091509150866001600160a01b0316826001600160a01b0316146126cc5760405163e146af6f60e01b815260040160405180910390fd5b6001600160a01b038616301480156126e357508385145b1561270157604051633d76b10760e01b815260040160405180910390fd5b61270a86613ee0565b612715858786613f97565b612720878787614088565b6001600160a01b0387166000908152600160208190526040822080549192909161274b9084906158b0565b9091555061275c90508585886140b0565b6001600160a01b038616600090815260016020819052604082208054919290916127879084906158c3565b9091555061279b905082878387898861410f565b50505050505050565b81516000908190815b818110156127fc57846001600160401b03168682815181106127d1576127d16157c0565b60200260200101516001600160401b0316036127f4579250600191506128069050565b6001016127ad565b5060008092509250505b9250929050565b6000818152600460205260409020600101546001600160a01b03166126865760405163089ba7e160e41b815260040160405180910390fd5b600061285082611580565b60008381526002602090815260408083206001600160a01b038581168086529190935281842080546001600160a01b031916938916938417905590519394508593919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259190a4505050565b6128c83382614210565b61268657604051635d64832960e01b815260040160405180910390fd5b6128f0838383613d47565b6128fb838383613def565b6000838152600d602090815260408083206001600160401b0385168085529252808320805460ff1916905551909185917f1010837a46db9510cad56c9b63e97183557a136e9d4ddbec309ce52c99afb1249190a3505050565b60008061296084612029565b5091509150856001600160a01b0316826001600160a01b0316146129975760405163e146af6f60e01b815260040160405180910390fd5b6001600160a01b0385166129be576040516338f646ff60e21b815260040160405180910390fd5b6129c9868686614088565b6001600160a01b038616600090815260016020819052604082208054919290916129f49084906158b0565b90915550612a069050846000876140b0565b6001600160a01b03851660009081526001602081905260408220805491929091612a319084906158c3565b909155505060405184906001600160a01b0380881691908916907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90600090a483856001600160a01b0316876001600160a01b03167f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d846000604051611718929190918252602082015260400190565b600260005403612ae4576040516362bfeae960e11b815260040160405180910390fd5b6002600055565b6040808201516001600160401b0390811660009081526010602090815283822054606086015186518452601383528584206001600160a01b039283168086529084528685209582168552949092529390912060020154919290911615612b645760405163bd0650ab60e01b815260040160405180910390fd5b612b7283604001518261428e565b6000612b8684600001518560200151610f68565b60208101518151608087015160405163074334fb60e01b815230600482015260248101929092526001600160401b039081166044830152851660648201529192506001600160a01b03169063074334fb90608401602060405180830381865afa158015612bf7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c1b91906158d6565b612c3857604051632c36cd3360e01b815260040160405180910390fd5b6020810151604051636e5bceab60e11b81526001600160401b03841660048201526001600160a01b0391821660248201529084169063dcb79d5690604401602060405180830381865afa158015612c93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cb791906158d6565b612cd457604051637228eff560e11b815260040160405180910390fd5b6040805160808082018352868301516001600160401b0390811683529087015181166020808401918252855184860190815286820180516001600160a01b03908116606088019081528c516000908152601386528981208d8416825286528981208c8916825286528981208951815498518a16600160401b026fffffffffffffffffffffffffffffffff1990991699169890981796909617875592516001808801919091559251600290960180549682166001600160a01b0319909716969096179095558a5184526014835286842090519094168352928152848220865183529052928320805492939192909190612dcd9084906158c3565b92505081905550826001600160401b031685604001516001600160401b031686600001517f1f5de02b1d9c93ca468f54630e1daf13f6dc458a63f8061ff73e85bf9bc38884856000015186602001518a60800151604051612e53939291909283526001600160a01b039190911660208301526001600160401b0316604082015260600190565b60405180910390a4611c88565b6040516318d5243360e21b81526001600160401b038084166004808401919091529083166024830152606060448301526064820152630c1e0d8d60e21b60848201523090819063635490cc9060a401600060405180830381600087803b158015612ec957600080fd5b505af115801561279b573d6000803e3d6000fd5b6000612ee882611580565b6000838152600f602090815260408083206001600160a01b038581168086529190935281842080546001600160a01b031916938916938417905590519394508593919290917fb90cc0d925ac3511ab6af2d7ca73ffcf7ec4bd871fff36b958ecf440079c463e9190a4505050565b6001600160401b0383161580612f7357506001600160401b038116155b15612f91576040516312c33ce360e01b815260040160405180910390fd5b6001600160401b0383811660008181526015602090815260408083206001600160a01b03881680855290835292819020805467ffffffffffffffff19169587169586179055519182527f5b5af0622001a9b735a56357ddc1abd65e6a640126498674daf9d2fb0516072591015b60405180910390a3505050565b613015338261432e565b612686576040516302728a9d60e41b815260040160405180910390fd5b60008281526006602052604090205481101561306157604051631e73178b60e11b815260040160405180910390fd5b6000828152600660205260408120613078916149b4565b60405182907f8ac4a0d65950c3e40448afb2260e2e0ec36ea15644d9b39e37e85472e5f9445190600090a25050565b60008060006130b585612029565b509150915060006130c586611580565b90506130d383600088614088565b60408051602080820183526000918290526001600160a01b038616825260019081905291812080549091906131099084906158b0565b9091555061311a9050600087612845565b6131238661439a565b600061312e87611730565b600088815260056020526040812091925061314991906149b4565b6000878152600660205260408120613160916149b4565b60008781526002602090815260408083206001600160a01b0386168452909152812080546001600160a01b031916905581518190815b818110156133655789831061320f578481815181106131b7576131b76157c0565b6020026020010151602001518582815181106131d5576131d56157c0565b6020908102919091010151516040516306177b2560e41b81526001600160a01b039092166004830152602482015260440160405180910390fd5b60076000868381518110613225576132256157c0565b6020026020010151602001516001600160a01b03166001600160a01b031681526020019081526020016000206000868381518110613265576132656157c0565b602002602001015160000151815260200190815260200160002060009055828a03935084818151811061329a5761329a6157c0565b6020026020010151602001516001600160a01b031663b390c0ab8683815181106132c6576132c66157c0565b6020026020010151600001516001876132df91906158b0565b6040516001600160e01b031960e085901b168152600481019290925260248201526044016020604051808303816000875af1158015613322573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061334691906158f3565b6133519060016158c3565b61335b90846158c3565b9250600101613196565b5060008a81526004602052604080822082815560010180546001600160a01b0319169055518b91906001600160a01b038a16907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908390a4604080518781526000602082018190528c9290916001600160a01b038b16917f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d910160405180910390a46040805160208101909152600090525098975050505050505050565b61342f84848484612954565b61343b848484846143a5565b610f3d5760405163bcb5663760e01b815260040160405180910390fd5b6001600160401b03808316600090815260106020908152604080832054878452601383528184206001600160a01b039182168086529084528285208787168652845293829020825160808101845281548088168252600160401b90049096169386019390935260018301549185019190915260029091015416606083018190529091906134f8576040516317de7dd760e21b815260040160405180910390fd5b60008581526013602090815260408083206001600160a01b0380871685529083528184206001600160401b0388168552835281842080546fffffffffffffffffffffffffffffffff191681556001808201869055600290910180546001600160a01b0319169055898552601484528285206060870151909216855290835281842085830151855290925282208054919290916135959084906158b0565b92505081905550826001600160401b0316846001600160401b0316867f438e039ebbba8f290f3b5d41aaf3295eccc9b5e6b0e1d52ace700772afb7da13846040015185606001518660200151604051612e53939291909283526001600160a01b039190911660208301526001600160401b0316604082015260600190565b6000838152600a60205260409020548190811461364357604051633581be1d60e11b815260040160405180910390fd5b6000848152600c6020526040902061365c9084846149d5565b5060405184907ff0bfd70b0068f973d58178846ca67112671ec45e060838f7de5662036bcf801790600090a2610f3d565b816136db5760008881526014602090815260408083206001600160a01b03881684528252808320868452909152902054156136db57604051630619dc9d60e21b815260040160405180910390fd5b6136eb88888888888888886144a4565b5050505050505050565b805160208201516001600160401b038216613723576040516312c33ce360e01b815260040160405180910390fd5b6001600160401b03821660009081526017602052604081205460ff1660028111156137505761375061535d565b1461376e57604051630fbdf8dd60e01b815260040160405180910390fd5b6000815160028111156137835761378361535d565b036137a157604051630b65407360e01b815260040160405180910390fd5b6002815160028111156137b6576137b661535d565b1480156137c7575060408101515115155b156137e557604051630b65407360e01b815260040160405180910390fd5b6001600160401b03821660009081526017602052604090208151815483929190829060ff1916600183600281111561381f5761381f61535d565b0217905550602082810151825460ff9091166101000261ff0019909116178255604083015180516138569260018501920190614a51565b506060820151600282019061386b9082615952565b5050601980546001810182556000919091527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c96956004820401805460039092166008026101000a6001600160401b03818102199093169286160291909117905550805160028111156138de576138de61535d565b826001600160401b03167fc4715b52aed3b9dfb2fbdc63e39e234892ec1dd3811d2c671646dbfd3d32d92e836020015184604001518560600151604051612ffe93929190615a11565b8061393181614685565b6001600160401b038216600081815260186020526040808220805460ff19166001179055517f540b0b22993accb6c2b7b0f4a5bd1b7e6419708ef2a68c39f09f01c848ba4fbc9190a25050565b6000828152600b6020526040902054818111156139ae57604051635134ce8960e01b815260040160405180910390fd5b60005b81811015613a2c576000848152600b602052604081208054839081106139d9576139d96157c0565b6000918252602080832060048304015488845260098252604080852060039094166008026101000a9091046001600160401b031684529190529020805467ffffffffffffffff19169055506001016139b1565b506000838152600b60205260408120613a4491614aa6565b60405160009084907f1010837a46db9510cad56c9b63e97183557a136e9d4ddbec309ce52c99afb124908390a3505050565b6000613a828585611bff565b9050613a8f818484614704565b6001600160a01b038316600090815260076020908152604080832085845290915290205415613ad15760405163188a497360e01b815260040160405180910390fd5b6000858152600660205260409020613ae99085614748565b600085815260056020908152604080832080546001808201835591855283852086516002909202019081558584015190820180546001600160a01b0319166001600160a01b03928316179055871680855260078452828520878652845293829020555186815284929188917f29486b9e2ae569b440933a9b1b421467306fa21f3dcad439c262910a634963a99101612e53565b6001600160a01b038416613ba3576040516325bd6bd360e01b815260040160405180910390fd5b6000838152600460205260409020600101546001600160a01b031615613bdc5760405163c5a8d37160e01b815260040160405180910390fd5b82613bfa576040516312c33ce360e01b815260040160405180910390fd5b613c0660008585614088565b6001600160a01b03841660009081526001602081905260408220805491929091613c319084906158c3565b90915550506040805180820182529283526001600160a01b039485166020808501918252600095865260049052932091518255509051600190910180546001600160a01b03191691909216179055565b6001600160401b038216613ca8576040516312c33ce360e01b815260040160405180910390fd5b6001600160401b03821660009081526008602052604081208054613ccb90615815565b90501115613cec576040516308fe3c3160e41b815260040160405180910390fd5b6001600160401b0382166000908152600860205260409020613d0e8282615952565b506040516001600160401b038316907f3cd061096eaf881067d936308fbd8b81d060c45ab2ec910c02b953162befc10990600090a25050565b6000838152600b60205260409020548210613d7557604051630757d52160e01b815260040160405180910390fd5b6000838152600b60205260409020805483908110613d9557613d956157c0565b90600052602060002090600491828204019190066008029054906101000a90046001600160401b03166001600160401b0316816001600160401b031614610e08576040516378eeeecf60e01b815260040160405180910390fd5b6000838152600b60205260409020613e079083614802565b60009283526009602090815260408085206001600160401b039093168552919052909120805467ffffffffffffffff1916905550565b6000806000613e4b84612029565b509150915080600014613e6e57506001600160a01b038481169116149050610a23565b816001600160a01b0316856001600160a01b03161480613eb357506001600160a01b0380831660009081526003602090815260408083209389168352929052205460ff165b80613ed75750846001600160a01b0316613ecc85610d3b565b6001600160a01b0316145b95945050505050565b806001600160a01b03163b600003613f0b5760405163b9d3114760e01b815260040160405180910390fd5b6040516301ffc9a760e01b81526342b0e56f60e01b60048201526001600160a01b038216906301ffc9a790602401602060405180830381865afa158015613f56573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613f7a91906158d6565b61268657604051631784ec7360e21b815260040160405180910390fd5b60005b606481101561406e576000806000856001600160a01b031663fb25fb7a866040518263ffffffff1660e01b8152600401613fd691815260200190565b606060405180830381865afa158015613ff3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140179190615a49565b9250925092508061402b5750505050505050565b6001600160a01b0383163014801561404257508682145b15614060576040516324543e6d60e11b815260040160405180910390fd5b509093509150600101613f9a565b50604051630349a6bd60e51b815260040160405180910390fd5b6140938184846118f6565b610e085760405163792fac8360e11b815260040160405180910390fd5b6040805180820182528381526001600160a01b038381166020808401918252600088815260049091529384209251835551600190920180546001600160a01b031916929091169190911790556141069084612845565b610e088361439a565b6040516318d5243360e21b815285906001600160a01b0382169063635490cc9061414190879087908790600401615a81565b600060405180830381600087803b15801561415b57600080fd5b505af115801561416f573d6000803e3d6000fd5b5050505082866001600160a01b0316886001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a482866001600160a01b0316886001600160a01b03167f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d8888604051614203929190918252602082015260400190565b60405180910390a461279b565b60008061421c83611580565b9050806001600160a01b0316846001600160a01b0316148061426357506001600160a01b038082166000908152600e602090815260408083209388168352929052205460ff165b8061192f5750836001600160a01b031661427c84611fdc565b6001600160a01b031614949350505050565b6001600160401b0382166000908152601260209081526040808320805482518185028101850190935280835261430d9386939291908301828280156124e957600091825260209182902080546001600160401b031684529082028301929091600891018084116124a657905050505050506127a490919063ffffffff16565b91505080610e0857604051634ef44ed560e01b815260040160405180910390fd5b60008061433a83611580565b9050806001600160a01b0316846001600160a01b0316148061438157506001600160a01b0380821660009081526003602090815260408083209388168352929052205460ff165b8061192f5750836001600160a01b031661427c84610d3b565b612686600082612edd565b60006001600160a01b0384163b1561449957604051630a85bd0160e11b81526001600160a01b0385169063150b7a02906143e9903390899088908890600401615aa0565b6020604051808303816000875af1925050508015614424575060408051601f3d908101601f1916820190925261442191810190615ad2565b60015b61447f573d808015614452576040519150601f19603f3d011682016040523d82523d6000602084013e614457565b606091505b5080516144775760405163bcb5663760e01b815260040160405180910390fd5b805181602001fd5b6001600160e01b031916630a85bd0160e11b14905061192f565b506001949350505050565b604080518082019091526000808252602082015282156144cf576144c88987611bff565b90506144dc565b6144d98987610f68565b90505b6144e7818686614704565b821561450a5760008981526006602052604090206145059087614748565b614544565b6001600160a01b038516600090815260076020908152604080832087845282528083208390558b8352600590915290206145449087614748565b6001600160a01b0388161561462e57866145c157604051635c46a7ef60e11b81526001600160a01b0386169063b88d4fde9061458a9030908c9089908890600401615aa0565b600060405180830381600087803b1580156145a457600080fd5b505af11580156145b8573d6000803e3d6000fd5b5050505061462e565b60208101518151604051630326051d60e11b81526001600160a01b039092169163064c0a3a916145fb9130918d918d908990600401615aef565b600060405180830381600087803b15801561461557600080fd5b505af1158015614629573d6000803e3d6000fd5b505050505b6040805187815284151560208201526001600160a01b038a81161582840152915186928816918c917f02d6d6dbcb604d5e1e8c7886456e82a9cdce88b0a580071358f206b5a4d58f709181900360600190a4611f7d565b6001600160401b03811660009081526017602052604081205460ff16908160028111156146b4576146b461535d565b036146d2576040516307ae018160e21b815260040160405180910390fd5b60028160028111156146e6576146e661535d565b0361104a5760405163ae6a3b7760e01b815260040160405180910390fd5b82602001516001600160a01b0316826001600160a01b031614158061472a575082518114155b15610e0857604051637383f2c160e11b815260040160405180910390fd5b81548290614758906001906158b0565b81548110614768576147686157c0565b9060005260206000209060020201828281548110614788576147886157c0565b600091825260209091208254600290920201908155600191820154910180546001600160a01b0319166001600160a01b0390921691909117905581548290806147d3576147d3615b27565b60008281526020812060026000199093019283020190815560010180546001600160a01b031916905590555050565b8154811061482357604051634e23d03560e01b815260040160405180910390fd5b81548290614833906001906158b0565b81548110614843576148436157c0565b90600052602060002090600491828204019190066008029054906101000a90046001600160401b031682828154811061487e5761487e6157c0565b90600052602060002090600491828204019190066008026101000a8154816001600160401b0302191690836001600160401b03160217905550818054806148c7576148c7615b27565b60008281526020902060046000199092019182040180546001600160401b03600860038516026101000a021916905590555050565b828054828255906000526020600020906003016004900481019282156149a45791602002820160005b8382111561496f57835183826101000a8154816001600160401b0302191690836001600160401b031602179055509260200192600801602081600701049283019260010302614925565b80156149a25782816101000a8154906001600160401b03021916905560080160208160070104928301926001030261496f565b505b506149b0929150614ac7565b5090565b50805460008255600202906000526020600020908101906126869190614adc565b828054828255906000526020600020906003016004900481019282156149a45791602002820160005b8382111561496f5783356001600160401b031683826101000a8154816001600160401b0302191690836001600160401b0316021790555092602001926008016020816007010492830192600103026149fe565b8280548282559060005260206000209081019282156149a4579160200282015b828111156149a457825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190614a71565b50805460008255600301600490049060005260206000209081019061268691905b5b808211156149b05760008155600101614ac8565b5b808211156149b057600081556001810180546001600160a01b0319169055600201614add565b6001600160e01b03198116811461268657600080fd5b600060208284031215614b2b57600080fd5b8135614b3681614b03565b9392505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715614b7b57614b7b614b3d565b604052919050565b600082601f830112614b9457600080fd5b81356001600160401b03811115614bad57614bad614b3d565b614bc0601f8201601f1916602001614b53565b818152846020838601011115614bd557600080fd5b816020850160208301376000918101602001919091529392505050565b60006001600160401b03821115614c0b57614c0b614b3d565b5060051b60200190565b6001600160a01b038116811461268657600080fd5b600082601f830112614c3b57600080fd5b81356020614c50614c4b83614bf2565b614b53565b82815260059290921b84018101918181019086841115614c6f57600080fd5b8286015b84811015614c93578035614c8681614c15565b8352918301918301614c73565b509695505050505050565b60008060408385031215614cb157600080fd5b82356001600160401b0380821115614cc857600080fd5b614cd486838701614b83565b93506020850135915080821115614cea57600080fd5b50614cf785828601614c2a565b9150509250929050565b600080600080600060a08688031215614d1957600080fd5b8535614d2481614c15565b94506020860135614d3481614c15565b9350604086013592506060860135915060808601356001600160401b03811115614d5d57600080fd5b614d6988828901614b83565b9150509295509295909350565b80356001600160401b0381168114614d8d57600080fd5b919050565b60008060008060808587031215614da857600080fd5b8435614db381614c15565b935060208501359250614dc860408601614d76565b9150614dd660608601614d76565b905092959194509250565b600060208284031215614df357600080fd5b5035919050565b60008060408385031215614e0d57600080fd5b8235614e1881614c15565b946020939093013593505050565b6000815180845260005b81811015614e4c57602081850181015186830182015201614e30565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000614b366020830184614e26565b600081518084526020808501945080840160005b83811015614eb85781516001600160401b031687529582019590820190600101614e93565b509495945050505050565b602081526000614b366020830184614e7f565b60008060408385031215614ee957600080fd5b8235614ef481614c15565b91506020830135614f0481614c15565b809150509250929050565b600080600060608486031215614f2457600080fd5b8335925060208401359150614f3b60408501614d76565b90509250925092565b600080600060608486031215614f5957600080fd5b8335614f6481614c15565b92506020840135614f7481614c15565b929592945050506040919091013590565b60008060408385031215614f9857600080fd5b50508035926020909101359150565b815181526020808301516001600160a01b03169082015260408101610a23565b600060a08284031215614fd957600080fd5b60405160a081018181106001600160401b0382111715614ffb57614ffb614b3d565b8060405250809150823581526020830135602082015261501d60408401614d76565b604082015261502e60608401614d76565b606082015261503f60808401614d76565b60808201525092915050565b600060a0828403121561505d57600080fd5b614b368383614fc7565b602080825282518282018190526000919060409081850190868401855b828110156150ba576150aa848351805182526020908101516001600160a01b0316910152565b9284019290850190600101615084565b5091979650505050505050565b600080604083850312156150da57600080fd5b823591506150ea60208401614d76565b90509250929050565b6080815260006151066080830187614e26565b6001600160401b03861660208401526001600160a01b038516604084015282810360608401526151368185614e7f565b979650505050505050565b6000806040838503121561515457600080fd5b61515d83614d76565b915060208301356001600160401b0381111561517857600080fd5b614cf785828601614b83565b60008060006060848603121561519957600080fd5b833592506020840135915060408401356001600160401b038111156151bd57600080fd5b6151c986828701614b83565b9150509250925092565b6000806000606084860312156151e857600080fd5b6151f184614d76565b9250602084013561520181614c15565b9150614f3b60408501614d76565b60006020828403121561522157600080fd5b8135614b3681614c15565b60008060006060848603121561524157600080fd5b83359250602084013561520181614c15565b801515811461268657600080fd5b6000806040838503121561527457600080fd5b823561527f81614c15565b91506020830135614f0481615253565b6000806000606084860312156152a457600080fd5b8335925060208401356152b681614c15565b915060408401356152c681614c15565b809150509250925092565b600060208083850312156152e457600080fd5b82356001600160401b038111156152fa57600080fd5b8301601f8101851361530b57600080fd5b8035615319614c4b82614bf2565b81815260059190911b8201830190838101908783111561533857600080fd5b928401925b828410156151365761534e84614d76565b8252928401929084019061533d565b634e487b7160e01b600052602160045260246000fd5b600081518084526020808501945080840160005b83811015614eb85781516001600160a01b031687529582019590820190600101615387565b60008151600381106153ce57634e487b7160e01b600052602160045260246000fd5b8084525060ff60208301511660208401526040820151608060408501526153f86080850182615373565b905060608301518482036060860152613ed78282614e26565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561546657603f198886030184526154548583516153ac565b94509285019290850190600101615438565b5092979650505050505050565b6000806000806080858703121561548957600080fd5b843561549481614c15565b935060208501356154a481614c15565b92506040850135915060608501356001600160401b038111156154c657600080fd5b6154d287828801614b83565b91505092959194509250565b6000806000606084860312156154f357600080fd5b8335925061520160208501614d76565b60006020828403121561551557600080fd5b614b3682614d76565b602081526000614b3660208301846153ac565b6000806040838503121561554457600080fd5b614ef483614d76565b60008060006040848603121561556257600080fd5b8335925060208401356001600160401b038082111561558057600080fd5b818601915086601f83011261559457600080fd5b8135818111156155a357600080fd5b8760208260051b85010111156155b857600080fd5b6020830194508093505050509250925092565b600080600080600080600080610100898b0312156155e857600080fd5b8835975060208901356155fa81614c15565b96506040890135955060608901359450608089013561561881614c15565b935060a0890135925060c089013561562f81615253565b915060e08901356001600160401b0381111561564a57600080fd5b6156568b828c01614b83565b9150509295985092959890939650565b60008060006060848603121561567b57600080fd5b83356001600160401b038082111561569257600080fd5b61569e87838801614c2a565b945060208601359150808211156156b457600080fd5b506156c186828701614b83565b925050614f3b60408501614d76565b600080600080608085870312156156e657600080fd5b843593506020850135925060408501356156ff81614c15565b9396929550929360600135925050565b60008060006060848603121561572457600080fd5b833592506020840135614f7481614c15565b600080600080610100858703121561574d57600080fd5b61575685614d76565b9350602085013561576681614c15565b925061577460408601614d76565b9150614dd68660608701614fc7565b634e487b7160e01b600052601160045260246000fd5b6001600160401b038181168382160190808211156157b9576157b9615783565b5092915050565b634e487b7160e01b600052603260045260246000fd5b6000600182016157e8576157e8615783565b5060010190565b60006001600160401b0380831681810361580b5761580b615783565b6001019392505050565b600181811c9082168061582957607f821691505b60208210810361584957634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561586157600080fd5b8151614b3681614c15565b6020808252825182820181905260009190848201906040850190845b818110156158a457835183529284019291840191600101615888565b50909695505050505050565b81810381811115610a2357610a23615783565b80820180821115610a2357610a23615783565b6000602082840312156158e857600080fd5b8151614b3681615253565b60006020828403121561590557600080fd5b5051919050565b601f821115610e0857600081815260208120601f850160051c810160208610156159335750805b601f850160051c820191505b81811015610cc55782815560010161593f565b81516001600160401b0381111561596b5761596b614b3d565b61597f816159798454615815565b8461590c565b602080601f8311600181146159b4576000841561599c5750858301515b600019600386901b1c1916600185901b178555610cc5565b600085815260208120601f198616915b828110156159e3578886015182559484019460019091019084016159c4565b5085821015615a015787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60ff84168152606060208201526000615a2d6060830185615373565b8281036040840152615a3f8185614e26565b9695505050505050565b600080600060608486031215615a5e57600080fd5b8351615a6981614c15565b6020850151604086015191945092506152c681615253565b838152826020820152606060408201526000613ed76060830184614e26565b60006001600160a01b03808716835280861660208401525083604083015260806060830152615a3f6080830184614e26565b600060208284031215615ae457600080fd5b8151614b3681614b03565b60006001600160a01b03808816835280871660208401525084604083015283606083015260a0608083015261513660a0830184614e26565b634e487b7160e01b600052603160045260246000fdfea26469706673582212200c510224d5dbe6ed17d2244bce49cb5d78257e1d48ad10bb924ae1f4672adf1764736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106103835760003560e01c80637280281e116101de578063dc477d2f1161010f578063e7de4de4116100ad578063fb25fb7a1161007c578063fb25fb7a14610997578063fbd6060c146109d1578063fc3517c8146109e4578063ffa1ad74146109f757600080fd5b8063e7de4de4146108f7578063e97ceaa81461090a578063e985e9c51461091d578063ee1dffcf1461095957600080fd5b8063defa80c3116100e9578063defa80c314610887578063df6f556b1461089a578063e2c1167c146108d1578063e467a48f146108e457600080fd5b8063dc477d2f14610835578063dcb79d5614610861578063de8e602c1461087457600080fd5b80639806c6ec1161017c578063b390c0ab11610156578063b390c0ab146107dc578063b88d4fde146107ef578063c259a98814610802578063d297ac431461081557600080fd5b80639806c6ec14610796578063a22cb465146107b6578063a898e364146107c957600080fd5b806386a92af7116101b857806386a92af7146107535780638d4f3bf51461075b57806391a6262f14610770578063979613361461078357600080fd5b80637280281e146106425780637507e2ae146106555780638507dc281461074057600080fd5b806342842e0e116102b85780635e94354a11610256578063635490cc11610230578063635490cc146105e857806365b67eb9146105fb5780636f19951c1461060e57806370a082311461062157600080fd5b80635e94354a146105af5780635ea72f36146105c25780636352211e146105d557600080fd5b80634e60edba116102925780634e60edba1461055357806351532e5a1461057657806355bd8648146105895780635e2e32921461059c57600080fd5b806342842e0e1461050d57806342966c681461052057806344ec93441461053357600080fd5b806315dae03e1161032557806322f6da9c116102ff57806322f6da9c146104b457806323b872dd146104c75780632f32f937146104da57806338dcf74c146104fa57600080fd5b806315dae03e1461044e5780631c6443991461046357806322e6d1601461047857600080fd5b8063064c0a3a11610361578063064c0a3a146103ea578063074334fb146103fd578063081812fc14610410578063095ea7b31461043b57600080fd5b8063010a38f51461038857806301ffc9a7146103b257806305c07af6146103d5575b600080fd5b601c546001600160401b03165b6040516001600160401b0390911681526020015b60405180910390f35b6103c56103c0366004614b19565b610a18565b60405190151581526020016103a9565b6103e86103e3366004614c9e565b610a29565b005b6103e86103f8366004614d01565b610cae565b6103c561040b366004614d92565b610ccd565b61042361041e366004614de1565b610d3b565b6040516001600160a01b0390911681526020016103a9565b6103e8610449366004614dfa565b610d81565b610456610e0d565b6040516103a99190614e6c565b61046b610e9f565b6040516103a99190614ec3565b6103c5610486366004614ed6565b6001600160a01b039182166000908152600e6020908152604080832093909416825291909152205460ff1690565b6103e86104c2366004614f0f565b610f28565b6103e86104d5366004614f44565b610f43565b6104ed6104e8366004614f85565b610f68565b6040516103a99190614fa7565b6103e861050836600461504b565b610fff565b6103e861051b366004614f44565b611024565b6103e861052e366004614de1565b61103f565b610546610541366004614de1565b61104e565b6040516103a99190615067565b6105666105613660046150c7565b6110d6565b6040516103a994939291906150f3565b61046b610584366004614de1565b6111ad565b6103e8610597366004615141565b611241565b6104566105aa3660046150c7565b6113a1565b61046b6105bd366004614de1565b611490565b6103e86105d0366004614dfa565b6114f9565b6104236105e3366004614de1565b611580565b6103e86105f6366004615184565b611610565b6103e86106093660046151d3565b611725565b61054661061c366004614de1565b611730565b61063461062f36600461520f565b6117a3565b6040519081526020016103a9565b61046b610650366004614de1565b6117e8565b6106f261066336600461522c565b6040805160808082018352600080835260208084018290528385018290526060938401829052968152601387528381206001600160a01b03968716825287528381206001600160401b03958616825287528390208351918201845280548086168352600160401b9004909416958101959095526001830154918501919091526002909101549091169082015290565b6040516103a9919060006080820190506001600160401b0380845116835280602085015116602084015250604083015160408301526001600160a01b03606084015116606083015292915050565b6103e861074e366004615261565b611851565b6104566118e7565b60405163524d524b60e01b81526020016103a9565b6103c561077e36600461528f565b6118f6565b6103e8610791366004614f85565b611937565b6107a96107a43660046152d1565b61194b565b6040516103a99190615411565b6103e86107c4366004615261565b611b71565b6104ed6107d7366004614f85565b611bff565b6106346107ea366004614f85565b611c5c565b6103e86107fd366004615473565b611c72565b6103e86108103660046154de565b611c8f565b610828610823366004615503565b611ca4565b6040516103a9919061551e565b6103c5610843366004615503565b6001600160401b031660009081526018602052604090205460ff1690565b6103c561086f366004615531565b611e24565b6103e861088236600461554d565b611f4e565b6103e86108953660046155cb565b611f63565b6103956108a83660046150c7565b60009182526009602090815260408084206001600160401b039384168552909152909120541690565b6103e86108df366004615666565b611f88565b6104236108f2366004614de1565b611fdc565b6103e8610905366004614f85565b611fff565b6103e86109183660046156d0565b612013565b6103c561092b366004614ed6565b6001600160a01b03918216600090815260036020908152604080832093909416825291909152205460ff1690565b6103c561096736600461570f565b60009283526014602090815260408085206001600160a01b03909416855292815282842091845252902054151590565b6109aa6109a5366004614de1565b612029565b604080516001600160a01b03909416845260208401929092521515908201526060016103a9565b6103e86109df366004615736565b612091565b6103e86109f2366004614f0f565b6120a5565b604080518082019091526005815264191719971960d91b6020820152610456565b6000610a23826120ba565b92915050565b604080516003808252608082019092526000916020820160608036833701905050601c546040805180820190915260048152630c1e0d8d60e21b6020820152919250610a809133916001600160401b0316906120f0565b601d54600090610a9a906001600160401b03166003615799565b601d549091506000906001600160401b03165b826001600160401b0316816001600160401b03161015610b5e57610ad2858783611f88565b80848381518110610ae557610ae56157c0565b6001600160401b039092166020928302919091019091015281610b07816157d6565b601d80549194506001600160401b0390911691506000610b26836157ef565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550508080610b56906157ef565b915050610aad565b50601c54610b82906001600160401b0380821691600160c01b900416308887612182565b601c54610ba3906001600160401b0380821691600160801b90041680612229565b601c54610bc7906001600160401b0380821691600091600160801b9091041661241f565b601c8054601e805460018101825560009182527f50bb669a95c7b50b7e8a6f09454034b2b14cf2b85c730dca9a539ca82cb6e350600482040180546001600160401b0360039093166008026101000a83810219909116948316029390931790925582549091169190610c38836157ef565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050601c601081819054906101000a90046001600160401b031680929190610c82906157ef565b91906101000a8154816001600160401b0302191690836001600160401b03160217905550505050505050565b82610cb88161265f565b610cc58686868686612689565b505050505050565b6001600160401b038083166000908152601160209081526040808320548416808452601583528184206001600160a01b038a1685529092528220549192909181169084168103610d31576000610d2c86610d26896117e8565b906127a4565b945050505b5050949350505050565b6000610d468261280d565b600082815260026020526040812090610d5e84611580565b6001600160a01b0390811682526020820192909252604001600020541692915050565b6000610d8c82611580565b9050806001600160a01b0316836001600160a01b031603610dc057604051630591db6d60e01b815260040160405180910390fd5b336001600160a01b03821614801590610de05750610dde813361092b565b155b15610dfe57604051634c12315960e11b815260040160405180910390fd5b610e088383612845565b505050565b6060601b8054610e1c90615815565b80601f0160208091040260200160405190810160405280929190818152602001828054610e4890615815565b8015610e955780601f10610e6a57610100808354040283529160200191610e95565b820191906000526020600020905b815481529060010190602001808311610e7857829003601f168201915b5050505050905090565b6060601e805480602002602001604051908101604052809291908181526020018280548015610e9557602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b031681526020019060080190602082600701049283019260010382029150808411610edc5790505050505050905090565b82610f32816128be565b610f3d8484846128e5565b50505050565b80610f4d8161265f565b610f3d84848460405180602001604052806000815250612954565b604080518082019091526000808252602082015281610f8684611730565b5111610fa55760405163653e642560e11b815260040160405180910390fd5b6000838152600560205260409020805483908110610fc557610fc56157c0565b60009182526020918290206040805180820190915260029092020180548252600101546001600160a01b0316918101919091529392505050565b805161100a816128be565b611012612ac1565b61101b82612aeb565b50506001600055565b610e0883838360405180602001604052806000815250611c72565b61104a816000611c5c565b5050565b606060066000838152602001908152602001600020805480602002602001604051908101604052809291908181526020016000905b828210156110cb5760008481526020908190206040805180820190915260028502909101805482526001908101546001600160a01b0316828401529083529092019101611083565b505050509050919050565b606060008060606110e786866113a1565b6001600160401b03808716600090815260116020908152604080832054601083528184205460128452938290208054835181860281018601909452808452969a50941697506001600160a01b03909216955090929083018282801561119d57602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b03168152602001906008019060208260070104928301926001038202915080841161115a5790505b5050505050905092959194509250565b6000818152600b602090815260409182902080548351818402810184019094528084526060939283018282801561123557602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b0316815260200190600801906020826007010492830192600103820291508084116111f25790505b50505050509050919050565b601c546040805180820190915260048152630c1e0d8d60e21b60208201526060916112779133916001600160401b0316906120f0565b601c5461129a906001600160401b0380821691600160c01b900416308585612182565b601c546112bb906001600160401b0380821691600160801b90041680612229565b601c546112df906001600160401b0380821691600091600160801b9091041661241f565b601c546112f69084906001600160401b0316612e60565b601c54611314906001600160401b0380861691600091309116612013565b601c80546001600160401b031690600061132d836157ef565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050601c601081819054906101000a90046001600160401b031680929190611377906157ef565b91906101000a8154816001600160401b0302191690836001600160401b0316021790555050505050565b6000828152600d602090815260408083206001600160401b038516845290915290205460609060ff166113e757604051631b9928fd60e31b815260040160405180910390fd5b6001600160401b0382166000908152600860205260409020805461140a90615815565b80601f016020809104026020016040519081016040528092919081815260200182805461143690615815565b80156114835780601f1061145857610100808354040283529160200191611483565b820191906000526020600020905b81548152906001019060200180831161146657829003601f168201915b5050505050905092915050565b6000818152600c602090815260409182902080548351818402810184019094528084526060939283018282801561123557600091825260209182902080546001600160401b031684529082028301929091600891018084116111f2575094979650505050505050565b600061150482611580565b9050806001600160a01b0316836001600160a01b031603611538576040516375f45abd60e01b815260040160405180910390fd5b336001600160a01b0382161480159061155857506115568133610486565b155b15611576576040516357a2e94960e11b815260040160405180910390fd5b610e088383612edd565b60008060008061158f85612029565b9250925092508015611607576040516331a9108f60e11b8152600481018390526001600160a01b03841690636352211e90602401602060405180830381865afa1580156115e0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611604919061584f565b92505b50909392505050565b6116198361280d565b33803b60000361163c5760405163b9d3114760e01b815260040160405180910390fd5b604080518082019091528381526001600160a01b038216602082015260006116638661104e565b51905060808110156116c2576000868152600660209081526040822080546001808201835591845292829020855160029094020192835590840151910180546001600160a01b0319166001600160a01b039092169190911790556116db565b60405163a53c8c0560e01b815260040160405180910390fd5b84836001600160a01b0316877fe65085e689b77b126ba0bac3b079aa8288f19f4d5445af11c76003f8ab3075dd8460405161171891815260200190565b60405180910390a4610cc5565b610e08838383612f56565b60008181526005602090815260408083208054825181850281018501909352808352606094929391929091840182156110cb5760008481526020908190206040805180820190915260028502909101805482526001908101546001600160a01b0316828401529083529092019101611083565b60006001600160a01b0382166117cc57604051633bb9143360e11b815260040160405180910390fd5b506001600160a01b031660009081526001602052604090205490565b6000818152600a602090815260409182902080548351818402810184019094528084526060939283018282801561123557600091825260209182902080546001600160401b031684529082028301929091600891018084116111f2575094979650505050505050565b6001600160a01b038216330361187a576040516375f45abd60e01b815260040160405180910390fd5b336000818152600e602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f0cff4fcf777050010027190b8061fd8bfd1de16d81b1f94e9752df1427a2623591015b60405180910390a35050565b6060601a8054610e1c90615815565b60006001600160a01b038316158061191557506001600160a01b038216155b8061192f575060008481526016602052604090205460ff16155b949350505050565b816119418161300b565b610e088383613032565b8051606090806001600160401b0381111561196857611968614b3d565b6040519080825280602002602001820160405280156119c357816020015b6119b060408051608081019091528060008152600060208201526060604082018190529081015290565b8152602001906001900390816119865790505b50915060005b81811015611b6a5760008482815181106119e5576119e56157c0565b6020908102919091018101516001600160401b03811660009081526017909252604091829020825160808101909352805491935090829060ff166002811115611a3057611a3061535d565b6002811115611a4157611a4161535d565b81528154610100900460ff166020808301919091526001830180546040805182850281018501825282815294019392830182828015611aa957602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611a8b575b50505050508152602001600282018054611ac290615815565b80601f0160208091040260200160405190810160405280929190818152602001828054611aee90615815565b8015611b3b5780601f10611b1057610100808354040283529160200191611b3b565b820191906000526020600020905b815481529060010190602001808311611b1e57829003601f168201915b505050505081525050848381518110611b5657611b566157c0565b6020908102919091010152506001016119c9565b5050919050565b6001600160a01b0382163303611b9a57604051630b7b99b960e21b815260040160405180910390fd5b3360008181526003602090815260408083206001600160a01b03871680855290835292819020805460ff191686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3191016118db565b604080518082019091526000808252602082015281611c1d8461104e565b5111611c3c5760405163da22687f60e01b815260040160405180910390fd5b6000838152600660205260409020805483908110610fc557610fc56157c0565b600082611c688161265f565b61192f84846130a7565b81611c7c8161265f565b611c8885858585613423565b5050505050565b82611c99816128be565b610f3d848484613458565b611cce60408051608081019091528060008152600060208201526060604082018190529081015290565b6001600160401b038216600090815260176020526040908190208151608081019092528054829060ff166002811115611d0957611d0961535d565b6002811115611d1a57611d1a61535d565b81528154610100900460ff166020808301919091526001830180546040805182850281018501825282815294019392830182828015611d8257602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611d64575b50505050508152602001600282018054611d9b90615815565b80601f0160208091040260200160405190810160405280929190818152602001828054611dc790615815565b8015611e145780601f10611de957610100808354040283529160200191611e14565b820191906000526020600020905b815481529060010190602001808311611df757829003601f168201915b5050505050815250509050919050565b6001600160401b03821660009081526018602052604090205460ff1680158015611e7a575060016001600160401b03841660009081526017602052604090205460ff166002811115611e7857611e7861535d565b145b15610a23576001600160401b038316600090815260176020908152604080832060010180548251818502810185019093528083529192909190830182828015611eec57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611ece575b505083519394506000925050505b81811015611f4557828181518110611f1457611f146157c0565b60200260200101516001600160a01b0316856001600160a01b031603611f3d5760019350611f45565b600101611efa565b50505092915050565b82611f58816128be565b610f3d848484613613565b87611f6d8161300b565b611f7d898989898989898961368d565b505050505050505050565b60408051608081018252600181526002602080830191909152818301869052606082018590528251808401909352601d546001600160401b03168352820181905290611fd3816136f5565b611c8883613927565b6000611fe78261280d565b6000828152600f6020526040812090610d5e84611580565b81612009816128be565b610e08838361397e565b8361201d8161300b565b611c8885858585613a76565b6000818152600460209081526040808320815180830190925280548252600101546001600160a01b0316918101829052829182919061207b5760405163089ba7e160e41b815260040160405180910390fd5b6020810151905190959094508415159350915050565b61209c848484611725565b610f3d81610fff565b826120af816128be565b610f3d84848461241f565b60006001600160e01b031982166301ffc9a760e01b1480610a2357506001600160e01b0319821663d912401f60e01b1492915050565b6120fd8383600084613b7c565b60405182906001600160a01b038516906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a46040805160008082526020820181905284926001600160a01b038716927f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d910160405180910390a4505050565b61218c8583613c81565b6001600160a01b0383161580156121a35750805115155b156121c157604051631035ad0760e11b815260040160405180910390fd5b6001600160401b03858116600090815260106020908152604080832080546001600160a01b0319166001600160a01b03891617905560118252808320805467ffffffffffffffff191694891694909417909355601281529190208251610cc5928401906148fc565b6000838152600d602090815260408083206001600160401b038616845290915290205460ff161561226d576040516308fe3c3160e41b815260040160405180910390fd5b6001600160401b0382166000908152600860205260408120805461229090615815565b9050036122b057604051632aa5eff960e11b815260040160405180910390fd5b6000838152600b60205260409020546080116122df5760405163bade3a7b60e01b815260040160405180910390fd5b6000838152600d602090815260408083206001600160401b038681168086529184528285208054600160ff199091168117909155888652600b8552928520805493840181558552929093206004820401805460039092166008026101000a80840219909216919093021790915581161561238d5760008381526009602090815260408083206001600160401b0386811685529252909120805467ffffffffffffffff19169183169190911790555b6040805160018082528183019092526000916020808301908036833701905050905083816000815181106123c3576123c36157c0565b602002602001018181525050816001600160401b0316836001600160401b03167f4a85a0221f784dbe75db7c29c422f474c15bde9211a98e50a30018fa8dfa937b83604051612412919061586c565b60405180910390a3610f3d565b61242a838383613d47565b60008381526009602090815260408083206001600160401b03808616855292528220541690808215612502576124fc83600a60008981526020019081526020016000208054806020026020016040519081016040528092919081815260200182805480156124e957602002820191906000526020600020906000905b82829054906101000a90046001600160401b03166001600160401b0316815260200190600801906020826007010492830192600103820291508084116124a65790505b50505050506127a490919063ffffffff16565b90925090505b8015612583576000868152600a6020526040902080548591908490811061252b5761252b6157c0565b600091825260208083206004830401805460039093166008026101000a6001600160401b03818102199094169584160294909417909355888252600d835260408083209187168352925220805460ff1916905561260e565b6000868152600c60209081526040808320600a83529083208054825460018181018555938652848620600480830490910180546001600160401b0394851660086003958616810261010090810a9283029288021990931691909117909255855496870186559488529587209085040180548b84169590921690950290920a9283029202191617905592505b612619868686613def565b826001600160401b0316846001600160401b0316877f3f2709a99f6c06b4e57bbb38eb0134332f96f51a3da314f41a515adbb28b17cc60405160405180910390a4610cc5565b6126693382613e3d565b612686576040516345f3c98360e11b815260040160405180910390fd5b50565b60008061269585612029565b5091509150866001600160a01b0316826001600160a01b0316146126cc5760405163e146af6f60e01b815260040160405180910390fd5b6001600160a01b038616301480156126e357508385145b1561270157604051633d76b10760e01b815260040160405180910390fd5b61270a86613ee0565b612715858786613f97565b612720878787614088565b6001600160a01b0387166000908152600160208190526040822080549192909161274b9084906158b0565b9091555061275c90508585886140b0565b6001600160a01b038616600090815260016020819052604082208054919290916127879084906158c3565b9091555061279b905082878387898861410f565b50505050505050565b81516000908190815b818110156127fc57846001600160401b03168682815181106127d1576127d16157c0565b60200260200101516001600160401b0316036127f4579250600191506128069050565b6001016127ad565b5060008092509250505b9250929050565b6000818152600460205260409020600101546001600160a01b03166126865760405163089ba7e160e41b815260040160405180910390fd5b600061285082611580565b60008381526002602090815260408083206001600160a01b038581168086529190935281842080546001600160a01b031916938916938417905590519394508593919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259190a4505050565b6128c83382614210565b61268657604051635d64832960e01b815260040160405180910390fd5b6128f0838383613d47565b6128fb838383613def565b6000838152600d602090815260408083206001600160401b0385168085529252808320805460ff1916905551909185917f1010837a46db9510cad56c9b63e97183557a136e9d4ddbec309ce52c99afb1249190a3505050565b60008061296084612029565b5091509150856001600160a01b0316826001600160a01b0316146129975760405163e146af6f60e01b815260040160405180910390fd5b6001600160a01b0385166129be576040516338f646ff60e21b815260040160405180910390fd5b6129c9868686614088565b6001600160a01b038616600090815260016020819052604082208054919290916129f49084906158b0565b90915550612a069050846000876140b0565b6001600160a01b03851660009081526001602081905260408220805491929091612a319084906158c3565b909155505060405184906001600160a01b0380881691908916907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90600090a483856001600160a01b0316876001600160a01b03167f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d846000604051611718929190918252602082015260400190565b600260005403612ae4576040516362bfeae960e11b815260040160405180910390fd5b6002600055565b6040808201516001600160401b0390811660009081526010602090815283822054606086015186518452601383528584206001600160a01b039283168086529084528685209582168552949092529390912060020154919290911615612b645760405163bd0650ab60e01b815260040160405180910390fd5b612b7283604001518261428e565b6000612b8684600001518560200151610f68565b60208101518151608087015160405163074334fb60e01b815230600482015260248101929092526001600160401b039081166044830152851660648201529192506001600160a01b03169063074334fb90608401602060405180830381865afa158015612bf7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c1b91906158d6565b612c3857604051632c36cd3360e01b815260040160405180910390fd5b6020810151604051636e5bceab60e11b81526001600160401b03841660048201526001600160a01b0391821660248201529084169063dcb79d5690604401602060405180830381865afa158015612c93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cb791906158d6565b612cd457604051637228eff560e11b815260040160405180910390fd5b6040805160808082018352868301516001600160401b0390811683529087015181166020808401918252855184860190815286820180516001600160a01b03908116606088019081528c516000908152601386528981208d8416825286528981208c8916825286528981208951815498518a16600160401b026fffffffffffffffffffffffffffffffff1990991699169890981796909617875592516001808801919091559251600290960180549682166001600160a01b0319909716969096179095558a5184526014835286842090519094168352928152848220865183529052928320805492939192909190612dcd9084906158c3565b92505081905550826001600160401b031685604001516001600160401b031686600001517f1f5de02b1d9c93ca468f54630e1daf13f6dc458a63f8061ff73e85bf9bc38884856000015186602001518a60800151604051612e53939291909283526001600160a01b039190911660208301526001600160401b0316604082015260600190565b60405180910390a4611c88565b6040516318d5243360e21b81526001600160401b038084166004808401919091529083166024830152606060448301526064820152630c1e0d8d60e21b60848201523090819063635490cc9060a401600060405180830381600087803b158015612ec957600080fd5b505af115801561279b573d6000803e3d6000fd5b6000612ee882611580565b6000838152600f602090815260408083206001600160a01b038581168086529190935281842080546001600160a01b031916938916938417905590519394508593919290917fb90cc0d925ac3511ab6af2d7ca73ffcf7ec4bd871fff36b958ecf440079c463e9190a4505050565b6001600160401b0383161580612f7357506001600160401b038116155b15612f91576040516312c33ce360e01b815260040160405180910390fd5b6001600160401b0383811660008181526015602090815260408083206001600160a01b03881680855290835292819020805467ffffffffffffffff19169587169586179055519182527f5b5af0622001a9b735a56357ddc1abd65e6a640126498674daf9d2fb0516072591015b60405180910390a3505050565b613015338261432e565b612686576040516302728a9d60e41b815260040160405180910390fd5b60008281526006602052604090205481101561306157604051631e73178b60e11b815260040160405180910390fd5b6000828152600660205260408120613078916149b4565b60405182907f8ac4a0d65950c3e40448afb2260e2e0ec36ea15644d9b39e37e85472e5f9445190600090a25050565b60008060006130b585612029565b509150915060006130c586611580565b90506130d383600088614088565b60408051602080820183526000918290526001600160a01b038616825260019081905291812080549091906131099084906158b0565b9091555061311a9050600087612845565b6131238661439a565b600061312e87611730565b600088815260056020526040812091925061314991906149b4565b6000878152600660205260408120613160916149b4565b60008781526002602090815260408083206001600160a01b0386168452909152812080546001600160a01b031916905581518190815b818110156133655789831061320f578481815181106131b7576131b76157c0565b6020026020010151602001518582815181106131d5576131d56157c0565b6020908102919091010151516040516306177b2560e41b81526001600160a01b039092166004830152602482015260440160405180910390fd5b60076000868381518110613225576132256157c0565b6020026020010151602001516001600160a01b03166001600160a01b031681526020019081526020016000206000868381518110613265576132656157c0565b602002602001015160000151815260200190815260200160002060009055828a03935084818151811061329a5761329a6157c0565b6020026020010151602001516001600160a01b031663b390c0ab8683815181106132c6576132c66157c0565b6020026020010151600001516001876132df91906158b0565b6040516001600160e01b031960e085901b168152600481019290925260248201526044016020604051808303816000875af1158015613322573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061334691906158f3565b6133519060016158c3565b61335b90846158c3565b9250600101613196565b5060008a81526004602052604080822082815560010180546001600160a01b0319169055518b91906001600160a01b038a16907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908390a4604080518781526000602082018190528c9290916001600160a01b038b16917f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d910160405180910390a46040805160208101909152600090525098975050505050505050565b61342f84848484612954565b61343b848484846143a5565b610f3d5760405163bcb5663760e01b815260040160405180910390fd5b6001600160401b03808316600090815260106020908152604080832054878452601383528184206001600160a01b039182168086529084528285208787168652845293829020825160808101845281548088168252600160401b90049096169386019390935260018301549185019190915260029091015416606083018190529091906134f8576040516317de7dd760e21b815260040160405180910390fd5b60008581526013602090815260408083206001600160a01b0380871685529083528184206001600160401b0388168552835281842080546fffffffffffffffffffffffffffffffff191681556001808201869055600290910180546001600160a01b0319169055898552601484528285206060870151909216855290835281842085830151855290925282208054919290916135959084906158b0565b92505081905550826001600160401b0316846001600160401b0316867f438e039ebbba8f290f3b5d41aaf3295eccc9b5e6b0e1d52ace700772afb7da13846040015185606001518660200151604051612e53939291909283526001600160a01b039190911660208301526001600160401b0316604082015260600190565b6000838152600a60205260409020548190811461364357604051633581be1d60e11b815260040160405180910390fd5b6000848152600c6020526040902061365c9084846149d5565b5060405184907ff0bfd70b0068f973d58178846ca67112671ec45e060838f7de5662036bcf801790600090a2610f3d565b816136db5760008881526014602090815260408083206001600160a01b03881684528252808320868452909152902054156136db57604051630619dc9d60e21b815260040160405180910390fd5b6136eb88888888888888886144a4565b5050505050505050565b805160208201516001600160401b038216613723576040516312c33ce360e01b815260040160405180910390fd5b6001600160401b03821660009081526017602052604081205460ff1660028111156137505761375061535d565b1461376e57604051630fbdf8dd60e01b815260040160405180910390fd5b6000815160028111156137835761378361535d565b036137a157604051630b65407360e01b815260040160405180910390fd5b6002815160028111156137b6576137b661535d565b1480156137c7575060408101515115155b156137e557604051630b65407360e01b815260040160405180910390fd5b6001600160401b03821660009081526017602052604090208151815483929190829060ff1916600183600281111561381f5761381f61535d565b0217905550602082810151825460ff9091166101000261ff0019909116178255604083015180516138569260018501920190614a51565b506060820151600282019061386b9082615952565b5050601980546001810182556000919091527f944998273e477b495144fb8794c914197f3ccb46be2900f4698fd0ef743c96956004820401805460039092166008026101000a6001600160401b03818102199093169286160291909117905550805160028111156138de576138de61535d565b826001600160401b03167fc4715b52aed3b9dfb2fbdc63e39e234892ec1dd3811d2c671646dbfd3d32d92e836020015184604001518560600151604051612ffe93929190615a11565b8061393181614685565b6001600160401b038216600081815260186020526040808220805460ff19166001179055517f540b0b22993accb6c2b7b0f4a5bd1b7e6419708ef2a68c39f09f01c848ba4fbc9190a25050565b6000828152600b6020526040902054818111156139ae57604051635134ce8960e01b815260040160405180910390fd5b60005b81811015613a2c576000848152600b602052604081208054839081106139d9576139d96157c0565b6000918252602080832060048304015488845260098252604080852060039094166008026101000a9091046001600160401b031684529190529020805467ffffffffffffffff19169055506001016139b1565b506000838152600b60205260408120613a4491614aa6565b60405160009084907f1010837a46db9510cad56c9b63e97183557a136e9d4ddbec309ce52c99afb124908390a3505050565b6000613a828585611bff565b9050613a8f818484614704565b6001600160a01b038316600090815260076020908152604080832085845290915290205415613ad15760405163188a497360e01b815260040160405180910390fd5b6000858152600660205260409020613ae99085614748565b600085815260056020908152604080832080546001808201835591855283852086516002909202019081558584015190820180546001600160a01b0319166001600160a01b03928316179055871680855260078452828520878652845293829020555186815284929188917f29486b9e2ae569b440933a9b1b421467306fa21f3dcad439c262910a634963a99101612e53565b6001600160a01b038416613ba3576040516325bd6bd360e01b815260040160405180910390fd5b6000838152600460205260409020600101546001600160a01b031615613bdc5760405163c5a8d37160e01b815260040160405180910390fd5b82613bfa576040516312c33ce360e01b815260040160405180910390fd5b613c0660008585614088565b6001600160a01b03841660009081526001602081905260408220805491929091613c319084906158c3565b90915550506040805180820182529283526001600160a01b039485166020808501918252600095865260049052932091518255509051600190910180546001600160a01b03191691909216179055565b6001600160401b038216613ca8576040516312c33ce360e01b815260040160405180910390fd5b6001600160401b03821660009081526008602052604081208054613ccb90615815565b90501115613cec576040516308fe3c3160e41b815260040160405180910390fd5b6001600160401b0382166000908152600860205260409020613d0e8282615952565b506040516001600160401b038316907f3cd061096eaf881067d936308fbd8b81d060c45ab2ec910c02b953162befc10990600090a25050565b6000838152600b60205260409020548210613d7557604051630757d52160e01b815260040160405180910390fd5b6000838152600b60205260409020805483908110613d9557613d956157c0565b90600052602060002090600491828204019190066008029054906101000a90046001600160401b03166001600160401b0316816001600160401b031614610e08576040516378eeeecf60e01b815260040160405180910390fd5b6000838152600b60205260409020613e079083614802565b60009283526009602090815260408085206001600160401b039093168552919052909120805467ffffffffffffffff1916905550565b6000806000613e4b84612029565b509150915080600014613e6e57506001600160a01b038481169116149050610a23565b816001600160a01b0316856001600160a01b03161480613eb357506001600160a01b0380831660009081526003602090815260408083209389168352929052205460ff165b80613ed75750846001600160a01b0316613ecc85610d3b565b6001600160a01b0316145b95945050505050565b806001600160a01b03163b600003613f0b5760405163b9d3114760e01b815260040160405180910390fd5b6040516301ffc9a760e01b81526342b0e56f60e01b60048201526001600160a01b038216906301ffc9a790602401602060405180830381865afa158015613f56573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613f7a91906158d6565b61268657604051631784ec7360e21b815260040160405180910390fd5b60005b606481101561406e576000806000856001600160a01b031663fb25fb7a866040518263ffffffff1660e01b8152600401613fd691815260200190565b606060405180830381865afa158015613ff3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140179190615a49565b9250925092508061402b5750505050505050565b6001600160a01b0383163014801561404257508682145b15614060576040516324543e6d60e11b815260040160405180910390fd5b509093509150600101613f9a565b50604051630349a6bd60e51b815260040160405180910390fd5b6140938184846118f6565b610e085760405163792fac8360e11b815260040160405180910390fd5b6040805180820182528381526001600160a01b038381166020808401918252600088815260049091529384209251835551600190920180546001600160a01b031916929091169190911790556141069084612845565b610e088361439a565b6040516318d5243360e21b815285906001600160a01b0382169063635490cc9061414190879087908790600401615a81565b600060405180830381600087803b15801561415b57600080fd5b505af115801561416f573d6000803e3d6000fd5b5050505082866001600160a01b0316886001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a482866001600160a01b0316886001600160a01b03167f04444026cefd1b05506559cab59d1b865ae3ba4ed2fe5c894f04e522776c552d8888604051614203929190918252602082015260400190565b60405180910390a461279b565b60008061421c83611580565b9050806001600160a01b0316846001600160a01b0316148061426357506001600160a01b038082166000908152600e602090815260408083209388168352929052205460ff165b8061192f5750836001600160a01b031661427c84611fdc565b6001600160a01b031614949350505050565b6001600160401b0382166000908152601260209081526040808320805482518185028101850190935280835261430d9386939291908301828280156124e957600091825260209182902080546001600160401b031684529082028301929091600891018084116124a657905050505050506127a490919063ffffffff16565b91505080610e0857604051634ef44ed560e01b815260040160405180910390fd5b60008061433a83611580565b9050806001600160a01b0316846001600160a01b0316148061438157506001600160a01b0380821660009081526003602090815260408083209388168352929052205460ff165b8061192f5750836001600160a01b031661427c84610d3b565b612686600082612edd565b60006001600160a01b0384163b1561449957604051630a85bd0160e11b81526001600160a01b0385169063150b7a02906143e9903390899088908890600401615aa0565b6020604051808303816000875af1925050508015614424575060408051601f3d908101601f1916820190925261442191810190615ad2565b60015b61447f573d808015614452576040519150601f19603f3d011682016040523d82523d6000602084013e614457565b606091505b5080516144775760405163bcb5663760e01b815260040160405180910390fd5b805181602001fd5b6001600160e01b031916630a85bd0160e11b14905061192f565b506001949350505050565b604080518082019091526000808252602082015282156144cf576144c88987611bff565b90506144dc565b6144d98987610f68565b90505b6144e7818686614704565b821561450a5760008981526006602052604090206145059087614748565b614544565b6001600160a01b038516600090815260076020908152604080832087845282528083208390558b8352600590915290206145449087614748565b6001600160a01b0388161561462e57866145c157604051635c46a7ef60e11b81526001600160a01b0386169063b88d4fde9061458a9030908c9089908890600401615aa0565b600060405180830381600087803b1580156145a457600080fd5b505af11580156145b8573d6000803e3d6000fd5b5050505061462e565b60208101518151604051630326051d60e11b81526001600160a01b039092169163064c0a3a916145fb9130918d918d908990600401615aef565b600060405180830381600087803b15801561461557600080fd5b505af1158015614629573d6000803e3d6000fd5b505050505b6040805187815284151560208201526001600160a01b038a81161582840152915186928816918c917f02d6d6dbcb604d5e1e8c7886456e82a9cdce88b0a580071358f206b5a4d58f709181900360600190a4611f7d565b6001600160401b03811660009081526017602052604081205460ff16908160028111156146b4576146b461535d565b036146d2576040516307ae018160e21b815260040160405180910390fd5b60028160028111156146e6576146e661535d565b0361104a5760405163ae6a3b7760e01b815260040160405180910390fd5b82602001516001600160a01b0316826001600160a01b031614158061472a575082518114155b15610e0857604051637383f2c160e11b815260040160405180910390fd5b81548290614758906001906158b0565b81548110614768576147686157c0565b9060005260206000209060020201828281548110614788576147886157c0565b600091825260209091208254600290920201908155600191820154910180546001600160a01b0319166001600160a01b0390921691909117905581548290806147d3576147d3615b27565b60008281526020812060026000199093019283020190815560010180546001600160a01b031916905590555050565b8154811061482357604051634e23d03560e01b815260040160405180910390fd5b81548290614833906001906158b0565b81548110614843576148436157c0565b90600052602060002090600491828204019190066008029054906101000a90046001600160401b031682828154811061487e5761487e6157c0565b90600052602060002090600491828204019190066008026101000a8154816001600160401b0302191690836001600160401b03160217905550818054806148c7576148c7615b27565b60008281526020902060046000199092019182040180546001600160401b03600860038516026101000a021916905590555050565b828054828255906000526020600020906003016004900481019282156149a45791602002820160005b8382111561496f57835183826101000a8154816001600160401b0302191690836001600160401b031602179055509260200192600801602081600701049283019260010302614925565b80156149a25782816101000a8154906001600160401b03021916905560080160208160070104928301926001030261496f565b505b506149b0929150614ac7565b5090565b50805460008255600202906000526020600020908101906126869190614adc565b828054828255906000526020600020906003016004900481019282156149a45791602002820160005b8382111561496f5783356001600160401b031683826101000a8154816001600160401b0302191690836001600160401b0316021790555092602001926008016020816007010492830192600103026149fe565b8280548282559060005260206000209081019282156149a4579160200282015b828111156149a457825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190614a71565b50805460008255600301600490049060005260206000209081019061268691905b5b808211156149b05760008155600101614ac8565b5b808211156149b057600081556001810180546001600160a01b0319169055600201614add565b6001600160e01b03198116811461268657600080fd5b600060208284031215614b2b57600080fd5b8135614b3681614b03565b9392505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715614b7b57614b7b614b3d565b604052919050565b600082601f830112614b9457600080fd5b81356001600160401b03811115614bad57614bad614b3d565b614bc0601f8201601f1916602001614b53565b818152846020838601011115614bd557600080fd5b816020850160208301376000918101602001919091529392505050565b60006001600160401b03821115614c0b57614c0b614b3d565b5060051b60200190565b6001600160a01b038116811461268657600080fd5b600082601f830112614c3b57600080fd5b81356020614c50614c4b83614bf2565b614b53565b82815260059290921b84018101918181019086841115614c6f57600080fd5b8286015b84811015614c93578035614c8681614c15565b8352918301918301614c73565b509695505050505050565b60008060408385031215614cb157600080fd5b82356001600160401b0380821115614cc857600080fd5b614cd486838701614b83565b93506020850135915080821115614cea57600080fd5b50614cf785828601614c2a565b9150509250929050565b600080600080600060a08688031215614d1957600080fd5b8535614d2481614c15565b94506020860135614d3481614c15565b9350604086013592506060860135915060808601356001600160401b03811115614d5d57600080fd5b614d6988828901614b83565b9150509295509295909350565b80356001600160401b0381168114614d8d57600080fd5b919050565b60008060008060808587031215614da857600080fd5b8435614db381614c15565b935060208501359250614dc860408601614d76565b9150614dd660608601614d76565b905092959194509250565b600060208284031215614df357600080fd5b5035919050565b60008060408385031215614e0d57600080fd5b8235614e1881614c15565b946020939093013593505050565b6000815180845260005b81811015614e4c57602081850181015186830182015201614e30565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000614b366020830184614e26565b600081518084526020808501945080840160005b83811015614eb85781516001600160401b031687529582019590820190600101614e93565b509495945050505050565b602081526000614b366020830184614e7f565b60008060408385031215614ee957600080fd5b8235614ef481614c15565b91506020830135614f0481614c15565b809150509250929050565b600080600060608486031215614f2457600080fd5b8335925060208401359150614f3b60408501614d76565b90509250925092565b600080600060608486031215614f5957600080fd5b8335614f6481614c15565b92506020840135614f7481614c15565b929592945050506040919091013590565b60008060408385031215614f9857600080fd5b50508035926020909101359150565b815181526020808301516001600160a01b03169082015260408101610a23565b600060a08284031215614fd957600080fd5b60405160a081018181106001600160401b0382111715614ffb57614ffb614b3d565b8060405250809150823581526020830135602082015261501d60408401614d76565b604082015261502e60608401614d76565b606082015261503f60808401614d76565b60808201525092915050565b600060a0828403121561505d57600080fd5b614b368383614fc7565b602080825282518282018190526000919060409081850190868401855b828110156150ba576150aa848351805182526020908101516001600160a01b0316910152565b9284019290850190600101615084565b5091979650505050505050565b600080604083850312156150da57600080fd5b823591506150ea60208401614d76565b90509250929050565b6080815260006151066080830187614e26565b6001600160401b03861660208401526001600160a01b038516604084015282810360608401526151368185614e7f565b979650505050505050565b6000806040838503121561515457600080fd5b61515d83614d76565b915060208301356001600160401b0381111561517857600080fd5b614cf785828601614b83565b60008060006060848603121561519957600080fd5b833592506020840135915060408401356001600160401b038111156151bd57600080fd5b6151c986828701614b83565b9150509250925092565b6000806000606084860312156151e857600080fd5b6151f184614d76565b9250602084013561520181614c15565b9150614f3b60408501614d76565b60006020828403121561522157600080fd5b8135614b3681614c15565b60008060006060848603121561524157600080fd5b83359250602084013561520181614c15565b801515811461268657600080fd5b6000806040838503121561527457600080fd5b823561527f81614c15565b91506020830135614f0481615253565b6000806000606084860312156152a457600080fd5b8335925060208401356152b681614c15565b915060408401356152c681614c15565b809150509250925092565b600060208083850312156152e457600080fd5b82356001600160401b038111156152fa57600080fd5b8301601f8101851361530b57600080fd5b8035615319614c4b82614bf2565b81815260059190911b8201830190838101908783111561533857600080fd5b928401925b828410156151365761534e84614d76565b8252928401929084019061533d565b634e487b7160e01b600052602160045260246000fd5b600081518084526020808501945080840160005b83811015614eb85781516001600160a01b031687529582019590820190600101615387565b60008151600381106153ce57634e487b7160e01b600052602160045260246000fd5b8084525060ff60208301511660208401526040820151608060408501526153f86080850182615373565b905060608301518482036060860152613ed78282614e26565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561546657603f198886030184526154548583516153ac565b94509285019290850190600101615438565b5092979650505050505050565b6000806000806080858703121561548957600080fd5b843561549481614c15565b935060208501356154a481614c15565b92506040850135915060608501356001600160401b038111156154c657600080fd5b6154d287828801614b83565b91505092959194509250565b6000806000606084860312156154f357600080fd5b8335925061520160208501614d76565b60006020828403121561551557600080fd5b614b3682614d76565b602081526000614b3660208301846153ac565b6000806040838503121561554457600080fd5b614ef483614d76565b60008060006040848603121561556257600080fd5b8335925060208401356001600160401b038082111561558057600080fd5b818601915086601f83011261559457600080fd5b8135818111156155a357600080fd5b8760208260051b85010111156155b857600080fd5b6020830194508093505050509250925092565b600080600080600080600080610100898b0312156155e857600080fd5b8835975060208901356155fa81614c15565b96506040890135955060608901359450608089013561561881614c15565b935060a0890135925060c089013561562f81615253565b915060e08901356001600160401b0381111561564a57600080fd5b6156568b828c01614b83565b9150509295985092959890939650565b60008060006060848603121561567b57600080fd5b83356001600160401b038082111561569257600080fd5b61569e87838801614c2a565b945060208601359150808211156156b457600080fd5b506156c186828701614b83565b925050614f3b60408501614d76565b600080600080608085870312156156e657600080fd5b843593506020850135925060408501356156ff81614c15565b9396929550929360600135925050565b60008060006060848603121561572457600080fd5b833592506020840135614f7481614c15565b600080600080610100858703121561574d57600080fd5b61575685614d76565b9350602085013561576681614c15565b925061577460408601614d76565b9150614dd68660608701614fc7565b634e487b7160e01b600052601160045260246000fd5b6001600160401b038181168382160190808211156157b9576157b9615783565b5092915050565b634e487b7160e01b600052603260045260246000fd5b6000600182016157e8576157e8615783565b5060010190565b60006001600160401b0380831681810361580b5761580b615783565b6001019392505050565b600181811c9082168061582957607f821691505b60208210810361584957634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561586157600080fd5b8151614b3681614c15565b6020808252825182820181905260009190848201906040850190845b818110156158a457835183529284019291840191600101615888565b50909695505050505050565b81810381811115610a2357610a23615783565b80820180821115610a2357610a23615783565b6000602082840312156158e857600080fd5b8151614b3681615253565b60006020828403121561590557600080fd5b5051919050565b601f821115610e0857600081815260208120601f850160051c810160208610156159335750805b601f850160051c820191505b81811015610cc55782815560010161593f565b81516001600160401b0381111561596b5761596b614b3d565b61597f816159798454615815565b8461590c565b602080601f8311600181146159b4576000841561599c5750858301515b600019600386901b1c1916600185901b178555610cc5565b600085815260208120601f198616915b828110156159e3578886015182559484019460019091019084016159c4565b5085821015615a015787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60ff84168152606060208201526000615a2d6060830185615373565b8281036040840152615a3f8185614e26565b9695505050505050565b600080600060608486031215615a5e57600080fd5b8351615a6981614c15565b6020850151604086015191945092506152c681615253565b838152826020820152606060408201526000613ed76060830184614e26565b60006001600160a01b03808716835280861660208401525083604083015260806060830152615a3f6080830184614e26565b600060208284031215615ae457600080fd5b8151614b3681614b03565b60006001600160a01b03808816835280871660208401525084604083015283606083015260a0608083015261513660a0830184614e26565b634e487b7160e01b600052603160045260246000fdfea26469706673582212200c510224d5dbe6ed17d2244bce49cb5d78257e1d48ad10bb924ae1f4672adf1764736f6c63430008150033",
  "devdoc": {
    "errors": {
      "RMRKIdZeroForbidden()": [
        {
          "details": "The ID 0 in RMRK suite is reserved for empty values. Guarding against its use ensures the expected operation"
        }
      ],
      "RMRKMaxRecursiveBurnsReached(address,uint256)": [
        {
          "params": {
            "childContract": "Address of the collection smart contract in which the maximum number of recursive burns was reached",
            "childId": "ID of the child token at which the maximum number of recursive burns was reached"
          }
        }
      ],
      "RMRKNotApprovedOrDirectOwner()": [
        {
          "details": "When a token is nested, only the direct owner (NFT parent) can mange it. In that case, approved addresses are  not allowed to manage it, in order to ensure the expected behaviour"
        }
      ]
    },
    "events": {
      "AddedEquippables(uint64,address[])": {
        "details": "It is emitted when new addresses are marked as equippable for `partId`.",
        "params": {
          "equippableAddresses": "An array of the new addresses that can equip this part",
          "partId": "ID of the part that had new equippable addresses added"
        }
      },
      "AddedPart(uint64,uint8,uint8,address[],string)": {
        "details": "It is emitted when a new part is added.",
        "params": {
          "equippableAddresses": "An array of addresses that can equip this part",
          "itemType": "Enum value specifying whether the part is `None`, `Slot` and `Fixed`",
          "metadataURI": "The metadata URI of the part",
          "partId": "ID of the part that was added",
          "zIndex": "An uint specifying the z value of the part. It is used to specify the depth which the part should  be rendered at"
        }
      },
      "AllChildrenRejected(uint256)": {
        "details": "Emitted when a token removes all a child tokens from its pending array.",
        "params": {
          "tokenId": "ID of the token that rejected all of the pending children"
        }
      },
      "Approval(address,address,uint256)": {
        "details": "Emitted when `owner` enables `approved` to manage the `tokenId` token."
      },
      "ApprovalForAll(address,address,bool)": {
        "details": "Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets."
      },
      "ApprovalForAllForAssets(address,address,bool)": {
        "params": {
          "approved": "Boolean value signifying whether the permission has been granted (`true`) or revoked (`false`)",
          "operator": "Address of the account that has been granted the approval to manage the token's assets on all of  the tokens",
          "owner": "Address of the account that has granted the approval for all assets on all of their tokens"
        }
      },
      "ApprovalForAssets(address,address,uint256)": {
        "details": "Approvals must be cleared on transfer",
        "params": {
          "approved": "Address of the account that has been granted approval to manage the token's assets",
          "owner": "Address of the account that has granted the approval for all token's assets",
          "tokenId": "ID of the token on which the approval was granted"
        }
      },
      "AssetAccepted(uint256,uint64,uint64)": {
        "params": {
          "assetId": "ID of the asset that was accepted",
          "replacesId": "ID of the asset that was replaced",
          "tokenId": "ID of the token that had a new asset accepted"
        }
      },
      "AssetAddedToTokens(uint256[],uint64,uint64)": {
        "params": {
          "assetId": "ID of the asset that has been added to the token's pending assets array",
          "replacesId": "ID of the asset that would be replaced",
          "tokenIds": "An array of token IDs that received a new pending asset"
        }
      },
      "AssetPrioritySet(uint256)": {
        "params": {
          "tokenId": "ID of the token that had the asset priority array updated"
        }
      },
      "AssetRejected(uint256,uint64)": {
        "params": {
          "assetId": "ID of the asset that was rejected",
          "tokenId": "ID of the token that had an asset rejected"
        }
      },
      "AssetSet(uint64)": {
        "params": {
          "assetId": "ID of the asset that was initialized"
        }
      },
      "ChildAccepted(uint256,uint256,address,uint256)": {
        "details": "Emitted when a parent token accepts a token from its pending array, migrating it to the active array.",
        "params": {
          "childAddress": "Address of the child token's collection smart contract",
          "childId": "ID of the child token in the child token's collection smart contract",
          "childIndex": "Index of the newly accepted child token in the parent token's active children array",
          "tokenId": "ID of the token that accepted a new child token"
        }
      },
      "ChildAssetEquipped(uint256,uint64,uint64,uint256,address,uint64)": {
        "params": {
          "assetId": "ID of the asset associated with the token we are equipping into",
          "childAddress": "Address of the child token's collection",
          "childAssetId": "ID of the asset associated with the token we are equipping",
          "childId": "ID of the child token we are equipping into the slot",
          "slotPartId": "ID of the slot we are using to equip",
          "tokenId": "ID of the token that had an asset equipped"
        }
      },
      "ChildAssetUnequipped(uint256,uint64,uint64,uint256,address,uint64)": {
        "params": {
          "assetId": "ID of the asset associated with the token we are unequipping out of",
          "childAddress": "Address of the collection that a token that is being unequipped belongs to",
          "childAssetId": "ID of the asset associated with the token we are unequipping",
          "childId": "ID of the token being unequipped",
          "slotPartId": "ID of the slot we are unequipping from",
          "tokenId": "ID of the token that had an asset unequipped"
        }
      },
      "ChildProposed(uint256,uint256,address,uint256)": {
        "details": "Emitted when a child NFT is added to a token's pending array.",
        "params": {
          "childAddress": "Address of the proposed child token's collection smart contract",
          "childId": "ID of the child token in the child token's collection smart contract",
          "childIndex": "Index of the proposed child token in the parent token's pending children array",
          "tokenId": "ID of the token that received a new pending child token"
        }
      },
      "ChildTransferred(uint256,uint256,address,uint256,bool,bool)": {
        "details": "Emitted when a token transfers a child from itself, transferring ownership to the root owner.",
        "params": {
          "childAddress": "Address of the child token's collection smart contract",
          "childId": "ID of the child token in the child token's collection smart contract",
          "childIndex": "Index of a child in the array from which it is being transferred",
          "fromPending": "A boolean value signifying whether the token was in the pending child tokens array (`true`) or  in the active child tokens array (`false`)",
          "toZero": "A boolean value signifying whether the token is being transferred to the `0x0` address (`true`) or  not (`false`)",
          "tokenId": "ID of the token that transferred a child token"
        }
      },
      "NestTransfer(address,address,uint256,uint256,uint256)": {
        "details": "Emitted when `tokenId` token is transferred from `from` to `to`.",
        "params": {
          "from": "Address of the previous immediate owner, which is a smart contract if the token was nested.",
          "fromTokenId": "ID of the previous parent token. If the token was not nested before, the value should be `0`",
          "to": "Address of the new immediate owner, which is a smart contract if the token is being nested.",
          "toTokenId": "ID of the new parent token. If the token is not being nested, the value should be `0`",
          "tokenId": "ID of the token being transferred"
        }
      },
      "SetEquippableToAll(uint64)": {
        "details": "It is emitted when a given part is marked as equippable by any.",
        "params": {
          "partId": "ID of the part marked as equippable by any address"
        }
      },
      "SetEquippables(uint64,address[])": {
        "details": "It is emitted when the existing list of addresses marked as equippable for `partId` is overwritten by a new one.",
        "params": {
          "equippableAddresses": "The new, full, list of addresses that can equip this part",
          "partId": "ID of the part whose list of equippable addresses was overwritten"
        }
      },
      "Soulbound(uint256,bool)": {
        "params": {
          "state": "A boolean value signifying whether the token became soulbound (`true`) or transferrable (`false`)",
          "tokenId": "ID of the token"
        }
      },
      "Transfer(address,address,uint256)": {
        "details": "Emitted when `tokenId` token is transferred from `from` to `to`."
      },
      "ValidParentEquippableGroupIdSet(uint64,uint64,address)": {
        "params": {
          "equippableGroupId": "ID of the equippable group being marked as equippable into the slot associated with  `slotPartId` of the `parentAddress` collection",
          "parentAddress": "Address of the collection into which the parts belonging to `equippableGroupId` can be  equipped",
          "slotPartId": "ID of the slot part of the catalog into which the parts belonging to the equippable group  associated with `equippableGroupId` can be equipped"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "RMRK_INTERFACE()": {
        "returns": {
          "rmrkInterface": "Interface identifier for implementations of the @rmrk-team/evm-contracts package"
        }
      },
      "VERSION()": {
        "returns": {
          "version": "Version identifier for implementations of the @rmrk-team/evm-contracts package"
        }
      },
      "acceptAsset(uint256,uint256,uint64)": {
        "details": "Migrates the asset from the token's pending asset array to the token's active asset array.Active assets cannot be removed by anyone, but can be replaced by a new asset.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.  - `index` must be in range of the length of the pending asset array.Emits an {AssetAccepted} event.",
        "params": {
          "assetId": "ID of the asset that is being accepted",
          "index": "Index of the asset in the pending array to accept",
          "tokenId": "ID of the token for which to accept the pending asset"
        }
      },
      "acceptChild(uint256,uint256,address,uint256)": {
        "details": "This moves the child token from parent token's pending child tokens array into the active child tokens  array.",
        "params": {
          "childAddress": "Address of the collection smart contract of the child token expected to be located at the  specified index of the given parent token's pending children array",
          "childId": "ID of the child token expected to be located at the specified index of the given parent token's  pending children array",
          "childIndex": "Index of a child tokem in the given parent's pending children array",
          "parentId": "ID of the parent token for which the child token is being accepted"
        }
      },
      "addChild(uint256,uint256,bytes)": {
        "details": "This adds the child token into the given parent token's pending child tokens array.Requirements:  - `directOwnerOf` on the child contract must resolve to the called contract.  - the pending array of the parent contract must not be full.",
        "params": {
          "childId": "ID of the new proposed child token",
          "data": "Additional data with no specified format",
          "parentId": "ID of the parent token to receive the new child token"
        }
      },
      "approve(address,uint256)": {
        "details": "Gives permission to `to` to transfer `tokenId` token to another account.The approval is cleared when the token is transferred.Only a single account can be approved at a time, so approving the zero address clears previous approvals.Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist.Emits an {Approval} event.",
        "params": {
          "to": "Address receiving the approval",
          "tokenId": "ID of the token for which the approval is being granted"
        }
      },
      "approveForAssets(address,uint256)": {
        "details": "This can only be called by the owner of the token or by an account that has been granted permission to  manage all of the owner's assets.",
        "params": {
          "to": "Address of the account to receive the approval to the specified token",
          "tokenId": "ID of the token for which we are granting the permission"
        }
      },
      "balanceOf(address)": {
        "params": {
          "owner": "Address of the account being checked"
        },
        "returns": {
          "balance": "The balance of the given account"
        }
      },
      "burn(uint256)": {
        "details": "In case the token has any child tokens, the execution will be reverted.",
        "params": {
          "tokenId": "ID of the token to burn"
        }
      },
      "burn(uint256,uint256)": {
        "details": "When a token is burned, all of its child tokens are recursively burned as well.When specifying the maximum recursive burns, the execution will be reverted if there are more children to be  burned.Setting the `maxRecursiveBurn` value to 0 will only attempt to burn the specified token and revert if there  are any child tokens present.The approvals are cleared when the token is burned.Requirements:  - `tokenId` must exist.Emits a {Transfer} event.",
        "params": {
          "maxRecursiveBurns": "Maximum number of tokens to recursively burn",
          "tokenId": "ID of the token to burn"
        },
        "returns": {
          "burnedChildren": "Number of recursively burned children"
        }
      },
      "canTokenBeEquippedWithAssetIntoSlot(address,uint256,uint64,uint64)": {
        "params": {
          "assetId": "ID of the asset associated with the token we want to equip",
          "parent": "Address of the parent token's smart contract",
          "slotId": "ID of the slot that we want to equip the token into",
          "tokenId": "ID of the token we want to equip"
        },
        "returns": {
          "canBeEquipped": "A boolean indicating whether the token with the given asset can be equipped into the desired slot"
        }
      },
      "checkIsEquippable(uint64,address)": {
        "details": "Returns true if a collection may equip asset with `partId`.",
        "params": {
          "partId": "The ID of the part that we are checking",
          "targetAddress": "The address that we are checking for whether the part can be equipped into it or not"
        },
        "returns": {
          "isEquippable": "The status indicating whether the `targetAddress` can be equipped into `Part` with `partId` or not"
        }
      },
      "checkIsEquippableToAll(uint64)": {
        "details": "Returns true if part is equippable to all.",
        "params": {
          "partId": "ID of the part that we are checking"
        },
        "returns": {
          "isEquippable": "The status indicating whether the part with `partId` can be equipped by any address or not"
        }
      },
      "childOf(uint256,uint256)": {
        "details": "Returns a single Child struct locating at `index` of parent token's active child tokens array.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]",
        "params": {
          "index": "Index of the child token in the parent token's active child tokens array",
          "parentId": "ID of the parent token for which the child is being retrieved"
        },
        "returns": {
          "child": "A Child struct containing data about the specified child"
        }
      },
      "childrenOf(uint256)": {
        "details": "Returns array of Child structs existing for parent token.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]",
        "params": {
          "parentId": "ID of the parent token for which to retrieve the active child tokens"
        },
        "returns": {
          "children": "An array of Child structs containing the parent token's active child tokens"
        }
      },
      "directOwnerOf(uint256)": {
        "details": "If the immediate owner is another token, the address returned, should be the one of the parent token's  collection smart contract.",
        "params": {
          "tokenId": "ID of the token for which the RMRK owner is being retrieved"
        },
        "returns": {
          "isNFT": "The boolean value signifying whether the owner is an NFT or not",
          "owner_": "Address of the given token's owner",
          "parentId": "The ID of the parent token. Should be `0` if the owner is an externally owned account"
        }
      },
      "equip((uint256,uint256,uint64,uint64,uint64))": {
        "details": "The `IntakeEquip` stuct contains the following data:  [      tokenId,      childIndex,      assetId,      slotPartId,      childAssetId  ]",
        "params": {
          "data": "An `IntakeEquip` struct specifying the equip data"
        }
      },
      "getActiveAssetPriorities(uint256)": {
        "details": "Asset priorities are a non-sequential array of uint64 values with an array size equal to active asset  priorites.",
        "params": {
          "tokenId": "ID of the token for which to retrieve the priorities of the active assets"
        },
        "returns": {
          "priorities": "An array of priorities of the active assets of the given token"
        }
      },
      "getActiveAssets(uint256)": {
        "details": "Asset data is stored by reference, in order to access the data corresponding to the ID, call  `getAssetMetadata(tokenId, assetId)`.You can safely get 10k",
        "params": {
          "tokenId": "ID of the token to retrieve the IDs of the active assets"
        },
        "returns": {
          "assetIds": "An array of active asset IDs of the given token"
        }
      },
      "getApproved(uint256)": {
        "details": "Requirements:  - `tokenId` must exist.",
        "params": {
          "tokenId": "ID of the token to check for approval"
        },
        "returns": {
          "approved": "Address of the account approved to manage the token"
        }
      },
      "getApprovedForAssets(uint256)": {
        "details": "Requirements:  - `tokenId` must exist.",
        "params": {
          "tokenId": "ID of the token for which to retrieve the approved address"
        },
        "returns": {
          "approved": "Address of the account that is approved to manage the specified token's assets"
        }
      },
      "getAssetAndEquippableData(uint256,uint64)": {
        "params": {
          "assetId": "ID of the asset of which we are retrieving",
          "tokenId": "ID of the token for which to retrieve the asset"
        },
        "returns": {
          "catalogAddress": "The address of the catalog the part belongs to",
          "equippableGroupId": "ID of the equippable group this asset belongs to",
          "metadataURI": "The metadata URI of the asset",
          "partIds": "An array of IDs of parts included in the asset"
        }
      },
      "getAssetMetadata(uint256,uint64)": {
        "details": "Assets are stored by reference mapping `_assets[assetId]`.Can be overriden to implement enumerate, fallback or other custom logic.",
        "params": {
          "assetId": "Asset Id, must be in the active assets array",
          "tokenId": "ID of the token from which to retrieve the asset metadata"
        },
        "returns": {
          "metadata": "The metadata of the asset belonging to the specified index in the token's active assets  array"
        }
      },
      "getAssetReplacements(uint256,uint64)": {
        "details": "Asset data is stored by reference, in order to access the data corresponding to the ID, call  `getAssetMetadata(tokenId, assetId)`.",
        "params": {
          "newAssetId": "ID of the pending asset which will be accepted",
          "tokenId": "ID of the token to check"
        },
        "returns": {
          "replacesAssetId": "ID of the asset which will be replaced"
        }
      },
      "getEquipment(uint256,address,uint64)": {
        "details": "The `Equipment` struct consists of the following data:  [      assetId,      childAssetId,      childId,      childEquippableAddress  ]",
        "params": {
          "slotPartId": "ID of the `Slot` part that we are checking for equipped objects",
          "targetCatalogAddress": "Address of the `Catalog` associated with the `Slot` part of the token",
          "tokenId": "ID of the token for which we are retrieving the equipped object"
        },
        "returns": {
          "equipment": "The `Equipment` struct containing data about the equipped object"
        }
      },
      "getMetadataURI()": {
        "returns": {
          "_0": "Catalog metadata URI"
        }
      },
      "getPart(uint64)": {
        "params": {
          "partId": "ID of the part that we are retrieving"
        },
        "returns": {
          "part": "The `Part` struct associated with given `partId`"
        }
      },
      "getParts(uint64[])": {
        "params": {
          "partIds": "An array of part IDs that we want to retrieve"
        },
        "returns": {
          "parts": "An array of `Part` structs associated with given `partIds`"
        }
      },
      "getPendingAssets(uint256)": {
        "details": "Asset data is stored by reference, in order to access the data corresponding to the ID, call  `getAssetMetadata(tokenId, assetId)`.",
        "params": {
          "tokenId": "ID of the token to retrieve the IDs of the pending assets"
        },
        "returns": {
          "assetIds": "An array of pending asset IDs of the given token"
        }
      },
      "getType()": {
        "returns": {
          "_0": "`itemType` of the associated Catalog"
        }
      },
      "isApprovedForAll(address,address)": {
        "params": {
          "operator": "Address being checked for approval",
          "owner": "Address of the owner of the tokens"
        },
        "returns": {
          "isApproved": "A boolean value signifying whether the *operator* is allowed to manage the tokens of the *owner* (`true`)  or not (`false`)"
        }
      },
      "isApprovedForAllForAssets(address,address)": {
        "details": "See {setApprovalForAllForAssets}.",
        "params": {
          "operator": "Address of the account that we are checking whether it has the operator role or not",
          "owner": "Address of the account that we are checking for whether it has granted the operator role"
        },
        "returns": {
          "isApproved": "A boolean value indicating whether the account we are checking has been granted the operator role"
        }
      },
      "isChildEquipped(uint256,address,uint256)": {
        "details": "This is used to prevent from transferring a child that is equipped.",
        "params": {
          "childAddress": "Address of the child token's smart contract",
          "childId": "ID of the child token",
          "tokenId": "ID of the parent token for which we are querying for"
        },
        "returns": {
          "isEquipped": "A boolean value indicating whether the child token is equipped into the given token or not"
        }
      },
      "isTransferable(uint256,address,address)": {
        "details": "If this function returns `false`, the transfer of the token MUST revert execution.If the tokenId does not exist, this method MUST revert execution, unless the token is being checked for  minting.",
        "params": {
          "from": "Address from which the token is being transferred",
          "to": "Address to which the token is being transferred",
          "tokenId": "ID of the token being checked"
        },
        "returns": {
          "isTransferable_": "Boolean value indicating whether the given token is transferable"
        }
      },
      "nestTransferFrom(address,address,uint256,uint256,bytes)": {
        "params": {
          "data": "Additional data with no specified format, sent in the addChild call",
          "destinationId": "ID of the token to receive the token being transferred",
          "from": "Address of the direct owner of the token to be transferred",
          "to": "Address of the receiving token's collection smart contract",
          "tokenId": "ID of the token being transferred"
        }
      },
      "ownerOf(uint256)": {
        "details": "The *root* owner of the token is an externally owned account (EOA). If the given token is child of another  NFT, this will return an EOA address. Otherwise, if the token is owned by an EOA, this EOA will be returned.",
        "params": {
          "tokenId": "ID of the token for which the *root* owner has been retrieved"
        },
        "returns": {
          "owner_": "The *root* owner of the token"
        }
      },
      "pendingChildOf(uint256,uint256)": {
        "details": "Returns a single Child struct locating at `index` of parent token's active child tokens array.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]",
        "params": {
          "index": "Index of the child token in the parent token's pending child tokens array",
          "parentId": "ID of the parent token for which the pending child token is being retrieved"
        },
        "returns": {
          "child": "A Child struct containting data about the specified child"
        }
      },
      "pendingChildrenOf(uint256)": {
        "details": "Returns array of pending Child structs existing for given parent.The Child struct consists of the following values:  [      tokenId,      contractAddress  ]",
        "params": {
          "parentId": "ID of the parent token for which to retrieve the pending child tokens"
        },
        "returns": {
          "children": "An array of Child structs containing the parent token's pending child tokens"
        }
      },
      "rejectAllAssets(uint256,uint256)": {
        "details": "Effecitvely deletes the pending array.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.Emits a {AssetRejected} event with assetId = 0.",
        "params": {
          "maxRejections": "Maximum number of expected assets to reject, used to prevent from rejecting assets which  arrive just before this operation.",
          "tokenId": "ID of the token of which to clear the pending array."
        }
      },
      "rejectAllChildren(uint256,uint256)": {
        "details": "Removes the children from the pending array mapping.This does not update the ownership storage data on children. If necessary, ownership can be reclaimed by the  rootOwner of the previous parent.Requirements: Requirements: - `parentId` must exist",
        "params": {
          "maxRejections": "Maximum number of expected children to reject, used to prevent from rejecting children which  arrive just before this operation.",
          "parentId": "ID of the parent token for which to reject all of the pending tokens."
        }
      },
      "rejectAsset(uint256,uint256,uint64)": {
        "details": "Removes the asset from the token's pending asset array.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.  - `index` must be in range of the length of the pending asset array.Emits a {AssetRejected} event.",
        "params": {
          "assetId": "ID of the asset that is being rejected",
          "index": "Index of the asset in the pending array to be rejected",
          "tokenId": "ID of the token that the asset is being rejected from"
        }
      },
      "safeTransferFrom(address,address,uint256)": {
        "details": "Requirements:  - `from` cannot be the zero address.  - `to` cannot be the zero address.  - `tokenId` token must exist and be owned by `from`.  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.  - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.Emits a {Transfer} event.",
        "params": {
          "from": "Address to transfer the tokens from",
          "to": "Address to transfer the tokens to",
          "tokenId": "ID of the token to transfer"
        }
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "details": "Requirements:  - `from` cannot be the zero address.  - `to` cannot be the zero address.  - `tokenId` token must exist and be owned by `from`.  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.  - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.Emits a {Transfer} event.",
        "params": {
          "data": "Additional data without a specified format to be sent along with the token transaction",
          "from": "Address to transfer the tokens from",
          "to": "Address to transfer the tokens to",
          "tokenId": "ID of the token to transfer"
        }
      },
      "setApprovalForAll(address,bool)": {
        "details": "Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.Requirements: - The `operator` cannot be the caller.Emits an {ApprovalForAll} event.",
        "params": {
          "approved": "A boolean value signifying whether the approval is being granted (`true`) or (`revoked`)",
          "operator": "Address of the operator being managed"
        }
      },
      "setApprovalForAllForAssets(address,bool)": {
        "details": "Operators can call {acceptAsset}, {rejectAsset}, {rejectAllAssets} or {setPriority} for any token  owned by the caller.Requirements:  - The `operator` cannot be the caller.Emits an {ApprovalForAllForAssets} event.",
        "params": {
          "approved": "The boolean value indicating whether the operator role is being granted (`true`) or revoked  (`false`)",
          "operator": "Address of the account to which the operator role is granted or revoked from"
        }
      },
      "setPriority(uint256,uint64[])": {
        "details": "The priority array is a non-sequential list of `uint64`s, where the lowest value is considered highest  priority.Value `0` of a priority is a special case equivalent to unitialized.Requirements:  - The caller must own the token or be approved to manage the token's assets  - `tokenId` must exist.  - The length of `priorities` must be equal the length of the active assets array.Emits a {AssetPrioritySet} event.",
        "params": {
          "priorities": "An array of priority values",
          "tokenId": "ID of the token to set the priorities for"
        }
      },
      "transferChild(uint256,address,uint256,uint256,address,uint256,bool,bytes)": {
        "details": "When transferring a child token, the owner of the token is set to `to`, or is not updated in the event of  `to` being the `0x0` address.",
        "params": {
          "childAddress": "Address of the child token's collection smart contract.",
          "childId": "ID of the child token in its own collection smart contract.",
          "childIndex": "Index of a token we are transferring, in the array it belongs to (can be either active array or  pending array)",
          "data": "Additional data with no specified format, sent in call to `_to`",
          "destinationId": "ID of the token to receive this child token (MUST be 0 if the destination is not a token)",
          "isPending": "A boolean value indicating whether the child token being transferred is in the pending array of  the parent token (`true`) or in the active array (`false`)",
          "to": "Address to which to transfer the token to",
          "tokenId": "ID of the parent token from which the child token is being transferred"
        }
      },
      "transferFrom(address,address,uint256)": {
        "details": "Requirements:  - `from` cannot be the zero address.  - `to` cannot be the zero address.  - `tokenId` token must be owned by `from`.  - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.Emits a {Transfer} event.",
        "params": {
          "from": "Address from which to transfer the token from",
          "to": "Address to which to transfer the token to",
          "tokenId": "ID of the token to transfer"
        }
      },
      "unequip(uint256,uint64,uint64)": {
        "details": "This can only be called by the owner of the token or by an account that has been granted permission to  manage the given token by the current owner.",
        "params": {
          "assetId": "ID of the parent's asset that contains the `Slot` into which the child is equipped",
          "slotPartId": "ID of the `Slot` from which to unequip the child",
          "tokenId": "ID of the parent from which the child is being unequipped"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "ERC721AddressZeroIsNotaValidOwner()": [
        {
          "notice": "Attempting to grant the token to 0x0 address"
        }
      ],
      "ERC721ApprovalToCurrentOwner()": [
        {
          "notice": "Attempting to grant approval to the current owner of the token"
        }
      ],
      "ERC721ApproveCallerIsNotOwnerNorApprovedForAll()": [
        {
          "notice": "Attempting to grant approval when not being owner or approved for all should not be permitted"
        }
      ],
      "ERC721ApproveToCaller()": [
        {
          "notice": "Attempting to grant approval to self"
        }
      ],
      "ERC721InvalidTokenId()": [
        {
          "notice": "Attempting to use an invalid token ID"
        }
      ],
      "ERC721MintToTheZeroAddress()": [
        {
          "notice": "Attempting to mint to 0x0 address"
        }
      ],
      "ERC721NotApprovedOrOwner()": [
        {
          "notice": "Attempting to manage a token without being its owner or approved by the owner"
        }
      ],
      "ERC721TokenAlreadyMinted()": [
        {
          "notice": "Attempting to mint an already minted token"
        }
      ],
      "ERC721TransferFromIncorrectOwner()": [
        {
          "notice": "Attempting to transfer the token from an address that is not the owner"
        }
      ],
      "ERC721TransferToNonReceiverImplementer()": [
        {
          "notice": "Attempting to safe transfer to an address that is unable to receive the token"
        }
      ],
      "ERC721TransferToTheZeroAddress()": [
        {
          "notice": "Attempting to transfer the token to a 0x0 address"
        }
      ],
      "RMRKApprovalForAssetsToCurrentOwner()": [
        {
          "notice": "Attempting to grant approval of assets to their current owner"
        }
      ],
      "RMRKApproveForAssetsCallerIsNotOwnerNorApprovedForAll()": [
        {
          "notice": "Attempting to grant approval of assets without being the caller or approved for all"
        }
      ],
      "RMRKAssetAlreadyExists()": [
        {
          "notice": "Attempting to add an asset using an ID that has already been used"
        }
      ],
      "RMRKBadConfig()": [
        {
          "notice": "Attempting to incorrectly configue a Catalog item"
        }
      ],
      "RMRKBadPriorityListLength()": [
        {
          "notice": "Attempting to set the priorities with an array of length that doesn't match the length of active assets array"
        }
      ],
      "RMRKCannotTransferSoulbound()": [
        {
          "notice": "Attempting to transfer a soulbound (non-transferrable) token"
        }
      ],
      "RMRKCatalogRequiredForParts()": [
        {
          "notice": "Attempting to add an asset entry with `Part`s, without setting the `Catalog` address"
        }
      ],
      "RMRKChildAlreadyExists()": [
        {
          "notice": "Attempting to accept a child that has already been accepted"
        }
      ],
      "RMRKChildIndexOutOfRange()": [
        {
          "notice": "Attempting to interact with a child, using index that is higher than the number of children"
        }
      ],
      "RMRKEquippableEquipNotAllowedByCatalog()": [
        {
          "notice": "Attempting to equip a `Part` with a child not approved by the Catalog"
        }
      ],
      "RMRKIdZeroForbidden()": [
        {
          "notice": "Attempting to use ID 0, which is not supported"
        }
      ],
      "RMRKIndexOutOfRange()": [
        {
          "notice": "Attempting to interact with an asset, using index greater than number of assets"
        }
      ],
      "RMRKIsNotContract()": [
        {
          "notice": "Attempting to interact with an end-user account when the contract account is expected"
        }
      ],
      "RMRKMaxPendingAssetsReached()": [
        {
          "notice": "Attempting to add a pending asset after the number of pending assets has reached the limit (default limit is  128)"
        }
      ],
      "RMRKMaxPendingChildrenReached()": [
        {
          "notice": "Attempting to add a pending child after the number of pending children has reached the limit (default limit is 128)"
        }
      ],
      "RMRKMaxRecursiveBurnsReached(address,uint256)": [
        {
          "notice": "Attempting to burn a total number of recursive children higher than maximum set"
        }
      ],
      "RMRKMustUnequipFirst()": [
        {
          "notice": "Attempting to transfer a child before it is unequipped"
        }
      ],
      "RMRKNestableTooDeep()": [
        {
          "notice": "Attempting to nest a child over the nestable limit (current limit is 100 levels of nesting)"
        }
      ],
      "RMRKNestableTransferToDescendant()": [
        {
          "notice": "Attempting to nest the token to own descendant, which would create a loop and leave the looped tokens in limbo"
        }
      ],
      "RMRKNestableTransferToNonRMRKNestableImplementer()": [
        {
          "notice": "Attempting to nest the token to a smart contract that doesn't support nesting"
        }
      ],
      "RMRKNestableTransferToSelf()": [
        {
          "notice": "Attempting to nest the token into itself"
        }
      ],
      "RMRKNoAssetMatchingId()": [
        {
          "notice": "Attempting to interact with an asset that can not be found"
        }
      ],
      "RMRKNotApprovedForAssetsOrOwner()": [
        {
          "notice": "Attempting to manage an asset without owning it or having been granted permission by the owner to do so"
        }
      ],
      "RMRKNotApprovedOrDirectOwner()": [
        {
          "notice": "Attempting to interact with a token without being its owner or having been granted permission by the  owner to do so"
        }
      ],
      "RMRKNotEquipped()": [
        {
          "notice": "Attempting to unequip an item that isn't equipped"
        }
      ],
      "RMRKPartAlreadyExists()": [
        {
          "notice": "Attempting to add a `Part` with an ID that is already used"
        }
      ],
      "RMRKPartDoesNotExist()": [
        {
          "notice": "Attempting to use a `Part` that doesn't exist"
        }
      ],
      "RMRKPartIsNotSlot()": [
        {
          "notice": "Attempting to use a `Part` that is `Fixed` when `Slot` kind of `Part` should be used"
        }
      ],
      "RMRKPendingChildIndexOutOfRange()": [
        {
          "notice": "Attempting to interact with a pending child using an index greater than the size of pending array"
        }
      ],
      "RMRKSlotAlreadyUsed()": [
        {
          "notice": "Attempting to equip an item into a slot that already has an item equipped"
        }
      ],
      "RMRKTargetAssetCannotReceiveSlot()": [
        {
          "notice": "Attempting to equip an item into a `Slot` that the target asset does not implement"
        }
      ],
      "RMRKTokenCannotBeEquippedWithAssetIntoSlot()": [
        {
          "notice": "Attempting to equip a child into a `Slot` and parent that the child's collection doesn't support"
        }
      ],
      "RMRKTokenDoesNotHaveAsset()": [
        {
          "notice": "Attempting to compose a NFT of a token without active assets"
        }
      ],
      "RMRKUnexpectedAssetId()": [
        {
          "notice": "Attempting to accept or reject an asset which does not match the one at the specified index"
        }
      ],
      "RMRKUnexpectedChildId()": [
        {
          "notice": "Attempting to accept or transfer a child which does not match the one at the specified index"
        }
      ],
      "RMRKUnexpectedNumberOfAssets()": [
        {
          "notice": "Attempting to reject all pending assets but more assets than expected are pending"
        }
      ],
      "RMRKUnexpectedNumberOfChildren()": [
        {
          "notice": "Attempting to reject all pending children but children assets than expected are pending"
        }
      ]
    },
    "events": {
      "AddedEquippables(uint64,address[])": {
        "notice": "Event to announce new equippables to the part."
      },
      "AddedPart(uint64,uint8,uint8,address[],string)": {
        "notice": "Event to announce addition of a new part."
      },
      "AllChildrenRejected(uint256)": {
        "notice": "Used to notify listeners that all pending child tokens of a given token have been rejected."
      },
      "ApprovalForAllForAssets(address,address,bool)": {
        "notice": "Used to notify listeners that owner has granted approval to the user to manage assets of all of their  tokens."
      },
      "ApprovalForAssets(address,address,uint256)": {
        "notice": "Used to notify listeners that owner has granted an approval to the user to manage the assets of a  given token."
      },
      "AssetAccepted(uint256,uint64,uint64)": {
        "notice": "Used to notify listeners that an asset object at `assetId` is accepted by the token and migrated  from token's pending assets array to active assets array of the token."
      },
      "AssetAddedToTokens(uint256[],uint64,uint64)": {
        "notice": "Used to notify listeners that an asset object at `assetId` is added to token's pending asset  array."
      },
      "AssetPrioritySet(uint256)": {
        "notice": "Used to notify listeners that token's prioritiy array is reordered."
      },
      "AssetRejected(uint256,uint64)": {
        "notice": "Used to notify listeners that an asset object at `assetId` is rejected from token and is dropped  from the pending assets array of the token."
      },
      "AssetSet(uint64)": {
        "notice": "Used to notify listeners that an asset object is initialized at `assetId`."
      },
      "ChildAccepted(uint256,uint256,address,uint256)": {
        "notice": "Used to notify listeners that a new child token was accepted by the parent token."
      },
      "ChildAssetEquipped(uint256,uint64,uint64,uint256,address,uint64)": {
        "notice": "Used to notify listeners that a child's asset has been equipped into one of its parent assets."
      },
      "ChildAssetUnequipped(uint256,uint64,uint64,uint256,address,uint64)": {
        "notice": "Used to notify listeners that a child's asset has been unequipped from one of its parent assets."
      },
      "ChildProposed(uint256,uint256,address,uint256)": {
        "notice": "Used to notify listeners that a new token has been added to a given token's pending children array."
      },
      "ChildTransferred(uint256,uint256,address,uint256,bool,bool)": {
        "notice": "Used to notify listeners a child token has been transferred from parent token."
      },
      "NestTransfer(address,address,uint256,uint256,uint256)": {
        "notice": "Used to notify listeners that the token is being transferred."
      },
      "SetEquippableToAll(uint64)": {
        "notice": "Event to announce that a given part can be equipped by any address."
      },
      "SetEquippables(uint64,address[])": {
        "notice": "Event to announce the overriding of equippable addresses of the part."
      },
      "Soulbound(uint256,bool)": {
        "notice": "Emitted when a token's soulbound state changes."
      },
      "ValidParentEquippableGroupIdSet(uint64,uint64,address)": {
        "notice": "Used to notify listeners that the assets belonging to a `equippableGroupId` have been marked as  equippable into a given slot and parent"
      }
    },
    "kind": "user",
    "methods": {
      "RMRK_INTERFACE()": {
        "notice": "Interface identifier of the @rmrk-team/evm-contracts package"
      },
      "VERSION()": {
        "notice": "Version of the @rmrk-team/evm-contracts package"
      },
      "acceptAsset(uint256,uint256,uint64)": {
        "notice": "Accepts a asset at from the pending array of given token."
      },
      "acceptChild(uint256,uint256,address,uint256)": {
        "notice": "Used to accept a pending child token for a given parent token."
      },
      "addChild(uint256,uint256,bytes)": {
        "notice": "Used to add a child token to a given parent token."
      },
      "approve(address,uint256)": {
        "notice": "Used to grant a one-time approval to manage one's token."
      },
      "approveForAssets(address,uint256)": {
        "notice": "Used to grant approvals for specific tokens to a specified address."
      },
      "balanceOf(address)": {
        "notice": "Used to retrieve the number of tokens in `owner`'s account."
      },
      "burn(uint256)": {
        "notice": "Used to burn a given token."
      },
      "burn(uint256,uint256)": {
        "notice": "Used to burn a given token."
      },
      "canTokenBeEquippedWithAssetIntoSlot(address,uint256,uint64,uint64)": {
        "notice": "Used to verify whether a token can be equipped into a given parent's slot."
      },
      "checkIsEquippable(uint64,address)": {
        "notice": "Used to check whether the given address is allowed to equip the desired `Part`."
      },
      "checkIsEquippableToAll(uint64)": {
        "notice": "Used to check if the part is equippable by all addresses."
      },
      "childOf(uint256,uint256)": {
        "notice": "Used to retrieve a specific active child token for a given parent token."
      },
      "childrenOf(uint256)": {
        "notice": "Used to retrieve the active child tokens of a given parent token."
      },
      "directOwnerOf(uint256)": {
        "notice": "Used to retrieve the immediate owner of the given token."
      },
      "equip((uint256,uint256,uint64,uint64,uint64))": {
        "notice": "Used to equip a child into a token."
      },
      "getActiveAssetPriorities(uint256)": {
        "notice": "Used to retrieve the priorities of the active resoources of a given token."
      },
      "getActiveAssets(uint256)": {
        "notice": "Used to retrieve IDs of the active assets of given token."
      },
      "getApproved(uint256)": {
        "notice": "Used to retrieve the account approved to manage given token."
      },
      "getApprovedForAssets(uint256)": {
        "notice": "Used to retrieve the address of the account approved to manage assets of a given token."
      },
      "getAssetAndEquippableData(uint256,uint64)": {
        "notice": "Used to get the asset and equippable data associated with given `assetId`."
      },
      "getAssetMetadata(uint256,uint64)": {
        "notice": "Used to fetch the asset metadata of the specified token's active asset with the given index."
      },
      "getAssetReplacements(uint256,uint64)": {
        "notice": "Used to retrieve the asset that will be replaced if a given asset from the token's pending array  is accepted."
      },
      "getEquipment(uint256,address,uint64)": {
        "notice": "Used to get the Equipment object equipped into the specified slot of the desired token."
      },
      "getMetadataURI()": {
        "notice": "Used to return the metadata URI of the associated Catalog."
      },
      "getPart(uint64)": {
        "notice": "Used to retrieve a `Part` with id `partId`"
      },
      "getParts(uint64[])": {
        "notice": "Used to retrieve multiple parts at the same time."
      },
      "getPendingAssets(uint256)": {
        "notice": "Used to retrieve IDs of the pending assets of given token."
      },
      "getType()": {
        "notice": "Used to return the `itemType` of the associated Catalog"
      },
      "isApprovedForAll(address,address)": {
        "notice": "Used to check if the given address is allowed to manage the tokens of the specified address."
      },
      "isApprovedForAllForAssets(address,address)": {
        "notice": "Used to check whether the address has been granted the operator role by a given address or not."
      },
      "isChildEquipped(uint256,address,uint256)": {
        "notice": "Used to check whether the token has a given child equipped."
      },
      "isTransferable(uint256,address,address)": {
        "notice": "Used to check whether the given token is transferable or not."
      },
      "nestTransferFrom(address,address,uint256,uint256,bytes)": {
        "notice": "Used to transfer the token into another token."
      },
      "ownerOf(uint256)": {
        "notice": "Used to retrieve the *root* owner of a given token."
      },
      "pendingChildOf(uint256,uint256)": {
        "notice": "Used to retrieve a specific pending child token from a given parent token."
      },
      "pendingChildrenOf(uint256)": {
        "notice": "Used to retrieve the pending child tokens of a given parent token."
      },
      "rejectAllAssets(uint256,uint256)": {
        "notice": "Rejects all assets from the pending array of a given token."
      },
      "rejectAllChildren(uint256,uint256)": {
        "notice": "Used to reject all pending children of a given parent token."
      },
      "rejectAsset(uint256,uint256,uint64)": {
        "notice": "Rejects a asset from the pending array of given token."
      },
      "safeTransferFrom(address,address,uint256)": {
        "notice": "Used to safely transfer a given token token from `from` to `to`."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "notice": "Used to safely transfer a given token token from `from` to `to`."
      },
      "setApprovalForAll(address,bool)": {
        "notice": "Used to approve or remove `operator` as an operator for the caller."
      },
      "setApprovalForAllForAssets(address,bool)": {
        "notice": "Used to add or remove an operator of assets for the caller."
      },
      "setPriority(uint256,uint64[])": {
        "notice": "Sets a new priority array for a given token."
      },
      "transferChild(uint256,address,uint256,uint256,address,uint256,bool,bytes)": {
        "notice": "Used to transfer a child token from a given parent token."
      },
      "transferFrom(address,address,uint256)": {
        "notice": "Transfers a given token from `from` to `to`."
      },
      "unequip(uint256,uint64,uint64)": {
        "notice": "Used to unequip child from parent token."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11029,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 8603,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_balances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 8609,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_tokenApprovals",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_address))"
      },
      {
        "astId": 8615,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_operatorApprovals",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 8620,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_RMRKOwners",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_struct(DirectOwner)4990_storage)"
      },
      {
        "astId": 8626,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_activeChildren",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint256,t_array(t_struct(Child)5051_storage)dyn_storage)"
      },
      {
        "astId": 8632,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_pendingChildren",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_array(t_struct(Child)5051_storage)dyn_storage)"
      },
      {
        "astId": 8638,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_childIsInActive",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 2299,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_assets",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint64,t_string_storage)"
      },
      {
        "astId": 2306,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_assetReplacements",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint256,t_mapping(t_uint64,t_uint64))"
      },
      {
        "astId": 2312,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_activeAssets",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_uint256,t_array(t_uint64)dyn_storage)"
      },
      {
        "astId": 2318,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_pendingAssets",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_uint256,t_array(t_uint64)dyn_storage)"
      },
      {
        "astId": 2324,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_activeAssetPriorities",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_uint256,t_array(t_uint64)dyn_storage)"
      },
      {
        "astId": 2331,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_tokenAssets",
        "offset": 0,
        "slot": "13",
        "type": "t_mapping(t_uint256,t_mapping(t_uint64,t_bool))"
      },
      {
        "astId": 2338,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_operatorApprovalsForAssets",
        "offset": 0,
        "slot": "14",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 6314,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_tokenApprovalsForAssets",
        "offset": 0,
        "slot": "15",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_address))"
      },
      {
        "astId": 6319,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_catalogAddresses",
        "offset": 0,
        "slot": "16",
        "type": "t_mapping(t_uint64,t_address)"
      },
      {
        "astId": 6324,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_equippableGroupIds",
        "offset": 0,
        "slot": "17",
        "type": "t_mapping(t_uint64,t_uint64)"
      },
      {
        "astId": 6330,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_partIds",
        "offset": 0,
        "slot": "18",
        "type": "t_mapping(t_uint64,t_array(t_uint64)dyn_storage)"
      },
      {
        "astId": 6340,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_equipments",
        "offset": 0,
        "slot": "19",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint64,t_struct(Equipment)4832_storage)))"
      },
      {
        "astId": 6349,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_equipCountPerChild",
        "offset": 0,
        "slot": "20",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint256,t_uint256)))"
      },
      {
        "astId": 6356,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_validParentSlots",
        "offset": 0,
        "slot": "21",
        "type": "t_mapping(t_uint64,t_mapping(t_address,t_uint64))"
      },
      {
        "astId": 10959,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_isSoulbound",
        "offset": 0,
        "slot": "22",
        "type": "t_mapping(t_uint256,t_bool)"
      },
      {
        "astId": 5688,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_parts",
        "offset": 0,
        "slot": "23",
        "type": "t_mapping(t_uint64,t_struct(Part)5433_storage)"
      },
      {
        "astId": 5693,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_isEquippableToAll",
        "offset": 0,
        "slot": "24",
        "type": "t_mapping(t_uint64,t_bool)"
      },
      {
        "astId": 5696,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_partIds",
        "offset": 0,
        "slot": "25",
        "type": "t_array(t_uint64)dyn_storage"
      },
      {
        "astId": 5698,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_metadataURI",
        "offset": 0,
        "slot": "26",
        "type": "t_string_storage"
      },
      {
        "astId": 5700,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "_type",
        "offset": 0,
        "slot": "27",
        "type": "t_string_storage"
      },
      {
        "astId": 4292,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "tokenId",
        "offset": 0,
        "slot": "28",
        "type": "t_uint64"
      },
      {
        "astId": 4295,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "childId",
        "offset": 8,
        "slot": "28",
        "type": "t_uint64"
      },
      {
        "astId": 4298,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "assetId",
        "offset": 16,
        "slot": "28",
        "type": "t_uint64"
      },
      {
        "astId": 4301,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "groupId",
        "offset": 24,
        "slot": "28",
        "type": "t_uint64"
      },
      {
        "astId": 4304,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "partId",
        "offset": 0,
        "slot": "29",
        "type": "t_uint64"
      },
      {
        "astId": 4307,
        "contract": "contracts/Equippable.sol:Equippale",
        "label": "parentTokens",
        "offset": 0,
        "slot": "30",
        "type": "t_array(t_uint64)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Child)5051_storage)dyn_storage": {
        "base": "t_struct(Child)5051_storage",
        "encoding": "dynamic_array",
        "label": "struct IERC7401.Child[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint64)dyn_storage": {
        "base": "t_uint64",
        "encoding": "dynamic_array",
        "label": "uint64[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_enum(ItemType)5421": {
        "encoding": "inplace",
        "label": "enum IRMRKCatalog.ItemType",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_address,t_mapping(t_uint64,t_struct(Equipment)4832_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint64 => struct IERC6220.Equipment))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint64,t_struct(Equipment)4832_storage)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_address,t_uint64)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_mapping(t_uint256,t_array(t_struct(Child)5051_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IERC7401.Child[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(Child)5051_storage)dyn_storage"
      },
      "t_mapping(t_uint256,t_array(t_uint64)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint64[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint64)dyn_storage"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_address))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_address)"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint256,t_uint256)))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => mapping(uint256 => uint256)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint64,t_struct(Equipment)4832_storage)))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => mapping(uint64 => struct IERC6220.Equipment)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_mapping(t_uint64,t_struct(Equipment)4832_storage))"
      },
      "t_mapping(t_uint256,t_mapping(t_uint64,t_bool))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint64 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint64,t_bool)"
      },
      "t_mapping(t_uint256,t_mapping(t_uint64,t_uint64))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint64 => uint64))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint64,t_uint64)"
      },
      "t_mapping(t_uint256,t_struct(DirectOwner)4990_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IERC7401.DirectOwner)",
        "numberOfBytes": "32",
        "value": "t_struct(DirectOwner)4990_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint64,t_address)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint64,t_array(t_uint64)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => uint64[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint64)dyn_storage"
      },
      "t_mapping(t_uint64,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint64,t_mapping(t_address,t_uint64))": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => mapping(address => uint64))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint64)"
      },
      "t_mapping(t_uint64,t_string_storage)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => string)",
        "numberOfBytes": "32",
        "value": "t_string_storage"
      },
      "t_mapping(t_uint64,t_struct(Equipment)4832_storage)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => struct IERC6220.Equipment)",
        "numberOfBytes": "32",
        "value": "t_struct(Equipment)4832_storage"
      },
      "t_mapping(t_uint64,t_struct(Part)5433_storage)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => struct IRMRKCatalog.Part)",
        "numberOfBytes": "32",
        "value": "t_struct(Part)5433_storage"
      },
      "t_mapping(t_uint64,t_uint64)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Child)5051_storage": {
        "encoding": "inplace",
        "label": "struct IERC7401.Child",
        "members": [
          {
            "astId": 5048,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "tokenId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 5050,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "contractAddress",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(DirectOwner)4990_storage": {
        "encoding": "inplace",
        "label": "struct IERC7401.DirectOwner",
        "members": [
          {
            "astId": 4987,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "tokenId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 4989,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "ownerAddress",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Equipment)4832_storage": {
        "encoding": "inplace",
        "label": "struct IERC6220.Equipment",
        "members": [
          {
            "astId": 4825,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "assetId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 4827,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "childAssetId",
            "offset": 8,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 4829,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "childId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 4831,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "childEquippableAddress",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Part)5433_storage": {
        "encoding": "inplace",
        "label": "struct IRMRKCatalog.Part",
        "members": [
          {
            "astId": 5425,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "itemType",
            "offset": 0,
            "slot": "0",
            "type": "t_enum(ItemType)5421"
          },
          {
            "astId": 5427,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "z",
            "offset": 1,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 5430,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "equippable",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 5432,
            "contract": "contracts/Equippable.sol:Equippale",
            "label": "metadataURI",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}